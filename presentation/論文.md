# Health Mirror：基於人工智能的實時健康監測系統
*Health Mirror: AI-Based Real-Time Health Monitoring System*

## 摘要 (Abstract)

在當今數位健康快速發展的時代，傳統健康監測方法面臨著重大挑戰。現有的健康評估體系往往依賴於昂貴的專業設備、需要專業醫療人員的操作，並且通常只能在醫療機構內進行，這導致了定期健康監測在可及性、便利性和成本控制方面存在顯著障礙。隨著現代生活節奏的加快和工作壓力的增大，人們對能夠融入日常生活的便捷、準確且實時的健康監測解決方案需求日益迫切。

Health Mirror 專案致力於通過先進的人工智能技術革新個人健康監測模式，構建一個基於計算機視覺和深度學習的實時健康檢測系統。該系統巧妙地整合了 YOLO 目標檢測框架、OpenCV 圖像處理技術、InsightFace 人臉識別系統以及 DeepSORT 目標追蹤演算法，能夠在標準攝像頭環境下對黑眼圈、唇部狀況和皮膚問題進行精確的實時分析。通過 Django 網頁框架構建的後端系統和線上醫療預約整合功能，形成了從健康檢測、狀況分析到醫療諮詢的完整閉環服務體系。

本論文遵循嚴謹的 IT 專案管理框架，從業務目標識別、可行性研究、利害關係人協調、方法論選擇到詳細實施計畫，對整個專案進行系統化的規劃和闡述。重點關注技術可行性、經濟可行性和市場可行性三個維度，確保技術創新能夠最終轉化為實用、可維運且具有社會價值的解決方案。

## Abstract

In today's rapidly advancing digital health era, traditional health monitoring methods face significant challenges. Existing health assessment systems often rely on expensive professional equipment, require operation by trained medical personnel, and are typically confined to medical facilities, creating substantial barriers in terms of accessibility, convenience, and cost control for regular health monitoring. With the accelerating pace of modern life and increasing work-related stress, there is a growing urgent need for convenient, accurate, and real-time health monitoring solutions that can be seamlessly integrated into daily routines.

The Health Mirror project aims to revolutionize personal health monitoring through advanced artificial intelligence technologies, building a real-time health detection system based on computer vision and deep learning. The system skillfully integrates the YOLO object detection framework, OpenCV image processing technology, InsightFace facial recognition system, and DeepSORT object tracking algorithms, enabling precise real-time analysis of dark circles, lip conditions, and skin problems using standard camera environments. Through a backend system built with the Django web framework and integrated online medical appointment functionality, it creates a complete closed-loop service system from health detection and condition analysis to medical consultation.

This paper follows a rigorous IT project management framework, systematically planning and articulating the entire project from business objective identification, feasibility studies, stakeholder coordination, methodology selection, to detailed implementation plans. The focus is on three dimensions: technical feasibility, economic feasibility, and market feasibility, ensuring that technological innovation can ultimately be transformed into practical, maintainable solutions with social value.

---

## 第一章 介紹 (Chapter I: Introduction)

### 1.1 從業務目標評估中識別潛在的 IT 專案 (Identify potential IT projects from business objectives)

Health Mirror 的業務願景是讓人人皆可獲得便捷、準確與可持續的健康監測。從這一願景出發，首先識別到三類核心 IT 專案：其一是以 YOLO、OpenCV 為核心的「即時影像 AI 健康檢測專案」，在標準攝像頭輸入的條件下快速抽取健康指標；其二是結合 InsightFace 與 DeepSORT 的「個人化辨識與追蹤專案」，用以建立穩定且隱私保護的用戶健康縱向檔案；其三是基於 Django 的「數據平台與醫療預約整合專案」，負責用戶管理、結果呈現、醫療資源路由與合規性保障。這三者共同構成 Health Mirror 的技術底座與服務能力邊界，直接對應既定的可及性、準確性與閉環服務的業務目標。

The business vision of Health Mirror is to make health monitoring accessible, accurate, and sustainable. From this vision, three potential IT projects are identified: an AI-based real-time visual detection project using YOLO and OpenCV; a personalization project leveraging InsightFace and DeepSORT to maintain longitudinal, privacy-preserving user profiles; and a Django-based data platform and medical appointment integration project handling user management, result visualization, routing to care, and compliance. Together, these projects form the technical foundation and service boundary aligned with the established objectives of accessibility, accuracy, and closed-loop care.

### 1.2 專案可行性研究 (Perform a project feasibility study)

技術層面上，YOLO 對小目標與多類別檢測的成熟度，以及 OpenCV 在影像前處理的穩定性，使即時面部健康分析具備落地條件；InsightFace 在人臉特徵嵌入與相似度匹配上的先進性，確保個人化追蹤的精準度；Django 作為後端框架在認證、ORM 與安全性方面完善，利於快速迭代與合規部署。經濟層面上，專案採用開源技術、雲端按需資源與模組化設計，有助於控制前期投入並支撐彈性擴展；商業模式可採免費增值與 B2B 醫療合作並行，逐步建立收益閉環。市場層面上，數位健康與預防醫療需求持續增長，現有競品多聚焦活動監測與生命跡象，對於面部健康特徵的即時評估仍存在差異化空間。綜合觀之，專案在技術、經濟與市場三方面具備可行性。

From a technical perspective, the maturity of YOLO for small-object and multi-class detection and OpenCV for stable preprocessing enables deployable facial analysis; the strength of InsightFace in feature embedding and matching ensures accurate personalization, while Django provides authentication, ORM, and security for rapid iteration and compliant deployment. Economically, open-source stacks, on-demand cloud resources, and modular design reduce upfront costs and support scalable growth; a freemium plus B2B medical partnership model establishes a viable revenue loop. The market shows sustained demand for digital health and preventive care, with a differentiation opportunity in real-time facial health assessment compared to activity/biometric-focused incumbents. Overall, the project is feasible across technical, economic, and market dimensions.

### 1.3 與關鍵利害關係人確立目標與目的 (Determine aims and objectives with key stakeholders)

本專案的核心目標與利害關係人共同制定：對最終用戶而言，目標是提供低門檻、易理解且可行動的健康洞察，並可直接銜接醫療服務；對合作醫院與保險方，目標是提升分診效率、縮短等待時間與優化醫療資源配置；對監管機構，目標是確保資料保護、審計可追與醫療合規；對投資方與合作夥伴，目標是以明確的里程碑驅動可預期的商業化路徑。據此形成量化目的：在 MVP 階段達成主要模型的準確度門檻、完備用戶與預約流程、建立初步合作網絡與用戶驗證，並以循環迭代方式持續提升體驗與可信度。

Project aims are co-defined with stakeholders: for end users, low-barrier, comprehensible, and actionable insights with direct pathways to care; for partner hospitals and insurers, improved triage efficiency, reduced waiting times, and better resource allocation; for regulators, strong data protection, auditable processes, and medical compliance; for investors and partners, milestone-driven commercialization. Quantified objectives include meeting model accuracy thresholds in MVP, completing user and booking flows, securing initial partnerships and user validation, and iteratively improving experience and trust.

### 1.4 審視適用的方法論 (Review suitable project methodologies)

鑑於 AI 專案的探索性與不確定性，高度迭代的敏捷方法論有助於以短週期交付可驗證增量，快速吸收用戶與臨床回饋；螺旋/風險驅動方法可在關鍵技術點（如模型泛化、資料偏差與隱私保護）設置風險門檻與緩解策略；而 DevOps 文化則確保從開發、測試到部署與監控的自動化與一致性，縮短交付鏈路並提升可用性。相較於瀑布模型，以上方法更能匹配「實驗—驗證—調優」的迭代節奏與合規上線的雙重要求。

Given the exploratory nature of AI, Agile supports short-cycle, verifiable increments and rapid incorporation of user/clinical feedback; a spiral/risk-driven layer enforces gates around model generalization, data bias, and privacy; DevOps ensures automation and consistency from build to monitoring, shortening delivery cycles and improving availability. Compared to waterfall, this triad better matches the experiment–validate–optimize rhythm while meeting compliance requirements.

### 1.5 方法論選擇之論證 (Justify the chosen methodology)

Health Mirror 採用「敏捷 + 風險驅動 + DevOps」的混合方法。其合理性在於：AI 檢測與個人化服務涉及多源資料、模型調參與人因變量，需以短迭代持續驗證；同時醫療場景對穩定性與合規有高要求，需以風險門設計確保關鍵品質門檻；而在多模組整合與雲端部署下，CI/CD 與可觀測性是維運效率與用戶體驗的前置條件。此組合既保障了創新的速度，也確保產品成熟度與可靠性。

Health Mirror adopts a hybrid of Agile, risk-driven governance, and DevOps. Short iterations validate models and features amidst data diversity and human factors; risk gates enforce quality for sensitive medical contexts; CI/CD and observability underpin integration and cloud deployment. The combination balances innovation speed with product maturity and reliability.

---

## 第二章 演算法與專案實施計畫 (Chapter II: Algorithms and Implementation Planning)

本章以系統「用到了哪些演算法、為什麼用、如何訓練與部署、如何驗證與優化」為主軸，循序說明從影像前處理、偵測、辨識到追蹤與推論最佳化的完整技術路徑。首先總覽所採用的關鍵演算法與技術元件：YOLO 系列目標偵測、特徵金字塔 FPN/PAN、多尺度資料增強、IoU 家族邊框回歸損失、NMS/Soft-NMS 抑制、OpenCV 前處理（去噪、對比與伽瑪校正、CLAHE、色彩空間轉換、形態學運算、Canny 邊緣偵測、ROI 標準化）、InsightFace + ArcFace 嵌入與餘弦相似度匹配、DeepSORT 以卡爾曼濾波 + 匈牙利演算法 + 外觀嵌入/IoU 做關聯、以及整體推論的並行化與混合精度最佳化。與此同時，我們給出對應的實作細節、訓練與評估流程，以及誤差分析與消融實驗策略，以確保演算法不僅能在研究環境中表現良好，更能穩健落地到實際場景。

This chapter explains which algorithms are used, why they are chosen, how they are trained and deployed, and how they are validated and optimized across preprocessing, detection, recognition, tracking, and inference. Key components include: YOLO object detection, FPN/PAN multi-scale fusion, multi-scale data augmentation, IoU-family box regression losses, NMS/Soft-NMS, OpenCV preprocessing (denoising, contrast/gamma correction, CLAHE, color space transforms, morphology, Canny edges, ROI normalization), InsightFace with ArcFace embeddings and cosine matching, DeepSORT with a Kalman filter, Hungarian assignment, and appearance/IoU association, as well as pipeline-level parallelism and mixed-precision optimization. We detail implementation, training and evaluation, error analysis, and ablations to ensure robustness from lab to real-world deployment.

### 2.1 YOLO 目標檢測與訓練 (YOLO Object Detection and Training)

任務與模型：本系統以 YOLO 系列為主要偵測引擎，針對健康場景打造四套專用權重：DarkCircles.pt（黑眼圈）、Lip_types.pt（唇部狀況/顏色）、skin.pt（皮膚狀況）、health.pt（綜合健康指標），各自聚焦於不同的臨床關聯特徵以提升精準度與召回率。

Tasks and models: We use the YOLO family as the main detection engine with four task-specific weights: DarkCircles.pt (dark circles), Lip_types.pt (lip condition/color), skin.pt (skin condition), and health.pt (composite indicators), each tuned for clinically relevant features to improve precision and recall.

網路架構與頭部：骨幹採輕量化設計以兼顧邊緣裝置，即在保持感受野的同時降低參數量；頸部以 FPN/PAN 融合多尺度語義與細節特徵；偵測頭使用密集預測，輔以 Anchor/Anchor-free 配置與動態特徵分配策略。輸出端透過 NMS 或 Soft-NMS 抑制重疊框，避免重複警示與誤觸發。

Architecture and heads: A lightweight backbone preserves receptive fields with fewer parameters; an FPN/PAN neck fuses multi-scale semantics and details; the dense detection head supports anchor/anchor-free settings with dynamic feature assignment. NMS or Soft-NMS reduces duplicates to prevent redundant alerts.

損失與最佳化：邊框回歸採 IoU 家族（如 GIoU/CIoU/DIoU）強化定位；分類/物件性使用 BCE/Focal Loss 懲罰難例；可搭配 Label smoothing 與 EMA（Exponential Moving Average）穩定收斂。學習率以餘弦退火或 OneCycle 調度，優化器依資料分布在 SGD(momentum) 與 AdamW 之間選擇。

Losses and optimization: IoU-family losses (e.g., GIoU/CIoU/DIoU) for box regression; BCE/Focal for classification/objectness with label smoothing and EMA for stability. Learning rate schedules use cosine or OneCycle; optimizers are chosen between SGD (momentum) and AdamW based on data characteristics.

資料與增強：資料集採分層切分（Train/Val/Test），並於必要時以 K-fold 交叉驗證檢驗穩健性。增強包含 Mosaic/MixUp、RandomAffine/Perspective、Resize、HSV 抖動、水平翻轉與隨機裁切，以擴張長尾樣本與光照/姿態變化覆蓋面。透過 AutoAnchor 或動態錨點調整降低佈局偏差，並以過/欠採樣策略緩解類別不均衡。

Data and augmentation: Stratified splits into Train/Val/Test with optional K-fold cross-validation for robustness. Augmentations include Mosaic, MixUp, RandomAffine/Perspective, Resize, HSV jitter, horizontal flip, and random crop to cover long tails and illumination/pose variations. AutoAnchor or dynamic anchors reduce layout bias; over-/under-sampling mitigates class imbalance.

訓練與評估：採用早停與最佳權重保存（mAP@0.5:0.95 為主選標準），並輸出 PR 曲線、混淆矩陣與 per-class 指標。針對關鍵場景（弱光、遮擋、佩戴口罩/眼鏡）進行情境化測試。錯誤類型（重疊偵測、誤分類混淆、漏檢）將反饋至超參數與增強策略調整。

Training and evaluation: Early stopping with best-weight selection by mAP@0.5:0.95; PR curves, confusion matrices, and per-class metrics are reported. Scenario tests (low light, occlusion, masks/glasses) assess robustness. Error types (duplicate detections, class confusion, misses) feed back into hyperparameter and augmentation tuning.

消融與部署：進行增強策略、損失組合、NMS 閾值與輸入尺寸的消融實驗，量化精度-延遲權衡。推論時依硬體選擇 FP32/FP16（或啟用 AMP），可導出 ONNX 以利跨框架部署；根據負載調整批量大小與影像解析度。

Ablations and deployment: We ablate augmentations, loss combinations, NMS thresholds, and input sizes to quantify accuracy–latency trade-offs. Inference uses FP32/FP16 (or AMP), with optional ONNX export for portability; batch size and resolution are tuned to workload.

### 2.2 OpenCV 影像處理管道 (OpenCV Image Processing Pipeline)

前處理核心：
- 去噪與平滑：高斯/雙邊/中值濾波降低感測器雜訊並保留邊緣；必要時結合非區域均值（NLM）在低光源下抑噪。
- 曝光與對比：線性對比拉伸與伽瑪校正；在 YCrCb/Lab 亮度通道使用 CLAHE 做區域對比增強，改善陰影。
- 色彩校正與恆常性：灰世界（Gray World）與 Shades-of-Gray 白平衡估計，減少色偏對膚色/唇色判讀影響。
- 邊緣與形態學：Canny 邊緣偵測輔助輪廓穩定；膨脹/腐蝕、開閉運算清理小塊雜訊並規整區域邊界。
- 色彩空間：BGR/HSV/YCrCb/Lab 轉換；以 HSV/Lab 測度顏色差異（如 ΔE/平均 a*）支援唇色量化。
- ROI 與幾何：利用臉部框與關鍵點做仿射校正與尺度標準化，提高 YOLO 與辨識的一致性。

Core preprocessing: Gaussian/bilateral/median (and NLM) denoising; contrast/gamma correction and CLAHE on luminance; Gray-World and Shades-of-Gray white balance; Canny edges and morphology (erode/dilate, open/close); color space transforms (BGR/HSV/YCrCb/Lab) with ΔE/a* for color quantification; and ROI/affine normalization with face boxes/landmarks.

特徵量測與輔助判讀：
- 黑眼圈：以眼眶 ROI 的亮度/飽和度分佈與鄰域對比差估計嚴重度。
- 唇部：在 Lab/HSV 估計平均色度與飽和度，結合 ΔE 與皮膚區域作相對度量，提升個體化穩定性。
- 皮膚：以色彩均勻度、紋理統計（如 LBP/GLCM 指標）輔助黃氣/泛紅/斑點的定性偵測，與 YOLO 的類別輸出互為校驗。

Feature measurements: For dark circles, we use luminance/saturation distributions and local contrast around eye sockets; for lips, mean chroma/saturation in Lab/HSV with ΔE against skin as a personalized baseline; for skin, color uniformity and texture stats (e.g., LBP/GLCM) cross-check YOLO classifications.

效能工程：以 ROI 裁切、SIMD/向量化與記憶體重用降低延遲；針對資源緊張環境動態調整解析度與處理頻率，保證畫面流暢與分析準確的平衡。

Performance engineering: ROI cropping, SIMD/vectorization, and memory reuse reduce latency; dynamic resolution and processing cadence balance smoothness and accuracy under resource pressure.

### 2.3 InsightFace 人臉辨識與嵌入 (InsightFace Recognition and Embedding)

對齊與品質控制：使用臉部關鍵點（雙眼、鼻尖、口角）進行仿射對齊，統一尺度與姿態；輸入圖像經品質檢測（模糊度如拉普拉斯方差、遮擋比率、亮度範圍）過濾低質樣本，降低誤匹配。

Alignment and quality control: Landmark-based affine normalization standardizes pose/scale; quality screening (e.g., Laplacian variance for blur, occlusion ratio, luminance range) filters poor samples to reduce mismatches.

嵌入與訓練目標：採用 L2 正規化的 512 維特徵嵌入，訓練時使用 ArcFace 類角度邊界損失（常見設置如 s≈64、m≈0.5）提升類間間隔與類內緊湊度，強化跨光照/年齡/表情條件的判別力。

Embeddings and objectives: L2-normalized 512-D embeddings trained with ArcFace-like angular-margin losses (typical s≈64, m≈0.5) increase inter-class margins and intra-class compactness, improving invariance to illumination, age, and expression.

匹配與樣本庫：以餘弦相似度與可配置閾值做一對一匹配；每位使用者維護多樣本模板，透過移動平均或聚類更新以適應長期外觀漂移。對敏感場景提供匿名化與「僅本地嵌入、分離存放個資」的隱私保護模式。

Matching and galleries: Cosine similarity with configurable thresholds; per-user multi-sample templates updated via moving averages or clustering to adapt to long-term drift. Privacy modes include local-only embeddings and separate storage from PII.

擴展與防偽：可選用簡單活體檢測（眨眼/頭部微動態、紋理反射特徵）作防偽門檻，平衡體驗與安全性需求。

Extensions and anti-spoofing: Optional lightweight liveness checks (blink/micro-motion cues, texture reflectance) provide anti-spoofing with balanced UX and security.

### 2.4 DeepSORT 追蹤與關聯 (DeepSORT Tracking and Association)

狀態模型與預測：採用常速模型的卡爾曼濾波器，狀態向量包含中心座標、縱橫比與高度及其速度分量，對偵測間隙進行時域外推，抑制短暫漏檢引起的抖動。

State and prediction: A constant-velocity Kalman filter with state vector (center coordinates, aspect ratio, height, and their velocities) extrapolates between detections to reduce jitter during brief misses.

關聯度量與指派：以馬氏距離做門檻（基於狀態不確定度的 gating）過濾不可行配對，再以匈牙利演算法求解最小成本指派；成本綜合 IoU 與外觀嵌入的餘弦距離，於遮擋與重疊時仍保持 ID 一致性。

Association and assignment: Mahalanobis gating filters infeasible matches per state uncertainty, followed by the Hungarian algorithm for minimum-cost assignment combining IoU and cosine distances of appearance embeddings to maintain identity through occlusions/overlaps.

軌跡生命週期：新生軌跡需連續命中至 min_hits 方可確認；長時間未匹配則在 max_age 之後銷毀。對於再入場景，藉由外觀向量與空間鄰近恢復先前 ID，降低 ID switch。

Track lifecycle: Tracks are confirmed after min_hits consecutive matches; they are deleted after max_age misses. Re-entry is handled by combining appearance vectors and spatial proximity to recover prior IDs and reduce switches.

### 2.5 推論流程與效能最佳化 (Inference Workflow and Performance Optimization)

端到端流程：攝影機取流 → OpenCV 前處理/白平衡/ROI 標準化 → YOLO 偵測（四模型之一或依場景選擇組合）→ NMS/Soft-NMS → DeepSORT 關聯 →（可選）InsightFace 身份匹配寫回個人記錄 → 結果可視化/事件觸發（如預約建議）。

End-to-end pipeline: Camera capture → OpenCV preprocessing/white balance/ROI normalization → YOLO detection (one or a combo of four models) → NMS/Soft-NMS → DeepSORT association → optional InsightFace identity logging → visualization/event triggers (e.g., appointment suggestions).

併行與低延遲：採多執行緒分離擷取、前處理、推論與後處理並以隊列解耦；在 GPU 啟用 FP16/AMP 與層融合；在 CPU 採用向量化、OpenMP/Threading、微批處理（batch=1–2）與幀率調度，兼顧互動性與吞吐。

Parallelism and latency: Multithreaded capture, preprocessing, inference, and postprocessing with queue decoupling; FP16/AMP and layer fusion on GPUs; vectorization, OpenMP/threading, micro-batches (1–2), and frame scheduling on CPUs to balance interactivity and throughput.

模型輸出與快取：進行預熱降低首幀延遲；對重複用戶快取臉部嵌入與 Tracking 狀態；對固定場景快取背景統計（亮度/白平衡）以加速穩態。

Model outputs and caching: Warm-up reduces first-frame latency; cache face embeddings and tracking states for returning users; cache background statistics (luminance/white balance) in static scenes for faster steady-state operation.

導出與可攜：視部署需求導出 ONNX；在雲端/邊緣環境提供動態形狀支援與張量維度對齊，避免記憶體碎片化；記錄性能指標（延遲/幀率/占用）以便持續優化。

Export and portability: ONNX export when needed; dynamic shapes and tensor alignment in cloud/edge environments to avoid fragmentation; instrument latency/FPS/utilization for continuous optimization.

### 2.6 涵蓋成本、範圍、時間、品質、溝通、風險與資源的 IT 專案管理計畫 (Project management plan)

本專案的範圍以「即時面部健康檢測 + 個人化識別追蹤 + 醫療預約整合」為核心，交付可於標準攝像頭環境運行的 Web 應用。時間上以六個月為第一階段目標：完成模型訓練與驗證、前後端整合、初步醫療合作與用戶驗證。品質指標以模型準確性、系統響應時間、可用性與安全合規為主，並以自動化測試與代碼審查把關。成本與資源方面，採小而專精的跨職能團隊，配合雲端彈性資源；以開源技術降低授權成本並保留可擴展性。溝通機制以每日站會、雙週迭代評審與月度利害關係人彙報為主，確保需求與交付同步。風險管理聚焦於資料偏差、模型泛化不足、第三方服務不穩與合規性挑戰，對應預備數據增補、備援模型、服務降級與法律顧問協作等緩解策略。

The project scope centers on real-time facial health detection, personalized identification/tracking, and medical appointment integration, delivered as a web app operating with standard cameras. The first six months target model training/validation, end-to-end integration, initial partnerships, and user validation. Quality metrics include model accuracy, response time, availability, and security/compliance, enforced via automated tests and code review. A small cross-functional team with elastic cloud resources manages cost and capacity, leveraging open source for extensibility. Communication relies on daily standups, biweekly reviews, and monthly stakeholder updates. Risk management focuses on data bias, model generalization, third-party instability, and regulatory hurdles, with mitigation including data augmentation, fallback models, service degradation, and legal counsel engagement.

### 2.7 工作分解結構 (Work breakdown structure)

工作分解以成果導向拆解至可驗證的子任務：在 AI 偵測上，從資料收集、標註、訓練到部署格式轉換，形成可重複的訓練與評估流程；在人臉識別與追蹤上，完成特徵嵌入、相似度閾值標定與多用戶場景測試；在 Web 與資料平台上，建立認證、數據模型、API 與前端展示，同步加入攝像頭串流與結果可視化；於醫療預約整合上，完成合作醫療機構資訊建模、推薦邏輯與預約流程打通；測試與品質保證覆蓋單元、整合、性能與安全；最終以部署與監控確保上線品質與持續可用。此種分解使每一層級皆對應明確可交付成果與驗收準則。

The work is decomposed into verifiable sub-deliverables: for AI detection, a repeatable loop from data collection/labeling to training and deployable formats; for identity/tracking, embedding calibration, similarity thresholds, and multi-user testing; for web and data, authentication, data models, APIs, and UI with camera streaming and result visualization; for appointment integration, provider data modeling, recommendation logic, and booking flow; testing spans unit, integration, performance, and security; deployment and monitoring ensure launch quality and availability. Each level maps to concrete deliverables and acceptance criteria.

### 2.8 里程碑排程 (Milestone schedules)

里程碑規劃遵循「先內核、後整合、再擴展」的節奏：第一階段完成四模型（黑眼圈、唇部、皮膚、綜合）的訓練與達標驗證，並建立穩定的人臉識別與追蹤能力；第二階段完成功能完整的 MVP，打通攝像頭串流、前後端服務與初步預約流程，並通過內部測試；第三階段聚焦醫療系統整合與資料安全治理，完成端到端可靠性驗證與負載測試；最終完成生產環境部署、用戶驗證與監控佈署，以可觀測性與回饋循環持續優化。各階段均設定量化成功準則，確保進度、品質與商業化節點可被有效監控與迭代修正。

Milestones follow a core-first, integration-second, expansion-third cadence: Phase 1 delivers four validated core models and stable identity/tracking; Phase 2 ships a functional MVP with live camera, end-to-end flows, and internal testing; Phase 3 completes medical integration and data security governance with end-to-end reliability and load testing; the final phase deploys to production with user validation and monitoring, enabling continuous optimization via observability and feedback.

---

## 第三章 系統架構與技術工具 (Chapter III: System Architecture and Technical Tools)

本章詳細介紹 Health Mirror 系統所採用的核心技術工具與開發環境，包括 Anaconda 科學計算平台、Jupyter Notebook 互動式開發環境、Python 機器學習生態系統、Django 網頁框架，以及各演算法的歷史發展脈絡與數學原理。這些技術選擇不僅支撐了系統的核心功能實現，更為後續的擴展與維護奠定了堅實的技術基礎。

This chapter provides a detailed introduction to the core technical tools and development environments adopted by the Health Mirror system, including the Anaconda scientific computing platform, Jupyter Notebook interactive development environment, Python machine learning ecosystem, Django web framework, and the historical development context and mathematical principles of various algorithms. These technical choices not only support the core functionality implementation of the system but also establish a solid technical foundation for future expansion and maintenance.

### 3.1 Anaconda 科學計算平台 (Anaconda Scientific Computing Platform)

Anaconda 作為 Health Mirror 專案的核心開發環境，提供了完整的 Python 科學計算生態系統。Anaconda 由 Continuum Analytics（現為 Anaconda Inc.）於 2012 年首次發布，旨在simplifying Python and R languages in data science domain. The platform integrates over 1,500 open-source packages, including core scientific computing libraries such as NumPy, SciPy, Pandas, Matplotlib, and Scikit-learn, providing a one-stop solution for machine learning and deep learning projects.

Anaconda serves as the core development environment for the Health Mirror project, providing a complete Python scientific computing ecosystem. Anaconda was first released by Continuum Analytics (now Anaconda Inc.) in 2012, aimed at simplifying package management and environment configuration for Python and R languages in the data science field. The platform integrates over 1,500 open-source packages, including core scientific computing libraries such as NumPy, SciPy, Pandas, Matplotlib, and Scikit-learn, providing a one-stop solution for machine learning and deep learning projects.

在 Health Mirror 專案中，Anaconda 的 conda 包管理器確保了不同開發環境間的一致性與可重現性。透過建立專用的虛擬環境，我們能夠精確控制每個依賴套件的版本，避免版本衝突並保證模型訓練結果的穩定性。特別是在處理 PyTorch、OpenCV、InsightFace 等深度學習框架時，conda 的二進制包分發機制大幅簡化了複雜依賴關係的解決過程，提升了開發效率。

In the Health Mirror project, Anaconda's conda package manager ensures consistency and reproducibility across different development environments. By creating dedicated virtual environments, we can precisely control the version of each dependency package, avoiding version conflicts and ensuring the stability of model training results. Particularly when dealing with deep learning frameworks such as PyTorch, OpenCV, and InsightFace, conda's binary package distribution mechanism significantly simplifies the resolution of complex dependency relationships and improves development efficiency.

### 3.2 Jupyter Notebook 互動式開發環境 (Jupyter Notebook Interactive Development Environment)

Jupyter Notebook 在 Health Mirror 專案中扮演著關鍵的原型開發與實驗驗證角色。Jupyter 專案起源於 2014 年的 IPython Notebook，由 Fernando Pérez 等人發起，旨在創建一個語言無關的互動式計算環境。其名稱來自於 Julia、Python 和 R 三種程式語言的組合，體現了跨語言支援的設計理念。

Jupyter Notebook plays a crucial role in prototype development and experimental validation in the Health Mirror project. The Jupyter project originated from IPython Notebook in 2014, initiated by Fernando Pérez and others, aiming to create a language-agnostic interactive computing environment. Its name comes from the combination of Julia, Python, and R programming languages, reflecting the design philosophy of cross-language support.

在模型開發階段，Jupyter Notebook 的細胞（Cell）執行機制允許開發者逐步驗證演算法邏輯，即時觀察中間結果與視覺化輸出。這種互動式的開發模式特別適合深度學習模型的調試與優化，開發者可以快速迭代超參數配置、觀察訓練曲線變化，並透過豐富的視覺化工具（如 Matplotlib、Seaborn、Plotly）直觀地分析模型性能。對於 YOLO 目標檢測模型的訓練過程，我們利用 Jupyter Notebook 建立了完整的實驗記錄系統，包括損失函數變化、精確度-召回率曲線、混淆矩陣分析等關鍵指標的即時監控。

During the model development phase, Jupyter Notebook's cell execution mechanism allows developers to gradually verify algorithm logic and observe intermediate results and visualization outputs in real-time. This interactive development mode is particularly suitable for debugging and optimizing deep learning models, enabling developers to quickly iterate hyperparameter configurations, observe training curve changes, and intuitively analyze model performance through rich visualization tools (such as Matplotlib, Seaborn, Plotly). For the training process of YOLO object detection models, we utilized Jupyter Notebook to establish a complete experimental recording system, including real-time monitoring of key metrics such as loss function changes, precision-recall curves, and confusion matrix analysis.

### 3.3 Python 機器學習生態系統 (Python Machine Learning Ecosystem)

Python 作為 Health Mirror 專案的主要開發語言，其豐富的機器學習生態系統為系統實現提供了強大支撐。Python 在機器學習領域的崛起可追溯至 1990 年代末期，隨著 NumPy（1995 年的 Numeric 前身）、SciPy（2001）、Matplotlib（2003）等基礎科學計算庫的發展，Python 逐漸成為數據科學與機器學習的首選語言。

Python serves as the primary development language for the Health Mirror project, and its rich machine learning ecosystem provides strong support for system implementation. Python's rise in the machine learning field can be traced back to the late 1990s. With the development of fundamental scientific computing libraries such as NumPy (predecessor Numeric in 1995), SciPy (2001), and Matplotlib (2003), Python gradually becomes the preferred language for data science and machine learning.

在深度學習框架方面，我們主要採用 PyTorch 作為模型訓練與推論的核心引擎。PyTorch 由 Facebook AI Research 團隊於 2016 年開源，其動態計算圖（Dynamic Computational Graph）設計理念為模型開發帶來了前所未有的靈活性。相較於靜態圖框架，PyTorch 的即時執行模式（Eager Execution）使得模型調試更加直觀，特別適合研究型專案的快速原型開發。在 Health Mirror 專案中，我們利用 PyTorch 的自動微分機制（Autograd）實現了複雜的多任務學習架構，同時透過 TorchVision 預訓練模型加速了 YOLO 檢測器的收斂過程。

In terms of deep learning frameworks, we primarily adopt PyTorch as the core engine for model training and inference. PyTorch was open-sourced by the Facebook AI Research team in 2016, and its Dynamic Computational Graph design philosophy brought unprecedented flexibility to model development. Compared to static graph frameworks, PyTorch's Eager Execution mode makes model debugging more intuitive, particularly suitable for rapid prototype development in research projects. In the Health Mirror project, we utilized PyTorch's automatic differentiation mechanism (Autograd) to implement complex multi-task learning architectures, while accelerating the convergence process of YOLO detectors through TorchVision pre-trained models.

### 3.4 Django 網頁框架架構 (Django Web Framework Architecture)

Django 作為 Health Mirror 系統的後端核心，提供了從用戶認證、數據管理到 API 服務的完整解決方案。Django 由 Adrian Holovaty 和 Simon Willison 於 2003 年在 Lawrence Journal-World 報社開發，並於 2005 年開源發布。其設計哲學「Don't Repeat Yourself (DRY)」與「Convention over Configuration」為快速開發高品質網頁應用奠定了基礎。

Django serves as the backend core of the Health Mirror system, providing a complete solution from user authentication and data management to API services. Django was developed by Adrian Holovaty and Simon Willison in 2003 at the Lawrence Journal-World newspaper and was open-sourced in 2005. Its design philosophy of "Don't Repeat Yourself (DRY)" and "Convention over Configuration" laid the foundation for rapid development of high-quality web applications.

Django 的 Model-View-Template (MVT) 架構模式在 Health Mirror 專案中發揮了關鍵作用。Model 層透過 Object-Relational Mapping (ORM) 技術抽象化了數據庫操作，我們定義了 User、HealthRecord、DetectionResult、Appointment 等核心數據模型，並透過 Django 的遷移系統（Migration）確保數據庫結構的版本控制與一致性。View 層負責業務邏輯處理，包括 AI 模型推論結果的處理、用戶健康數據的分析與醫療預約的智能推薦。Template 層則提供了靈活的前端渲染機制，支援響應式設計與多設備適配。

Django's Model-View-Template (MVT) architectural pattern plays a key role in the Health Mirror project. The Model layer abstracts database operations through Object-Relational Mapping (ORM) technology. We defined core data models such as User, HealthRecord, DetectionResult, and Appointment, and ensured version control and consistency of database structure through Django's Migration system. The View layer handles business logic processing, including processing of AI model inference results, analysis of user health data, and intelligent recommendations for medical appointments. The Template layer provides a flexible frontend rendering mechanism, supporting responsive design and multi-device adaptation.

### 3.5 演算法歷史發展與數學原理 (Algorithm Historical Development and Mathematical Principles)

#### 3.5.1 YOLO 演算法發展史與核心公式 (YOLO Algorithm History and Core Formulas)

YOLO（You Only Look Once）演算法由 Joseph Redmon 等人於 2015 年在華盛頓大學提出，革命性地將目標檢測問題重新定義為單一神經網路的回歸問題。相較於傳統的兩階段檢測方法（如 R-CNN 系列），YOLO 的一階段設計大幅提升了檢測速度，使實時目標檢測成為可能。在 Health Mirror 系統中，我們採用 YOLOv8 作為主要檢測引擎，針對健康監測場景開發了四個專用模型：DarkCircles.pt（黑眼圈檢測）、Lip_types.pt（唇部狀況監測）、skin.pt（皮膚問題分析）和 health.pt（綜合健康指標）。

The YOLO (You Only Look Once) algorithm was proposed by Joseph Redmon and others at the University of Washington in 2015, revolutionarily redefining the object detection problem as a single neural network regression problem. Compared to traditional two-stage detection methods (such as the R-CNN series), YOLO's one-stage design significantly improved detection speed, making real-time object detection possible. In the Health Mirror system, we utilize YOLOv8 as the primary detection engine with four specialized models: DarkCircles.pt (dark circle detection), Lip_types.pt (lip condition monitoring), skin.pt (skin problem analysis), and health.pt (comprehensive health indicators).

YOLOv8 採用改良的 CSPDarknet 輕量化骨幹網路（Cross-Stage Partial Network），通過跨階段的特徵分割與合併，有效減少冗餘計算同時保持完整的感受野和梯度流動。頸部架構結合特徵金字塔網路（FPN）和路徑聚合網路（PAN），實現雙向多尺度特徵融合。檢測頭採用混合預測架構，支援基於錨點和無錨點的預測方式，並引入動態特徵分配策略以適應不同場景需求。

YOLOv8 utilizes a modified CSPDarknet lightweight backbone network (Cross-Stage Partial Network), effectively reducing redundant computation while preserving full receptive field and gradient flow through cross-stage feature splitting and merging. The neck architecture combines Feature Pyramid Network (FPN) and Path Aggregation Network (PAN) for bidirectional multi-scale feature fusion. The detection head adopts a hybrid prediction architecture supporting both anchor-based and anchor-free predictions, with dynamic feature allocation strategy for different scenarios.

YOLO 的核心思想是將輸入圖像劃分為 S×S 的網格，每個網格負責預測 B 個邊界框及其置信度分數。對於每個邊界框，網路預測五個值：中心座標 (x, y)、寬高 (w, h) 和置信度 C。置信度定義為：

The core idea of YOLO is to divide the input image into an S×S grid, with each grid cell responsible for predicting B bounding boxes and their confidence scores. For each bounding box, the network predicts five values: center coordinates (x, y), width and height (w, h), and confidence C. Confidence is defined as:

```
C = Pr(Object) × IoU(pred, truth)
```

其中 Pr(Object) 表示網格包含目標的機率，IoU 為預測框與真實框的交集比聯集。

Where Pr(Object) represents the probability that the grid contains an object, and IoU is the intersection over union of the predicted box and ground truth box.

損失函數結合了定位損失、置信度損失和分類損失：

The loss function combines localization loss, confidence loss, and classification loss:

```
Loss = λcoord ∑∑ 𝟙ᵢⱼᵒᵇʲ [(xi - x̂i)² + (yi - ŷi)²]
     + λcoord ∑∑ 𝟙ᵢⱼᵒᵇʲ [(√wi - √ŵi)² + (√hi - √ĥi)²]
     + ∑∑ 𝟙ᵢⱼᵒᵇʲ (Ci - Ĉi)²
     + λnoobj ∑∑ 𝟙ᵢⱼⁿᵒᵒᵇʲ (Ci - Ĉi)²
     + ∑ 𝟙ᵢᵒᵇʲ ∑ (pi(c) - p̂i(c))²
```

為提升運算效率並減少模型大小，我們引入訓練後模型壓縮策略，包括剪枝（移除低權重通道）和知識蒸餾（使用完整 YOLOv8 作為教師模型）。數據增強結合 Mosaic、MixUp、隨機仿射變換、透視變換、HSV 抖動等技術，評估採用 mAP@0.70:0.95 作為核心指標。

To improve operational efficiency and reduce model size, we introduce post-training model compression strategies including pruning (removing low-weight channels) and knowledge distillation (using full YOLOv8 as teacher model). Data augmentation combines Mosaic, MixUp, random affine transformation, perspective transformation, and HSV jittering, with evaluation using mAP@0.70:0.95 as the core metric.

#### 3.5.2 OpenCV 影像處理演算法原理 (OpenCV Image Processing Algorithm Principles)

OpenCV（Open Source Computer Vision Library）由 Intel 於 1999 年發起，Gary Bradski 領導開發，是目前最廣泛使用的開源計算機視覺庫。在 Health Mirror 系統中，OpenCV 負責影像前處理模組，提供靈活且高效能的工作流程。

OpenCV (Open Source Computer Vision Library) was initiated by Intel in 1999 under the leadership of Gary Bradski, and is currently the most widely used open-source computer vision library. In the Health Mirror system, OpenCV handles the image preprocessing module, providing a flexible and high-performance workflow.

去噪與平滑處理採用多種濾波技術：高斯濾波器使用二維高斯核進行卷積，數學表達式為：

Denoising and smoothing employ various filtering techniques. Gaussian filtering uses 2D Gaussian kernel convolution with the mathematical expression:

```
G(x,y) = (1/(2πσ²)) * e^(-(x²+y²)/(2σ²))
```

雙邊濾波器在保持邊緣的同時進行平滑，其權重函數結合空間距離和像素值差異：

Bilateral filtering performs smoothing while preserving edges, with weight function combining spatial distance and pixel value differences:

```
w(i,j,k,l) = exp(-(i-k)²+(j-l)²)/(2σd²)) * exp(-||I(i,j)-I(k,l)||²/(2σr²))
```

色彩校正採用灰世界假設和 Shades-of-Gray 白平衡估計。灰世界假設認為圖像的平均反射率為灰色，校正公式為：

Color correction uses Gray World assumption and Shades-of-Gray white balance estimation. The Gray World assumption considers the average reflectance of an image to be gray, with correction formula:

```
R' = R * (Gavg/Ravg), G' = G * (Gavg/Gavg), B' = B * (Gavg/Bavg)
```

Canny 邊緣檢測採用多階段演算法：首先使用高斯濾波去噪，然後計算梯度幅值和方向，進行非極大值抑制，最後使用雙閾值檢測和邊緣連接。梯度計算使用 Sobel 運算子：

Canny edge detection uses a multi-stage algorithm: Gaussian filtering for denoising, gradient magnitude and direction calculation, non-maximum suppression, and finally double threshold detection with edge linking. Gradient calculation uses Sobel operators:

```
Gx = [-1 0 1; -2 0 2; -1 0 1], Gy = [-1 -2 -1; 0 0 0; 1 2 1]
```

#### 3.5.3 InsightFace 與 ArcFace 損失函數 (InsightFace and ArcFace Loss Function)

InsightFace 框架由 Jiankang Deng 等人開發，是目前最先進的人臉識別開源框架之一。該框架採用的 ArcFace 損失函數於 2018 年提出，通過在角度空間引入加性邊界來增強人臉特徵的判別性。在 Health Mirror 系統中，我們使用 InsightFace 進行嚴格的品質控制和身份驗證。

The InsightFace framework, developed by Jiankang Deng and others, is one of the most advanced open-source face recognition frameworks. The ArcFace loss function adopted by this framework was proposed in 2018, enhancing the discriminability of facial features by introducing additive margins in the angular space. In the Health Mirror system, we use InsightFace for rigorous quality control and identity verification.

系統首先檢測面部關鍵點（雙眼、鼻尖、嘴角），執行高精度仿射變換以標準化輸入圖像的尺度、位置和姿態。品質檢查包括使用拉普拉斯方差量化圖像清晰度、計算有效面部區域和遮擋比例、檢查亮度範圍。

The system first detects facial landmarks (eyes, nose tip, mouth corners) and performs high-precision affine transformation to standardize the scale, position, and pose of input images. Quality checks include using Laplacian variance to quantify image sharpness, calculating effective facial area and occlusion ratio, and checking brightness range.

ArcFace 損失函數定義為：

The ArcFace loss function is defined as:

```
L = -1/N ∑ᵢ₌₁ᴺ log(e^(s·cos(θyᵢ + m)) / (e^(s·cos(θyᵢ + m)) + ∑ⱼ₌₁,ⱼ≠yᵢᶜ e^(s·cos(θⱼ))))
```

其中 θyᵢ 是特徵向量與對應類別權重向量之間的角度，m 是加性角度邊界（典型值 m≈0.5），s 是特徵尺度參數（典型值 s≈64）。系統將每張面部圖像轉換為經 L2 正規化的 512 維向量，使用餘弦相似度進行匹配，並維護多樣本模板以適應長期外觀變化。

Where θyᵢ is the angle between the feature vector and the corresponding class weight vector, m is the additive angular margin (typical value m≈0.5), and s is the feature scale parameter (typical value s≈64). The system converts each facial image into an L2-normalized 512-dimensional vector, uses cosine similarity for matching, and maintains multi-sample templates to adapt to long-term appearance changes.

#### 3.5.4 DeepSORT 追蹤演算法與卡爾曼濾波器 (DeepSORT Tracking Algorithm and Kalman Filter)

DeepSORT 演算法由 Nicolai Wojke 等人於 2017 年提出，是 SORT（Simple Online and Realtime Tracking）演算法的改進版本，結合了運動模型和外觀特徵以確保跨幀身份一致性。該演算法的核心是卡爾曼濾波器，由 Rudolf Kalman 於 1960 年提出，是一種用於線性動態系統狀態估計的最優遞歸濾波器。

The DeepSORT algorithm was proposed by Nicolai Wojke and others in 2017 as an improved version of the SORT (Simple Online and Realtime Tracking) algorithm, combining motion models with appearance features to ensure cross-frame identity consistency. The core of this algorithm is the Kalman filter, proposed by Rudolf Kalman in 1960, which is an optimal recursive filter for state estimation in linear dynamic systems.

在 Health Mirror 系統中，DeepSORT 採用常速度運動模型，假設目標在短時間內表現出近似恆定的速度。狀態向量包含目標邊界框的中心座標、縱橫比、高度及其速度分量：

In the Health Mirror system, DeepSORT adopts a constant velocity motion model, assuming targets exhibit approximately constant velocity over short periods. The state vector contains the center coordinates, aspect ratio, height of the target's bounding box, and their velocity components:

```
x = [u, v, γ, h, u̇, v̇, γ̇, ḣ]ᵀ
```

其中 (u, v) 為邊界框中心座標，γ 為縱橫比，h 為高度，點表示對應的速度分量。

Where (u, v) are the center coordinates of the bounding box, γ is the aspect ratio, h is the height, and dots represent the corresponding velocity components.

卡爾曼濾波器的預測步驟：

Kalman filter prediction step:

```
xₖ|ₖ₋₁ = Fₖxₖ₋₁|ₖ₋₁
Pₖ|ₖ₋₁ = FₖPₖ₋₁|ₖ₋₁Fₖᵀ + Qₖ
```

更新步驟：

Update step:

```
Kₖ = Pₖ|ₖ₋₁Hₖᵀ(HₖPₖ|ₖ₋₁Hₖᵀ + Rₖ)⁻¹
xₖ|ₖ = xₖ|ₖ₋₁ + Kₖ(zₖ - Hₖxₖ|ₖ₋₁)
Pₖ|ₖ = (I - KₖHₖ)Pₖ|ₖ₋₁
```

其中 F 為狀態轉移矩陣，H 為觀測矩陣，Q 為過程噪聲協方差，R 為觀測噪聲協方差，K 為卡爾曼增益。

Where F is the state transition matrix, H is the observation matrix, Q is the process noise covariance, R is the observation noise covariance, and K is the Kalman gain.

目標關聯過程首先使用馬氏距離進行初步篩選，消除與當前狀態不確定性分佈不符的配對。馬氏距離定義為：

The target association process first uses Mahalanobis distance for preliminary screening, eliminating pairs that don't align with current state uncertainty distribution. Mahalanobis distance is defined as:

```
d²(i,j) = (dⱼ - yᵢ)ᵀSᵢ⁻¹(dⱼ - yᵢ)
```

其中 dⱼ 為第 j 個檢測結果，yᵢ 為第 i 個軌跡的預測位置，Sᵢ 為創新協方差矩陣。篩選後使用匈牙利演算法求解最小成本指派問題，成本函數結合邊界框 IoU 和外觀嵌入的餘弦距離。

Where dⱼ is the j-th detection result, yᵢ is the predicted position of the i-th track, and Sᵢ is the innovation covariance matrix. After screening, the Hungarian algorithm solves the minimum cost assignment problem, with cost function combining bounding box IoU and cosine distance of appearance embeddings.

軌跡管理實施確認階段，新檢測目標需連續命中超過 min_hits 閾值才被視為有效軌跡，長時間未匹配的軌跡在超過 max_age 閾值後自動刪除。對於重新進入場景的目標，系統結合外觀特徵和空間鄰近性恢復原始 ID，最小化身份重置的發生。

Track management implements a confirmation phase where newly detected objects require consecutive hits exceeding the min_hits threshold to be considered valid tracks. Tracks that haven't been matched for extended periods are automatically deleted after exceeding the max_age threshold. For targets re-entering the scene, the system combines appearance features and spatial proximity to recover original IDs, minimizing identity resets.

### 3.6 系統整合與部署架構 (System Integration and Deployment Architecture)

在系統整合層面，Health Mirror 採用微服務架構設計，將 AI 推論、用戶管理、數據存儲和醫療預約等功能模組化。透過 Docker 容器化技術確保跨平台部署的一致性，並利用 Kubernetes 進行容器編排與自動擴縮容。前端採用響應式設計，支援桌面瀏覽器、平板電腦和智慧型手機等多種設備訪問。

At the system integration level, Health Mirror adopts a microservices architecture design, modularizing functions such as AI inference, user management, data storage, and medical appointments. Docker containerization technology ensures consistency in cross-platform deployment, while Kubernetes is used for container orchestration and auto-scaling. The frontend adopts responsive design, supporting access from various devices including desktop browsers, tablets, and smartphones.

系統的安全性設計遵循醫療數據保護的最高標準，實施端到端加密、訪問控制和審計日誌等安全措施。所有健康數據的傳輸和存儲均採用 AES-256 加密，用戶身份驗證支援多因子認證（MFA），確保個人隱私和醫療數據的安全性。

The system's security design follows the highest standards for medical data protection, implementing security measures such as end-to-end encryption, access control, and audit logs. All health data transmission and storage use AES-256 encryption, and user authentication supports multi-factor authentication (MFA) to ensure the security of personal privacy and medical data.

---

## Chapter IV: 開發環境建置與實作流程 (Development Environment Setup and Implementation Process)

### 4.1 Conda 環境建置與依賴管理 (Conda Environment Setup and Dependency Management)

Health Mirror 系統的開發環境建置採用 Anaconda 作為 Python 環境管理工具，確保跨平台開發的一致性和依賴套件的版本控制。Anaconda 提供了完整的數據科學生態系統，包含 Jupyter Notebook、NumPy、Pandas、Matplotlib 等核心套件，為 AI 模型開發提供穩定的基礎環境。

The Health Mirror system's development environment setup uses Anaconda as the Python environment management tool, ensuring cross-platform development consistency and dependency package version control. Anaconda provides a complete data science ecosystem, including Jupyter Notebook, NumPy, Pandas, Matplotlib, and other core packages, providing a stable foundation for AI model development.

#### 4.1.1 環境建立步驟 (Environment Setup Steps)

首先建立專用的 Conda 虛擬環境，隔離專案依賴避免版本衝突：

First, create a dedicated Conda virtual environment to isolate project dependencies and avoid version conflicts:

```bash
# 建立新的 Conda 環境
conda create -n health_mirror python=3.9

# 啟動環境
conda activate health_mirror

# 安裝核心機器學習套件
conda install pytorch torchvision torchaudio pytorch-cuda=11.8 -c pytorch -c nvidia
conda install opencv matplotlib pandas numpy scikit-learn

# 安裝 YOLOv8 和相關套件
pip install ultralytics
pip install insightface
pip install deep-sort-realtime

# 安裝 Django 和 Web 開發套件
pip install django djangorestframework
pip install pillow
pip install python-decouple
```

#### 4.1.2 Google Colab 雲端開發環境 (Google Colab Cloud Development Environment)

為了利用免費的 GPU 資源進行模型訓練，我們同時配置 Google Colab 環境。Colab 提供 Tesla T4 GPU，適合中小型模型的訓練和實驗：

To utilize free GPU resources for model training, we also configure the Google Colab environment. Colab provides Tesla T4 GPU, suitable for training and experimenting with small to medium-sized models:

```python
# Google Colab 環境設定
from google.colab import drive
import os

# 掛載 Google Drive
drive.mount('/content/drive', force_remount=True)

# 安裝必要套件
!pip install ultralytics
!pip install roboflow

# 設定 GPU 環境
import torch
print(f"CUDA available: {torch.cuda.is_available()}")
print(f"GPU count: {torch.cuda.device_count()}")
if torch.cuda.is_available():
    print(f"Current GPU: {torch.cuda.get_device_name(0)}")
```

### 4.2 數據準備與標註流程 (Data Preparation and Annotation Process)

#### 4.2.1 數據集結構設計 (Dataset Structure Design)

Health Mirror 系統採用 YOLO 格式的數據集結構，每個健康檢測任務（黑眼圈、唇部狀況、皮膚問題、綜合健康指標）都有獨立的數據集：

The Health Mirror system adopts YOLO format dataset structure, with each health detection task (dark circles, lip conditions, skin problems, comprehensive health indicators) having independent datasets:

```
DATA-Train/
├── Dark_Circles/
│   ├── train/
│   │   ├── images/
│   │   └── labels/
│   ├── valid/
│   │   ├── images/
│   │   └── labels/
│   ├── test/
│   │   ├── images/
│   │   └── labels/
│   └── data.yaml
├── Lip_types/
├── skin/
└── health/
```

每個 data.yaml 檔案定義了類別標籤和路徑配置：

Each data.yaml file defines class labels and path configurations:

```yaml
# Dark_Circles/data.yaml
train: /content/drive/MyDrive/DATA-Train/Dark_Circles/train/images
val: /content/drive/MyDrive/DATA-Train/Dark_Circles/valid/images
test: /content/drive/MyDrive/DATA-Train/Dark_Circles/test/images

nc: 2  # 類別數量
names: ['no_dark_circles', 'dark_circles']  # 類別名稱
```

### 4.3 模型訓練流程詳解 (Detailed Model Training Process)

#### 4.3.1 YOLOv8 模型訓練實作 (YOLOv8 Model Training Implementation)

基於 Training.md 的訓練流程，我們採用遷移學習策略，從預訓練的 YOLOv8 模型開始，針對健康檢測任務進行微調：

Based on the training process in Training.md, we adopt a transfer learning strategy, starting from pre-trained YOLOv8 models and fine-tuning for health detection tasks:

```python
# 載入預訓練模型
from ultralytics import YOLO
import os

# 選擇適當的模型大小（根據計算資源和精度需求）
model = YOLO("yolov8l.pt")  # Large model for better accuracy

# 訓練配置
training_config = {
    "data": "/content/drive/MyDrive/DATA-Train/Dark_Circles/data.yaml",
    "epochs": 30,
    "batch": 16,
    "imgsz": 640,
    "device": 0,  # GPU device
    "save_dir": "/content/drive/MyDrive/DATA-Train/Dark_Circles",
    "name": "DarkCirclesTrain_v1",
    "patience": 10,  # Early stopping
    "save_period": 5,  # Save checkpoint every 5 epochs
    "val": True,  # Validate during training
    "plots": True,  # Generate training plots
    "verbose": True  # Detailed logging
}

# 開始訓練
results = model.train(**training_config)
```

#### 4.3.2 訓練監控與優化 (Training Monitoring and Optimization)

訓練過程中實施多項監控和優化策略：

Multiple monitoring and optimization strategies are implemented during training:

```python
# 訓練後評估
metrics = model.val()  # 在驗證集上評估
print(f"mAP50: {metrics.box.map50}")
print(f"mAP50-95: {metrics.box.map}")

# 模型推論測試
test_results = model("/path/to/test/image.jpg")

# 可視化訓練結果
import matplotlib.pyplot as plt

# 顯示訓練曲線
training_results_path = "/content/drive/MyDrive/DATA-Train/Dark_Circles/DarkCirclesTrain_v1/results.png"
plt.figure(figsize=(12, 8))
plt.imshow(plt.imread(training_results_path))
plt.axis('off')
plt.title('Training Results')
plt.show()
```

#### 4.3.3 模型驗證與測試 (Model Validation and Testing)

訓練完成後進行全面的模型驗證，確保模型性能符合預期：

After training completion, comprehensive model validation is performed to ensure model performance meets expectations:

```python
# 載入最佳模型
best_model = YOLO("/content/drive/MyDrive/DATA-Train/Dark_Circles/DarkCirclesTrain_v15/weights/best.pt")

# 隨機測試推論
import random
import cv2
import numpy as np

test_path = "/content/drive/MyDrive/DATA-Train/Dark_Circles/test/images"
img_list = os.listdir(test_path)
random_img = random.choice(img_list)
test_img_path = os.path.join(test_path, random_img)

# 執行推論
results = best_model(test_img_path)[0]

# 視覺化結果
img = cv2.imread(test_img_path)
for box in results.boxes:
    x1, y1, x2, y2 = box.xyxy[0].tolist()
    cls = int(box.cls[0])
    label = best_model.names[cls]
    conf = box.conf[0]
    
    # 繪製邊界框和標籤
    cv2.rectangle(img, (int(x1), int(y1)), (int(x2), int(y2)), (255, 0, 0), 2)
    cv2.putText(img, f"{label} {conf:.2f}", (int(x1), int(y1) - 10),
                cv2.FONT_HERSHEY_SIMPLEX, 0.9, (255, 0, 0), 2)

# 顯示結果
img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
plt.figure(figsize=(10, 8))
plt.imshow(img_rgb)
plt.axis('off')
plt.title(f"Inference Result: {random_img}")
plt.show()

# 儲存推論結果
save_path = "/content/drive/MyDrive/DATA-Train/Dark_Circles"
save_img_path = os.path.join(save_path, f"inference_{random_img}")
cv2.imwrite(save_img_path, img)
print(f"推論結果已儲存到: {save_img_path}")
```

### 4.4 Django Web 應用開發流程 (Django Web Application Development Process)

#### 4.4.1 Django 專案架構設計 (Django Project Architecture Design)

Health Mirror 的 Web 應用採用 Django 框架，實現模型-視圖-模板（MVT）架構模式。專案結構遵循 Django 最佳實踐，將功能模組化以提高可維護性：

The Health Mirror web application uses the Django framework, implementing the Model-View-Template (MVT) architecture pattern. The project structure follows Django best practices, modularizing functionality to improve maintainability:

```
safety/  # Django 專案根目錄
├── safety/
│   ├── __init__.py
│   ├── settings.py     # 專案設定
│   ├── urls.py         # URL 路由配置
│   ├── wsgi.py         # WSGI 部署配置
│   └── asgi.py         # ASGI 異步配置
├── base/               # 主要應用模組
│   ├── models.py       # 數據模型定義
│   ├── views.py        # 視圖邏輯
│   ├── urls.py         # 應用 URL 配置
│   ├── forms.py        # 表單定義
│   ├── admin.py        # 管理介面配置
│   └── templates/      # HTML 模板
├── static/             # 靜態檔案
│   ├── styles/         # CSS 樣式
│   ├── js/             # JavaScript
│   └── images/         # 圖片資源
├── media/              # 用戶上傳檔案
├── AIModels/           # AI 模型檔案
└── manage.py           # Django 管理腳本
```

#### 4.4.2 數據模型設計 (Data Model Design)

系統的核心數據模型包括用戶管理、健康記錄和醫療預約等功能：

The system's core data models include user management, health records, and medical appointment functions:

```python
# base/models.py
from django.db import models
from django.contrib.auth.models import AbstractUser
from django.utils import timezone

class User(AbstractUser):
    """擴展用戶模型"""
    phone = models.CharField(max_length=15, blank=True)
    mykad = models.CharField(max_length=12, unique=True, blank=True)
    race = models.CharField(max_length=50, blank=True)
    admin = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    
class HealthRecord(models.Model):
    """健康檢測記錄"""
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    image_path = models.ImageField(upload_to='health_images/')
    detection_results = models.JSONField()  # 儲存 AI 檢測結果
    dark_circles_score = models.FloatField(null=True, blank=True)
    lip_condition = models.CharField(max_length=100, blank=True)
    skin_analysis = models.JSONField(null=True, blank=True)
    overall_health_score = models.FloatField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    
class Booking(models.Model):
    """醫療預約模型"""
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    appointment_date = models.DateTimeField()
    doctor_name = models.CharField(max_length=100)
    department = models.CharField(max_length=100)
    status = models.CharField(max_length=20, default='pending')
    notes = models.TextField(blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
```

#### 4.4.3 AI 模型整合 (AI Model Integration)

Django 視圖中整合 AI 模型進行即時健康檢測：

Integrating AI models in Django views for real-time health detection:

```python
# base/views.py
from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required
from django.http import JsonResponse
from ultralytics import YOLO
import cv2
import numpy as np
import os
from .models import HealthRecord

# 載入預訓練模型
DARK_CIRCLES_MODEL = YOLO('AIModels/DarkCircles.pt')
LIP_MODEL = YOLO('AIModels/Lip_types.pt')
SKIN_MODEL = YOLO('AIModels/skin.pt')
HEALTH_MODEL = YOLO('AIModels/health.pt')

@login_required
def health_detection(request):
    """健康檢測主頁面"""
    if request.method == 'POST' and request.FILES.get('image'):
        image_file = request.FILES['image']
        
        # 儲存上傳的圖片
        health_record = HealthRecord.objects.create(
            user=request.user,
            image_path=image_file
        )
        
        # 執行 AI 檢測
        detection_results = perform_ai_detection(health_record.image_path.path)
        
        # 更新檢測結果
        health_record.detection_results = detection_results
        health_record.dark_circles_score = detection_results.get('dark_circles_score')
        health_record.lip_condition = detection_results.get('lip_condition')
        health_record.skin_analysis = detection_results.get('skin_analysis')
        health_record.overall_health_score = detection_results.get('overall_health_score')
        health_record.save()
        
        return JsonResponse({
            'success': True,
            'results': detection_results,
            'record_id': health_record.id
        })
    
    return render(request, 'base/health_detection.html')

def perform_ai_detection(image_path):
    """執行多模型 AI 檢測"""
    # 讀取圖片
    image = cv2.imread(image_path)
    
    # 黑眼圈檢測
    dark_circles_results = DARK_CIRCLES_MODEL(image)
    dark_circles_score = calculate_dark_circles_score(dark_circles_results)
    
    # 唇部狀況檢測
    lip_results = LIP_MODEL(image)
    lip_condition = analyze_lip_condition(lip_results)
    
    # 皮膚分析
    skin_results = SKIN_MODEL(image)
    skin_analysis = analyze_skin_condition(skin_results)
    
    # 綜合健康評估
    health_results = HEALTH_MODEL(image)
    overall_health_score = calculate_overall_health_score(health_results)
    
    return {
        'dark_circles_score': dark_circles_score,
        'lip_condition': lip_condition,
        'skin_analysis': skin_analysis,
        'overall_health_score': overall_health_score,
        'timestamp': timezone.now().isoformat()
    }
```

#### 4.4.4 前端介面開發 (Frontend Interface Development)

採用響應式設計，結合 HTML5、CSS3 和 JavaScript 創建直觀的用戶介面：

Using responsive design, combining HTML5, CSS3, and JavaScript to create an intuitive user interface:

```html
<!-- templates/base/health_detection.html -->
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Health Mirror - 健康檢測</title>
    <link rel="stylesheet" href="{% static 'styles/style.css' %}">
</head>
<body>
    <div class="container">
        <h1>AI 健康檢測</h1>
        
        <!-- 圖片上傳區域 -->
        <div class="upload-section">
            <form id="detection-form" enctype="multipart/form-data">
                {% csrf_token %}
                <div class="upload-area" id="upload-area">
                    <input type="file" id="image-input" name="image" accept="image/*" required>
                    <label for="image-input">
                        <i class="upload-icon"></i>
                        <p>點擊或拖拽上傳照片</p>
                    </label>
                </div>
                <button type="submit" id="detect-btn">開始檢測</button>
            </form>
        </div>
        
        <!-- 檢測結果顯示區域 -->
        <div class="results-section" id="results-section" style="display: none;">
            <h2>檢測結果</h2>
            <div class="result-cards">
                <div class="result-card">
                    <h3>黑眼圈檢測</h3>
                    <div class="score" id="dark-circles-score">--</div>
                </div>
                <div class="result-card">
                    <h3>唇部狀況</h3>
                    <div class="condition" id="lip-condition">--</div>
                </div>
                <div class="result-card">
                    <h3>皮膚分析</h3>
                    <div class="analysis" id="skin-analysis">--</div>
                </div>
                <div class="result-card">
                    <h3>綜合健康評分</h3>
                    <div class="score" id="overall-score">--</div>
                </div>
            </div>
        </div>
    </div>
    
    <script src="{% static 'js/health_detection.js' %}"></script>
</body>
</html>
```

### 4.5 系統部署與維運 (System Deployment and Operations)

#### 4.5.1 本地開發環境部署 (Local Development Environment Deployment)

```bash
# 啟動 Django 開發服務器
python manage.py makemigrations
python manage.py migrate
python manage.py collectstatic
python manage.py runserver 0.0.0.0:8000
```

#### 4.5.2 生產環境部署考量 (Production Environment Deployment Considerations)

生產環境部署需要考慮性能優化、安全性和可擴展性：

Production environment deployment requires consideration of performance optimization, security, and scalability:

- **Web 服務器配置**：使用 Nginx + Gunicorn 部署 Django 應用
- **數據庫優化**：從 SQLite 遷移到 PostgreSQL 或 MySQL
- **靜態檔案服務**：配置 CDN 加速靜態資源載入
- **AI 模型優化**：使用 ONNX 或 TensorRT 優化推論速度
- **負載均衡**：實施水平擴展以處理高併發請求
- **監控與日誌**：部署 ELK Stack 進行系統監控

---

## 第五章 系統架構與技術細節 (Chapter V: System Architecture and Technical Details)

本章將深入探討 Health Mirror 系統的技術架構、實現細節和關鍵組件，為讀者提供全面的系統技術視角。從 Django 專案結構到 AI 模型整合，從數據流處理到安全性考量，本章旨在展示系統如何將理論設計轉化為實際可運行的健康監測平台。

This chapter delves into the technical architecture, implementation details, and key components of the Health Mirror system, providing readers with a comprehensive technical perspective. From Django project structure to AI model integration, from data flow processing to security considerations, this chapter aims to demonstrate how the system transforms theoretical design into a practical, operational health monitoring platform.

### 5.1 Django 專案結構詳解 (Django Project Structure Detailed Explanation)

Health Mirror 系統採用 Django 框架作為後端開發的核心，其專案結構遵循 Django 的最佳實踐，同時融入了 AI 模型整合的特殊需求。Django 的選擇基於其強大的 ORM 系統、內置的安全機制、可擴展性和豐富的生態系統，這些特性使其成為健康監測系統的理想框架。以下是對專案結構的詳細解析：

The Health Mirror system uses the Django framework as the core of backend development. Its project structure follows Django best practices while incorporating special requirements for AI model integration. The choice of Django is based on its powerful ORM system, built-in security mechanisms, scalability, and rich ecosystem, which make it an ideal framework for health monitoring systems. Below is a detailed analysis of the project structure:

#### 5.1.1 專案根目錄結構 (Project Root Directory Structure)

```
safety/  # Django 專案根目錄
```

專案根目錄「safety」是整個系統的容器，包含所有子模組和配置文件。選擇「safety」作為名稱反映了系統的核心價值：為用戶提供安全、可靠的健康監測服務。

The project root directory "safety" is the container for the entire system, containing all submodules and configuration files. The choice of "safety" as the name reflects the core value of the system: providing users with safe and reliable health monitoring services.

#### 5.1.2 核心配置目錄 (Core Configuration Directory)

```
├── safety/
│   ├── __init__.py
│   ├── settings.py     # 專案設定
│   ├── urls.py         # URL 路由配置
│   ├── wsgi.py         # WSGI 部署配置
│   └── asgi.py         # ASGI 異步配置
```

核心配置目錄包含 Django 專案的基礎設定：

The core configuration directory contains the basic settings for the Django project:

- **settings.py**：定義了資料庫連接、靜態文件路徑、已安裝應用、中間件、認證後端等關鍵配置。特別地，我們在此文件中配置了 AI 模型路徑和相關參數。
- **urls.py**：實現了 URL 路由系統，將請求分發到適當的視圖函數。包含主要路由和對 base 應用的路由包含。
- **wsgi.py** 和 **asgi.py**：分別提供了同步和異步的應用服務器接口，支持不同部署場景的需求。

- **settings.py**: Defines key configurations such as database connections, static file paths, installed applications, middleware, authentication backends, etc. Specifically, we configure AI model paths and related parameters in this file.
- **urls.py**: Implements the URL routing system, dispatching requests to appropriate view functions. Includes main routes and route inclusions for the base application.
- **wsgi.py** and **asgi.py**: Provide synchronous and asynchronous application server interfaces respectively, supporting the needs of different deployment scenarios.

#### 5.1.3 主要應用模組 (Main Application Module)

```
├── base/               # 主要應用模組
│   ├── models.py       # 數據模型定義
│   ├── views.py        # 視圖邏輯
│   ├── urls.py         # 應用 URL 配置
│   ├── forms.py        # 表單定義
│   ├── admin.py        # 管理介面配置
│   └── templates/      # HTML 模板
```

「base」應用是系統的核心功能模組，實現了所有業務邏輯：

The "base" application is the core functional module of the system, implementing all business logic:

- **models.py**：定義了數據模型，包括用戶擴展模型、健康記錄模型和預約模型，建立了系統的數據結構基礎。
- **views.py**：包含所有視圖函數，處理 HTTP 請求並返回響應。特別地，這裡實現了 AI 模型的調用邏輯和結果處理。
- **urls.py**：定義了應用級別的 URL 路由，將請求映射到具體視圖函數。
- **forms.py**：定義了表單類，處理用戶輸入驗證和數據預處理。
- **admin.py**：配置了 Django 管理界面，方便管理員管理系統數據。
- **templates/**：包含所有 HTML 模板，實現了前端頁面的結構和布局。

- **models.py**: Defines data models, including user extension model, health record model, and appointment model, establishing the data structure foundation of the system.
- **views.py**: Contains all view functions, handling HTTP requests and returning responses. Specifically, it implements the calling logic and result processing of AI models.
- **urls.py**: Defines application-level URL routing, mapping requests to specific view functions.
- **forms.py**: Defines form classes, handling user input validation and data preprocessing.
- **admin.py**: Configures the Django admin interface, facilitating administrators to manage system data.
- **templates/**: Contains all HTML templates, implementing the structure and layout of frontend pages.

#### 5.1.4 靜態資源與媒體文件 (Static Resources and Media Files)

```
├── static/             # 靜態檔案
│   ├── styles/         # CSS 樣式
│   ├── js/             # JavaScript
│   └── images/         # 圖片資源
├── media/              # 用戶上傳檔案
```

靜態資源和媒體文件目錄分別存儲了系統的固定資源和用戶生成內容：

Static resources and media file directories store the system's fixed resources and user-generated content respectively:

- **static/**：包含所有預定義的靜態資源，如 CSS 樣式表、JavaScript 腳本和圖片資源。這些文件在部署時會被收集到統一位置，提高訪問效率。
- **media/**：存儲用戶上傳的文件，如健康檢測的圖片。系統會自動管理這些文件的存儲和訪問權限。

- **static/**: Contains all predefined static resources, such as CSS stylesheets, JavaScript scripts, and image resources. These files are collected to a unified location during deployment to improve access efficiency.
- **media/**: Stores user-uploaded files, such as health detection images. The system automatically manages the storage and access permissions of these files.

#### 5.1.5 AI 模型與管理腳本 (AI Models and Management Script)

```
├── AIModels/           # AI 模型檔案
└── manage.py           # Django 管理腳本
```

- **AIModels/**：存儲了系統使用的所有 AI 模型文件，包括 YOLO 模型權重和配置文件。這些模型在系統啟動時被加載到內存中，以提供即時的健康檢測服務。
- **manage.py**：Django 的命令行工具，提供了各種管理命令，如啟動開發服務器、創建數據庫遷移、應用遷移等。

- **AIModels/**: Stores all AI model files used by the system, including YOLO model weights and configuration files. These models are loaded into memory when the system starts to provide real-time health detection services.
- **manage.py**: Django's command-line tool, providing various management commands such as starting the development server, creating database migrations, applying migrations, etc.

### 5.2 系統核心功能實現 (Implementation of System Core Functions)

本節詳細介紹 Health Mirror 系統的核心功能實現，包括用戶認證與授權、AI 模型整合與健康檢測、健康數據可視化等關鍵技術點。系統採用分層架構設計，將表示層、業務邏輯層和數據訪問層清晰分離，確保代碼的可維護性和可擴展性。同時，我們實施了完整的錯誤處理和日誌記錄機制，以提高系統的穩定性和可追溯性。

This section details the implementation of the core functions of the Health Mirror system, including user authentication and authorization, AI model integration and health detection, health data visualization, and other key technical points. The system adopts a layered architectural design, clearly separating the presentation layer, business logic layer, and data access layer to ensure code maintainability and scalability. Additionally, we have implemented comprehensive error handling and logging mechanisms to enhance system stability and traceability.

#### 5.2.1 用戶認證與授權 (User Authentication and Authorization)

Health Mirror 系統實現了完整的用戶認證和授權機制，確保用戶數據的安全性和隱私性。我們擴展了 Django 的內置用戶模型，添加了健康相關的個人資料字段，並實施了基於角色的訪問控制系統，區分普通用戶、醫療專業人員和系統管理員的權限範圍：

The Health Mirror system implements a complete user authentication and authorization mechanism to ensure the security and privacy of user data. We extended Django's built-in user model by adding health-related profile fields and implemented a role-based access control system that differentiates permission scopes for regular users, healthcare professionals, and system administrators:

```python
# base/models.py - 擴展用戶模型
from django.contrib.auth.models import User
from django.db import models

class UserProfile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='profile')
    date_of_birth = models.DateField(null=True, blank=True)
    gender = models.CharField(max_length=10, choices=[
        ('male', '男性'),
        ('female', '女性'),
        ('other', '其他')
    ])
    phone_number = models.CharField(max_length=15, blank=True)
    medical_history = models.TextField(blank=True)
    role = models.CharField(max_length=20, choices=[
        ('user', '普通用戶'),
        ('doctor', '醫療專業人員'),
        ('admin', '系統管理員')
    ], default='user')
    last_health_check = models.DateTimeField(null=True, blank=True)
    
    def __str__(self):
        return f"{self.user.username}'s Profile"

# base/views.py - 認證與授權實現
from django.contrib.auth import authenticate, login, logout
from django.contrib.auth.decorators import login_required, user_passes_test
from django.contrib import messages
from django.shortcuts import render, redirect, get_object_or_404
from .models import UserProfile, HealthRecord

def login_view(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        user = authenticate(request, username=username, password=password)
        
        if user is not None:
            login(request, user)
            # 記錄登錄活動
            from django.utils import timezone
            user.last_login = timezone.now()
            user.save()
            
            # 根據用戶角色重定向到不同頁面
            try:
                if user.profile.role == 'doctor':
                    return redirect('doctor_dashboard')
                elif user.profile.role == 'admin':
                    return redirect('admin_dashboard')
                else:
                    return redirect('home')
            except UserProfile.DoesNotExist:
                # 如果用戶沒有關聯的個人資料，創建一個默認的
                UserProfile.objects.create(user=user, role='user')
                return redirect('home')
        else:
            messages.error(request, '用戶名或密碼錯誤')
    
    return render(request, 'base/login.html')

def logout_view(request):
    logout(request)
    return redirect('login')

@login_required
def home_view(request):
    # 只有登錄用戶才能訪問
    return render(request, 'base/home.html')
```

系統使用 Django 內置的認證系統，並通過裝飾器 `@login_required` 限制未認證用戶對敏感頁面的訪問。此外，我們實現了自定義的用戶模型，擴展了標準用戶字段以滿足健康監測的特定需求。系統還實施了基於角色的訪問控制，通過以下方式實現：

The system uses Django's built-in authentication system and restricts unauthenticated users' access to sensitive pages through the `@login_required` decorator. Additionally, we implemented a custom user model, extending standard user fields to meet the specific requirements of health monitoring. The system also implements role-based access control through the following methods:

```python
# 基於角色的訪問控制裝飾器
def doctor_required(function):
    actual_decorator = user_passes_test(
        lambda u: hasattr(u, 'profile') and u.profile.role in ['doctor', 'admin']
    )
    return actual_decorator(function)

def admin_required(function):
    actual_decorator = user_passes_test(
        lambda u: hasattr(u, 'profile') and u.profile.role == 'admin'
    )
    return actual_decorator(function)

# 使用裝飾器限制訪問
@doctor_required
def doctor_dashboard(request):
    # 只有醫生和管理員可以訪問
    patients = User.objects.filter(profile__role='user')
    return render(request, 'base/doctor_dashboard.html', {'patients': patients})

@admin_required
def system_settings(request):
    # 只有管理員可以訪問
    return render(request, 'base/system_settings.html')
```

#### 5.2.2 AI 模型整合與健康檢測 (AI Model Integration and Health Detection)

系統的核心功能是 AI 驅動的健康檢測，這部分通過在 Django 視圖中整合 YOLO 模型實現。我們採用了模型預加載策略，在應用啟動時將模型載入內存，以減少檢測時的延遲。同時，我們實現了異步處理機制，使長時間運行的 AI 推理不會阻塞 Web 服務器：

The core function of the system is AI-driven health detection, which is implemented by integrating YOLO models in Django views. We adopted a model pre-loading strategy, loading models into memory when the application starts to reduce detection latency. At the same time, we implemented an asynchronous processing mechanism so that long-running AI inference does not block the web server:

```python
# base/apps.py - 在應用啟動時預加載模型
from django.apps import AppConfig
import os

class BaseConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'base'
    
    def ready(self):
        # 在應用啟動時預加載 AI 模型
        from django.conf import settings
        from ultralytics import YOLO
        import threading
        
        # 使用線程池進行模型加載，避免阻塞應用啟動
        def load_models():
            from .models import AIModel
            # 清除舊模型記錄
            AIModel.objects.all().delete()
            
            # 加載並保存模型引用
            models = {
                'dark_circles': YOLO(os.path.join(settings.BASE_DIR, 'AIModels/DarkCircles.pt')),
                'lip': YOLO(os.path.join(settings.BASE_DIR, 'AIModels/Lip_types.pt')),
                'skin': YOLO(os.path.join(settings.BASE_DIR, 'AIModels/skin.pt')),
                'health': YOLO(os.path.join(settings.BASE_DIR, 'AIModels/health.pt'))
            }
            
            # 將模型引用保存到數據庫，方便在視圖中訪問
            for name, model in models.items():
                AIModel.objects.create(name=name, model_instance=model)
                print(f"Model {name} loaded successfully")
        
        # 使用線程異步加載模型，避免阻塞應用啟動
        if not settings.TESTING:  # 測試環境下不加載模型
            thread = threading.Thread(target=load_models)
            thread.daemon = True
            thread.start()

# base/models.py - AI模型存儲
class AIModel(models.Model):
    name = models.CharField(max_length=50, unique=True)
    model_path = models.CharField(max_length=255)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    # 非持久化字段，用於存儲模型實例
    model_instance = None
    
    def __str__(self):
        return f"AI Model: {self.name}"

# base/tasks.py - 異步任務處理
from celery import shared_task
import cv2
import numpy as np
import os
from django.conf import settings
from .models import HealthRecord, AIModel

@shared_task
def process_health_detection(user_id, image_path):
    """異步處理健康檢測任務"""
    from django.contrib.auth.models import User
    
    # 獲取用戶
    user = User.objects.get(id=user_id)
    
    # 讀取圖片並進行預處理
    img = cv2.imread(image_path)
    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    
    # 獲取模型實例
    models = {model.name: model.model_instance for model in AIModel.objects.all()}
    
    # 使用 AI 模型進行檢測
    dark_circles_results = models['dark_circles'](img_rgb)
    lip_results = models['lip'](img_rgb)
    skin_results = models['skin'](img_rgb)
    health_results = models['health'](img_rgb)
    
    # 處理檢測結果
    dark_circles_score = process_dark_circles(dark_circles_results)
    lip_condition = process_lip_condition(lip_results)
    skin_analysis = process_skin_analysis(skin_results)
    overall_health = process_overall_health(health_results)
    
    # 保存檢測記錄
    record = HealthRecord.objects.create(
        user=user,
        image_path=image_path,
        detection_results={
            'dark_circles': dark_circles_results.tolist(),
            'lip': lip_results.tolist(),
            'skin': skin_results.tolist(),
            'health': health_results.tolist()
        },
        dark_circles_score=dark_circles_score,
        lip_condition=lip_condition,
        skin_analysis=skin_analysis,
        overall_health_score=overall_health
    )
    
    # 返回結果ID，前端可以通過輪詢獲取結果
    return record.id

# base/views.py - 健康檢測視圖
from django.http import JsonResponse
from django.contrib.auth.decorators import login_required
from .tasks import process_health_detection
import os

@login_required
def detect_health(request):
    """處理健康檢測請求，使用異步任務進行處理"""
    if request.method == 'POST' and request.FILES.get('image'):
        # 處理上傳的圖片
        image_file = request.FILES['image']
        image_path = os.path.join(settings.MEDIA_ROOT, 'temp', image_file.name)
        
        # 確保目錄存在
        os.makedirs(os.path.dirname(image_path), exist_ok=True)
        
        with open(image_path, 'wb+') as destination:
            for chunk in image_file.chunks():
                destination.write(chunk)
        
        # 啟動異步任務處理
        task = process_health_detection.delay(request.user.id, image_path)
        
        return JsonResponse({
            'success': True,
            'task_id': task.id,
            'message': '健康檢測正在處理中，請稍後查看結果'
        })
    
    return JsonResponse({'success': False, 'message': '請上傳有效的圖片'})

@login_required
def get_detection_result(request, task_id):
    """獲取異步任務的處理結果"""
    from celery.result import AsyncResult
    
    result = AsyncResult(task_id)
    
    if result.ready():
        record_id = result.get()
        record = HealthRecord.objects.get(id=record_id)
        
        return JsonResponse({
            'success': True,
            'status': 'completed',
            'dark_circles_score': record.dark_circles_score,
            'lip_condition': record.lip_condition,
            'skin_analysis': skin_analysis,
            'overall_health': overall_health
        })
    
    return JsonResponse({'success': False, 'error': '無效的請求'})
```

這段代碼展示了系統如何加載 AI 模型、處理上傳的圖片、執行健康檢測並保存結果。系統使用 Ultralytics 的 YOLO 實現，結合 OpenCV 進行圖像處理，實現了高效的健康特徵檢測。

This code demonstrates how the system loads AI models, processes uploaded images, performs health detection, and saves results. The system uses Ultralytics' YOLO implementation combined with OpenCV for image processing, achieving efficient health feature detection.

#### 5.2.3 健康數據可視化 (Health Data Visualization)

系統通過 JavaScript 和 Chart.js 實現了健康數據的可視化，為用戶提供直觀的健康趨勢分析。我們設計了響應式圖表系統，能夠自動適應不同設備的屏幕尺寸，並實現了實時數據更新機制，確保用戶始終看到最新的健康狀況：

The system implements health data visualization through JavaScript and Chart.js, providing users with intuitive health trend analysis. We designed a responsive chart system that automatically adapts to different device screen sizes and implemented a real-time data update mechanism to ensure users always see the latest health status:

```javascript
// static/js/chart.js - 健康數據可視化與實時更新

// 全局變量存儲圖表實例，便於更新
let healthLineChart = null;
let skinLineChart = null;

// 初始化圖表並設置自動刷新
function initCharts() {
    // 初始加載圖表數據
    loadChartData3();
    loadSkinChartData();
    
    // 設置定時刷新 - 每60秒更新一次數據
    setInterval(() => {
        updateCharts();
    }, 60000);
    
    // 添加窗口大小變化監聽器，實現響應式設計
    window.addEventListener('resize', () => {
        if (healthLineChart) healthLineChart.resize();
        if (skinLineChart) skinLineChart.resize();
    });
}

// 更新所有圖表數據
function updateCharts() {
    console.log('Updating charts with latest data...');
    // 使用帶有緩存破壞參數的API調用，確保獲取最新數據
    fetch(`/api/health-stats/?_=${new Date().getTime()}`)
        .then(response => response.json())
        .then(data => {
            // 更新現有圖表而不是重新創建
            if (healthLineChart) {
                healthLineChart.data.labels = data.dates;
                healthLineChart.data.datasets[0].data = data.dark_circles_scores;
                healthLineChart.data.datasets[1].data = data.lip_issues;
                healthLineChart.update('none'); // 使用'none'模式避免動畫重播
            }
            
            if (skinLineChart) {
                skinLineChart.data.labels = data.dates;
                skinLineChart.data.datasets[0].data = data.acne_scores;
                skinLineChart.data.datasets[1].data = data.dry_skin_scores;
                skinLineChart.data.datasets[2].data = data.oily_skin_scores;
                skinLineChart.data.datasets[3].data = data.sensitive_skin_scores;
                skinLineChart.update('none');
            }
        })
        .catch(error => console.error('Error updating charts:', error));
}

// 健康問題趨勢圖表
function loadChartData3() {
    fetch('/api/health-stats/')
        .then(response => response.json())
        .then(data => {
            const ctx = document.getElementById('lineChart').getContext('2d');
            
            // 創建漸變背景
            const gradientFill1 = ctx.createLinearGradient(0, 0, 0, 400);
            gradientFill1.addColorStop(0, 'rgba(75, 192, 192, 0.6)');
            gradientFill1.addColorStop(0.7, 'rgba(75, 192, 192, 0.1)');
            
            const gradientFill2 = ctx.createLinearGradient(0, 0, 0, 400);
            gradientFill2.addColorStop(0, 'rgba(255, 99, 132, 0.6)');
            gradientFill2.addColorStop(0.7, 'rgba(255, 99, 132, 0.1)');
            
            // 銷毀現有圖表（如果存在）
            if (healthLineChart) healthLineChart.destroy();
            
            // 創建新圖表
            healthLineChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.dates,
                    datasets: [
                        {
                            label: '黑眼圈指數',
                            data: data.dark_circles_scores,
                            borderColor: 'rgba(75, 192, 192, 1)',
                            backgroundColor: gradientFill1,
                            tension: 0.4,
                            fill: true,
                            pointBackgroundColor: 'rgba(75, 192, 192, 1)',
                            pointBorderColor: '#fff',
                            pointHoverBackgroundColor: '#fff',
                            pointHoverBorderColor: 'rgba(75, 192, 192, 1)'
                        },
                        {
                            label: '唇部問題',
                            data: data.lip_issues,
                            borderColor: 'rgba(255, 99, 132, 1)',
                            backgroundColor: gradientFill2,
                            tension: 0.4,
                            fill: true,
                            pointBackgroundColor: 'rgba(255, 99, 132, 1)',
                            pointBorderColor: '#fff',
                            pointHoverBackgroundColor: '#fff',
                            pointHoverBorderColor: 'rgba(255, 99, 132, 1)'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: '健康問題趨勢',
                            font: {
                                size: 16,
                                weight: 'bold'
                            }
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 20
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += Math.round(context.parsed.y * 10) / 10;
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: {
                                drawBorder: false,
                                color: 'rgba(200, 200, 200, 0.15)'
                            },
                            ticks: {
                                font: {
                                    size: 12
                                }
                            }
                        },
                        x: {
                            grid: {
                                drawBorder: false,
                                color: 'rgba(200, 200, 200, 0.15)'
                            },
                            ticks: {
                                font: {
                                    size: 12
                                }
                            }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'nearest'
                    },
                    animation: {
                        duration: 1000,
                        easing: 'easeOutQuart'
                    }
                }
            });
        })
        .catch(error => console.error('Error loading health chart data:', error));
}

// 皮膚健康趨勢圖表
function loadSkinChartData() {
    fetch('/api/skin-health-stats/')
        .then(response => response.json())
        .then(data => {
            const ctx = document.getElementById('skinChart').getContext('2d');
            
            // 創建漸變背景
            const gradients = [
                createGradient(ctx, 'rgba(54, 162, 235, 1)'),  // 痘痘問題
                createGradient(ctx, 'rgba(255, 206, 86, 1)'),  // 乾燥問題
                createGradient(ctx, 'rgba(75, 192, 192, 1)'),  // 油性問題
                createGradient(ctx, 'rgba(153, 102, 255, 1)')  // 敏感問題
            ];
            
            // 銷毀現有圖表（如果存在）
            if (skinLineChart) skinLineChart.destroy();
            
            // 創建新圖表
            skinLineChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.dates,
                    datasets: [
                        createDataset('痘痘問題', data.acne_scores, 'rgba(54, 162, 235, 1)', gradients[0]),
                        createDataset('乾燥問題', data.dry_skin_scores, 'rgba(255, 206, 86, 1)', gradients[1]),
                        createDataset('油性問題', data.oily_skin_scores, 'rgba(75, 192, 192, 1)', gradients[2]),
                        createDataset('敏感問題', data.sensitive_skin_scores, 'rgba(153, 102, 255, 1)', gradients[3])
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: '皮膚健康趨勢',
                            font: {
                                size: 16,
                                weight: 'bold'
                            }
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 20
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += Math.round(context.parsed.y * 10) / 10;
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: {
                                drawBorder: false,
                                color: 'rgba(200, 200, 200, 0.15)'
                            }
                        },
                        x: {
                            grid: {
                                drawBorder: false,
                                color: 'rgba(200, 200, 200, 0.15)'
                            }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'nearest'
                    }
                }
            });
        })
        .catch(error => console.error('Error loading skin chart data:', error));
}

// 輔助函數 - 創建漸變背景
function createGradient(ctx, color) {
    const gradient = ctx.createLinearGradient(0, 0, 0, 400);
    // 從顏色的RGB值創建半透明版本
    const rgbValues = color.match(/\d+/g);
    gradient.addColorStop(0, color.replace('1)', '0.6)'));
    gradient.addColorStop(0.7, color.replace('1)', '0.1)'));
    return gradient;
}

// 輔助函數 - 創建數據集配置
function createDataset(label, data, color, gradient) {
    return {
        label: label,
        data: data,
        borderColor: color,
        backgroundColor: gradient,
        tension: 0.4,
        fill: true,
        pointBackgroundColor: color,
        pointBorderColor: '#fff',
        pointHoverBackgroundColor: '#fff',
        pointHoverBorderColor: color,
        borderWidth: 2
    };
}
```

後端API實現：

```python
# base/views.py (API部分)

from django.http import JsonResponse
from django.db.models import Avg
from django.db.models.functions import TruncDate
from .models import HealthDetection
import json

@login_required
def health_stats_api(request):
    """提供健康統計數據API，用於前端圖表顯示"""
    # 獲取用戶最近30天的健康檢測數據
    user_detections = HealthDetection.objects.filter(
        user=request.user,
        created_at__gte=timezone.now() - timezone.timedelta(days=30)
    ).annotate(
        date=TruncDate('created_at')
    ).values('date').annotate(
        dark_circles_avg=Avg('dark_circles_score'),
        lip_issues_avg=Avg('lip_health_score')
    ).order_by('date')
    
    # 格式化數據用於Chart.js
    dates = []
    dark_circles_scores = []
    lip_issues = []
    
    for detection in user_detections:
        dates.append(detection['date'].strftime('%Y-%m-%d'))
        dark_circles_scores.append(round(detection['dark_circles_avg'], 2))
        lip_issues.append(round(detection['lip_issues_avg'], 2))
    
    return JsonResponse({
        'dates': dates,
        'dark_circles_scores': dark_circles_scores,
        'lip_issues': lip_issues
    })

@login_required
def skin_health_stats_api(request):
    """提供皮膚健康統計數據API，用於前端圖表顯示"""
    # 獲取用戶最近30天的皮膚健康數據
    user_detections = HealthDetection.objects.filter(
        user=request.user,
        created_at__gte=timezone.now() - timezone.timedelta(days=30)
    ).annotate(
        date=TruncDate('created_at')
    ).values('date').annotate(
        acne_avg=Avg('acne_score'),
        dry_skin_avg=Avg('dry_skin_score'),
        oily_skin_avg=Avg('oily_skin_score'),
        sensitive_skin_avg=Avg('sensitive_skin_score')
    ).order_by('date')
    
    # 格式化數據用於Chart.js
    dates = []
    acne_scores = []
    dry_skin_scores = []
    oily_skin_scores = []
    sensitive_skin_scores = []
    
    for detection in user_detections:
        dates.append(detection['date'].strftime('%Y-%m-%d'))
        acne_scores.append(round(detection['acne_avg'], 2))
        dry_skin_scores.append(round(detection['dry_skin_avg'], 2))
        oily_skin_scores.append(round(detection['oily_skin_avg'], 2))
        sensitive_skin_scores.append(round(detection['sensitive_skin_avg'], 2))
    
    return JsonResponse({
        'dates': dates,
        'acne_scores': acne_scores,
        'dry_skin_scores': dry_skin_scores,
        'oily_skin_scores': oily_skin_scores,
        'sensitive_skin_scores': sensitive_skin_scores
    })
```
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100
                        }
                    }
                }
            });
        });
}
```

這段代碼展示了系統如何從後端 API 獲取健康數據，並使用 Chart.js 創建線性圖表來展示健康問題的趨勢變化。系統還實現了其他類型的圖表，如甜甜圈圖和日曆視圖，提供多維度的健康數據分析。

This code demonstrates how the system retrieves health data from the backend API and uses Chart.js to create line charts to show trends in health issues. The system also implements other types of charts, such as donut charts and calendar views, providing multi-dimensional health data analysis.

### 5.3 系統安全與性能優化 (System Security and Performance Optimization)

#### 5.3.1 安全措施實現 (Security Measures Implementation)

Health Mirror 系統實施了多層次的安全措施，保護用戶數據和系統完整性：

The Health Mirror system implements multi-layered security measures to protect user data and system integrity:

1. **認證與授權**：使用 Django 的認證系統和權限控制，確保只有授權用戶能訪問敏感資源。
2. **CSRF 保護**：在所有表單中實施 CSRF 令牌，防止跨站請求偽造攻擊。
3. **密碼哈希**：使用 PBKDF2 算法和 SHA256 哈希函數安全存儲用戶密碼。
4. **SQL 注入防護**：使用 Django ORM 的參數化查詢，防止 SQL 注入攻擊。
5. **XSS 防護**：在模板中自動轉義 HTML 特殊字符，防止跨站腳本攻擊。
6. **安全 HTTP 頭**：配置適當的安全頭，如 Content-Security-Policy 和 X-XSS-Protection。

1. **Authentication and Authorization**: Using Django's authentication system and permission control to ensure that only authorized users can access sensitive resources.
2. **CSRF Protection**: Implementing CSRF tokens in all forms to prevent cross-site request forgery attacks.
3. **Password Hashing**: Securely storing user passwords using the PBKDF2 algorithm and SHA256 hash function.
4. **SQL Injection Protection**: Using Django ORM's parameterized queries to prevent SQL injection attacks.
5. **XSS Protection**: Automatically escaping HTML special characters in templates to prevent cross-site scripting attacks.
6. **Secure HTTP Headers**: Configuring appropriate security headers such as Content-Security-Policy and X-XSS-Protection.

#### 5.3.2 性能優化策略 (Performance Optimization Strategies)

系統採用了多種策略優化性能，提高用戶體驗：

The system adopts various strategies to optimize performance and improve user experience:

1. **數據庫優化**：
   - 使用適當的索引加速查詢
   - 實施數據庫連接池管理
   - 優化查詢語句，減少不必要的連接和子查詢

2. **AI 模型優化**：
   - 使用 ONNX 格式轉換模型，提高推理速度
   - 實施批處理機制，減少模型加載開銷
   - 使用混合精度計算，在保持準確性的同時提高性能

3. **前端優化**：
   - 使用瀏覽器緩存和 CDN 加速靜態資源加載
   - 實施懶加載和代碼分割，減少初始加載時間
   - 使用 AJAX 和 WebSocket 實現無刷新數據更新

4. **服務器優化**：
   - 使用 Gunicorn 和 Nginx 提高請求處理能力
   - 實施適當的緩存策略，減少重複計算
   - 使用異步任務處理長時間運行的操作

1. **Database Optimization**:
   - Using appropriate indexes to accelerate queries
   - Implementing database connection pool management
   - Optimizing query statements to reduce unnecessary joins and subqueries

2. **AI Model Optimization**:
   - Converting models to ONNX format to improve inference speed
   - Implementing batch processing mechanisms to reduce model loading overhead
   - Using mixed-precision computation to improve performance while maintaining accuracy

3. **Frontend Optimization**:
   - Using browser caching and CDN to accelerate static resource loading
   - Implementing lazy loading and code splitting to reduce initial loading time
   - Using AJAX and WebSocket for refresh-free data updates

4. **Server Optimization**:
   - Using Gunicorn and Nginx to improve request handling capacity
   - Implementing appropriate caching strategies to reduce repeated calculations
   - Using asynchronous task processing for long-running operations

### 5.4 系統擴展性與未來發展 (System Scalability and Future Development)

#### 5.4.1 模組化設計與擴展性 (Modular Design and Scalability)

Health Mirror 系統採用模組化設計，便於未來擴展和功能增強：

The Health Mirror system adopts a modular design, facilitating future expansion and functional enhancement:

1. **模組化 AI 模型**：每個健康檢測功能使用獨立的 AI 模型，可以單獨更新和優化，無需修改整個系統。
2. **可插拔應用架構**：使用 Django 的應用機制，可以輕鬆添加新的功能模組，如營養建議、運動追蹤等。
3. **API 優先設計**：系統提供 RESTful API，便於與移動應用、穿戴設備和第三方服務集成。
4. **可擴展的數據模型**：數據模型設計考慮了未來擴展，使用 JSONField 存儲靈活的結構化數據。

1. **Modular AI Models**: Each health detection function uses an independent AI model that can be updated and optimized individually without modifying the entire system.
2. **Pluggable Application Architecture**: Using Django's application mechanism, new functional modules such as nutrition advice and exercise tracking can be easily added.
3. **API-First Design**: The system provides RESTful APIs, facilitating integration with mobile applications, wearable devices, and third-party services.
4. **Extensible Data Models**: Data model design considers future expansion, using JSONField to store flexible structured data.

#### 5.4.2 未來發展路線圖 (Future Development Roadmap)

系統的未來發展計劃包括：

Future development plans for the system include:

1. **增強 AI 能力**：
   - 整合更多健康指標檢測，如疲勞度、壓力水平等
   - 實施時序分析，提供長期健康趨勢預測
   - 引入個性化健康建議引擎

2. **擴展平台功能**：
   - 開發移動應用，提供隨時隨地的健康監測
   - 增加社區功能，促進用戶間的健康知識分享
   - 實施遠程醫療諮詢，直接連接用戶和醫療專業人員

3. **技術升級**：
   - 遷移到微服務架構，提高系統彈性和可擴展性
   - 實施邊緣計算，減少雲端依賴並提高響應速度
   - 引入聯邦學習，在保護隱私的同時提高模型性能

1. **Enhanced AI Capabilities**:
   - Integrating more health indicator detection, such as fatigue level, stress level, etc.
   - Implementing time series analysis to provide long-term health trend predictions
   - Introducing personalized health recommendation engines

2. **Expanded Platform Functions**:
   - Developing mobile applications for health monitoring anytime, anywhere
   - Adding community features to promote health knowledge sharing among users
   - Implementing telemedicine consultation, directly connecting users and healthcare professionals

3. **Technical Upgrades**:
   - Migrating to microservice architecture to improve system resilience and scalability
   - Implementing edge computing to reduce cloud dependency and improve response speed
   - Introducing federated learning to improve model performance while protecting privacy

## 5.5 系統部署與維護

本節詳細說明系統的部署流程和維護策略，確保系統在生產環境中穩定運行並能夠持續優化。

> **System Deployment and Maintenance**
>
> This section details the system deployment process and maintenance strategies to ensure stable operation in the production environment and continuous optimization.

### 5.5.1 部署流程與環境配置

系統採用容器化部署方案，使用Docker和Docker Compose實現環境一致性和快速部署。部署流程包括以下步驟：

1. **環境準備**：配置生產服務器，安裝Docker和Docker Compose，設置網絡和安全規則。

2. **容器化應用**：將Django應用、AI模型服務和數據庫服務分別打包為Docker容器。

```dockerfile
# Dockerfile for Django Application
FROM python:3.9-slim

WORKDIR /app

# 安裝系統依賴
RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential libpq-dev \
    && rm -rf /var/lib/apt/lists/*

# 安裝Python依賴
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 複製應用代碼
COPY . .

# 收集靜態文件
RUN python manage.py collectstatic --noinput

# 設置環境變量
ENV DJANGO_SETTINGS_MODULE=mirror_project.settings.production
ENV PYTHONUNBUFFERED=1

# 暴露端口
EXPOSE 8000

# 啟動命令
CMD ["gunicorn", "--bind", "0.0.0.0:8000", "mirror_project.wsgi:application"]
```

3. **編排服務**：使用Docker Compose定義和管理多容器應用。

```yaml
# docker-compose.yml
version: '3.8'

services:
  db:
    image: postgres:13
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    env_file:
      - ./.env.db
    restart: always
  
  redis:
    image: redis:6
    volumes:
      - redis_data:/data
    restart: always
  
  web:
    build: .
    volumes:
      - static_volume:/app/staticfiles
      - media_volume:/app/media
    depends_on:
      - db
      - redis
    env_file:
      - ./.env.prod
    restart: always
  
  celery:
    build: .
    command: celery -A mirror_project worker -l info
    volumes:
      - ./:/app/
    depends_on:
      - db
      - redis
    env_file:
      - ./.env.prod
    restart: always
  
  nginx:
    image: nginx:1.21
    volumes:
      - ./nginx/conf.d:/etc/nginx/conf.d
      - static_volume:/home/app/staticfiles
      - media_volume:/home/app/media
    ports:
      - "80:80"
      - "443:443"
    depends_on:
      - web
    restart: always

volumes:
  postgres_data:
  redis_data:
  static_volume:
  media_volume:
```

4. **CI/CD流程**：實現持續集成和持續部署，自動化測試和部署過程。

```yaml
# .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: '3.9'
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - name: Run tests
        run: |
          python manage.py test
  
  deploy:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to server
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.SSH_KEY }}
          script: |
            cd /path/to/project
            git pull
            docker-compose -f docker-compose.prod.yml down
            docker-compose -f docker-compose.prod.yml up -d --build
```

> **Deployment Process and Environment Configuration**
>
> The system adopts a containerized deployment solution using Docker and Docker Compose to achieve environment consistency and rapid deployment. The deployment process includes the following steps:
>
> 1. **Environment Preparation**: Configure production servers, install Docker and Docker Compose, set up network and security rules.
>
> 2. **Containerize Applications**: Package Django applications, AI model services, and database services as separate Docker containers.
>
> 3. **Service Orchestration**: Use Docker Compose to define and manage multi-container applications.
>
> 4. **CI/CD Process**: Implement continuous integration and continuous deployment to automate testing and deployment processes.

### 5.5.2 系統監控與維護策略

為確保系統穩定運行，我們實施了全面的監控和維護策略：

1. **性能監控**：使用Prometheus和Grafana建立監控儀表板，實時監控系統資源使用情況、響應時間和錯誤率。

```yaml
# prometheus.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'django'
    static_configs:
      - targets: ['web:8000']
  
  - job_name: 'nginx'
    static_configs:
      - targets: ['nginx-exporter:9113']
  
  - job_name: 'postgres'
    static_configs:
      - targets: ['postgres-exporter:9187']
  
  - job_name: 'redis'
    static_configs:
      - targets: ['redis-exporter:9121']
```

2. **日誌管理**：集中收集和分析系統日誌，使用ELK Stack（Elasticsearch, Logstash, Kibana）實現日誌可視化和異常檢測。

```python
# settings.py 日誌配置
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'file': {
            'level': 'INFO',
            'class': 'logging.FileHandler',
            'filename': '/var/log/django/mirror.log',
            'formatter': 'verbose',
        },
        'console': {
            'level': 'INFO',
            'class': 'logging.StreamHandler',
            'formatter': 'verbose',
        },
    },
    'loggers': {
        'django': {
            'handlers': ['file', 'console'],
            'level': 'INFO',
            'propagate': True,
        },
        'base': {
            'handlers': ['file', 'console'],
            'level': 'INFO',
            'propagate': True,
        },
    },
}
```

3. **自動備份**：實施定期數據庫備份策略，確保數據安全。

```bash
#!/bin/bash
# backup.sh - 自動備份腳本

DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR=/var/backups/postgres

# 創建備份目錄
mkdir -p $BACKUP_DIR

# 執行數據庫備份
docker exec mirror_db_1 pg_dump -U postgres -d mirror_db > $BACKUP_DIR/mirror_db_$DATE.sql

# 壓縮備份文件
gzip $BACKUP_DIR/mirror_db_$DATE.sql

# 刪除7天前的備份
find $BACKUP_DIR -name "*.gz" -mtime +7 -delete

# 上傳到遠程存儲
aws s3 cp $BACKUP_DIR/mirror_db_$DATE.sql.gz s3://mirror-backups/
```

4. **更新與補丁管理**：建立系統更新流程，定期應用安全補丁和功能更新。

5. **容量規劃**：根據使用趨勢進行容量規劃，確保系統資源充足。

6. **災難恢復計劃**：制定詳細的災難恢復計劃，包括備份恢復、服務遷移和故障轉移策略。

> **System Monitoring and Maintenance Strategy**
>
> To ensure stable system operation, we have implemented comprehensive monitoring and maintenance strategies:
>
> 1. **Performance Monitoring**: Use Prometheus and Grafana to establish monitoring dashboards, real-time monitoring of system resource usage, response time, and error rates.
>
> 2. **Log Management**: Centrally collect and analyze system logs, using the ELK Stack (Elasticsearch, Logstash, Kibana) to achieve log visualization and anomaly detection.
>
> 3. **Automatic Backup**: Implement regular database backup strategies to ensure data security.
>
> 4. **Updates and Patch Management**: Establish system update processes, regularly apply security patches and feature updates.
>
> 5. **Capacity Planning**: Conduct capacity planning based on usage trends to ensure sufficient system resources.
>
> 6. **Disaster Recovery Plan**: Develop detailed disaster recovery plans, including backup recovery, service migration, and failover strategies.

---

## 結論 (Conclusion)

Health Mirror 以面部影像 AI 為切入點，將即時檢測、個人化追蹤與醫療預約整合為閉環服務，回應了健康可及性與預防醫療的核心訴求。透過「敏捷 + 風險驅動 + DevOps」的專案方法論，本專案在保障創新速度的同時，建立了可驗證的品質門檻與可維運的工程基礎。未來工作將聚焦於模型泛化能力提升、更多健康指標拓展、合規與隱私強化，以及醫療生態合作深化，持續將技術能力轉化為可被不同人群公平使用的健康服務價值。

By fusing real-time facial AI detection, personalization, and appointment integration, Health Mirror addresses accessibility and preventive healthcare needs. A hybrid of Agile, risk-driven governance, and DevOps balances innovation with quality and operability. Future work will strengthen model generalization, expand indicators, deepen compliance and privacy, and broaden healthcare partnerships—continually translating technical capability into equitable health value for diverse populations.