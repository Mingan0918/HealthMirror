# Health Mirrorï¼šåŸºæ–¼äººå·¥æ™ºèƒ½çš„å¯¦æ™‚å¥åº·ç›£æ¸¬ç³»çµ±
*Health Mirror: AI-Based Real-Time Health Monitoring System*

## æ‘˜è¦ (Abstract)

åœ¨ç•¶ä»Šæ•¸ä½å¥åº·å¿«é€Ÿç™¼å±•çš„æ™‚ä»£ï¼Œå‚³çµ±å¥åº·ç›£æ¸¬æ–¹æ³•é¢è‡¨è‘—é‡å¤§æŒ‘æˆ°ã€‚ç¾æœ‰çš„å¥åº·è©•ä¼°é«”ç³»å¾€å¾€ä¾è³´æ–¼æ˜‚è²´çš„å°ˆæ¥­è¨­å‚™ã€éœ€è¦å°ˆæ¥­é†«ç™‚äººå“¡çš„æ“ä½œï¼Œä¸¦ä¸”é€šå¸¸åªèƒ½åœ¨é†«ç™‚æ©Ÿæ§‹å…§é€²è¡Œï¼Œé€™å°è‡´äº†å®šæœŸå¥åº·ç›£æ¸¬åœ¨å¯åŠæ€§ã€ä¾¿åˆ©æ€§å’Œæˆæœ¬æ§åˆ¶æ–¹é¢å­˜åœ¨é¡¯è‘—éšœç¤™ã€‚éš¨è‘—ç¾ä»£ç”Ÿæ´»ç¯€å¥çš„åŠ å¿«å’Œå·¥ä½œå£“åŠ›çš„å¢å¤§ï¼Œäººå€‘å°èƒ½å¤ èå…¥æ—¥å¸¸ç”Ÿæ´»çš„ä¾¿æ·ã€æº–ç¢ºä¸”å¯¦æ™‚çš„å¥åº·ç›£æ¸¬è§£æ±ºæ–¹æ¡ˆéœ€æ±‚æ—¥ç›Šè¿«åˆ‡ã€‚

Health Mirror å°ˆæ¡ˆè‡´åŠ›æ–¼é€šéå…ˆé€²çš„äººå·¥æ™ºèƒ½æŠ€è¡“é©æ–°å€‹äººå¥åº·ç›£æ¸¬æ¨¡å¼ï¼Œæ§‹å»ºä¸€å€‹åŸºæ–¼è¨ˆç®—æ©Ÿè¦–è¦ºå’Œæ·±åº¦å­¸ç¿’çš„å¯¦æ™‚å¥åº·æª¢æ¸¬ç³»çµ±ã€‚è©²ç³»çµ±å·§å¦™åœ°æ•´åˆäº† YOLO ç›®æ¨™æª¢æ¸¬æ¡†æ¶ã€OpenCV åœ–åƒè™•ç†æŠ€è¡“ã€InsightFace äººè‡‰è­˜åˆ¥ç³»çµ±ä»¥åŠ DeepSORT ç›®æ¨™è¿½è¹¤æ¼”ç®—æ³•ï¼Œèƒ½å¤ åœ¨æ¨™æº–æ”åƒé ­ç’°å¢ƒä¸‹å°é»‘çœ¼åœˆã€å”‡éƒ¨ç‹€æ³å’Œçš®è†šå•é¡Œé€²è¡Œç²¾ç¢ºçš„å¯¦æ™‚åˆ†æã€‚é€šé Django ç¶²é æ¡†æ¶æ§‹å»ºçš„å¾Œç«¯ç³»çµ±å’Œç·šä¸Šé†«ç™‚é ç´„æ•´åˆåŠŸèƒ½ï¼Œå½¢æˆäº†å¾å¥åº·æª¢æ¸¬ã€ç‹€æ³åˆ†æåˆ°é†«ç™‚è«®è©¢çš„å®Œæ•´é–‰ç’°æœå‹™é«”ç³»ã€‚

æœ¬è«–æ–‡éµå¾ªåš´è¬¹çš„ IT å°ˆæ¡ˆç®¡ç†æ¡†æ¶ï¼Œå¾æ¥­å‹™ç›®æ¨™è­˜åˆ¥ã€å¯è¡Œæ€§ç ”ç©¶ã€åˆ©å®³é—œä¿‚äººå”èª¿ã€æ–¹æ³•è«–é¸æ“‡åˆ°è©³ç´°å¯¦æ–½è¨ˆç•«ï¼Œå°æ•´å€‹å°ˆæ¡ˆé€²è¡Œç³»çµ±åŒ–çš„è¦åŠƒå’Œé—¡è¿°ã€‚é‡é»é—œæ³¨æŠ€è¡“å¯è¡Œæ€§ã€ç¶“æ¿Ÿå¯è¡Œæ€§å’Œå¸‚å ´å¯è¡Œæ€§ä¸‰å€‹ç¶­åº¦ï¼Œç¢ºä¿æŠ€è¡“å‰µæ–°èƒ½å¤ æœ€çµ‚è½‰åŒ–ç‚ºå¯¦ç”¨ã€å¯ç¶­é‹ä¸”å…·æœ‰ç¤¾æœƒåƒ¹å€¼çš„è§£æ±ºæ–¹æ¡ˆã€‚

## Abstract

In today's rapidly advancing digital health era, traditional health monitoring methods face significant challenges. Existing health assessment systems often rely on expensive professional equipment, require operation by trained medical personnel, and are typically confined to medical facilities, creating substantial barriers in terms of accessibility, convenience, and cost control for regular health monitoring. With the accelerating pace of modern life and increasing work-related stress, there is a growing urgent need for convenient, accurate, and real-time health monitoring solutions that can be seamlessly integrated into daily routines.

The Health Mirror project aims to revolutionize personal health monitoring through advanced artificial intelligence technologies, building a real-time health detection system based on computer vision and deep learning. The system skillfully integrates the YOLO object detection framework, OpenCV image processing technology, InsightFace facial recognition system, and DeepSORT object tracking algorithms, enabling precise real-time analysis of dark circles, lip conditions, and skin problems using standard camera environments. Through a backend system built with the Django web framework and integrated online medical appointment functionality, it creates a complete closed-loop service system from health detection and condition analysis to medical consultation.

This paper follows a rigorous IT project management framework, systematically planning and articulating the entire project from business objective identification, feasibility studies, stakeholder coordination, methodology selection, to detailed implementation plans. The focus is on three dimensions: technical feasibility, economic feasibility, and market feasibility, ensuring that technological innovation can ultimately be transformed into practical, maintainable solutions with social value.

---

## ç¬¬ä¸€ç«  ä»‹ç´¹ (Chapter I: Introduction)

### 1.1 å¾æ¥­å‹™ç›®æ¨™è©•ä¼°ä¸­è­˜åˆ¥æ½›åœ¨çš„ IT å°ˆæ¡ˆ (Identify potential IT projects from business objectives)

Health Mirror çš„æ¥­å‹™é¡˜æ™¯æ˜¯è®“äººäººçš†å¯ç²å¾—ä¾¿æ·ã€æº–ç¢ºèˆ‡å¯æŒçºŒçš„å¥åº·ç›£æ¸¬ã€‚å¾é€™ä¸€é¡˜æ™¯å‡ºç™¼ï¼Œé¦–å…ˆè­˜åˆ¥åˆ°ä¸‰é¡æ ¸å¿ƒ IT å°ˆæ¡ˆï¼šå…¶ä¸€æ˜¯ä»¥ YOLOã€OpenCV ç‚ºæ ¸å¿ƒçš„ã€Œå³æ™‚å½±åƒ AI å¥åº·æª¢æ¸¬å°ˆæ¡ˆã€ï¼Œåœ¨æ¨™æº–æ”åƒé ­è¼¸å…¥çš„æ¢ä»¶ä¸‹å¿«é€ŸæŠ½å–å¥åº·æŒ‡æ¨™ï¼›å…¶äºŒæ˜¯çµåˆ InsightFace èˆ‡ DeepSORT çš„ã€Œå€‹äººåŒ–è¾¨è­˜èˆ‡è¿½è¹¤å°ˆæ¡ˆã€ï¼Œç”¨ä»¥å»ºç«‹ç©©å®šä¸”éš±ç§ä¿è­·çš„ç”¨æˆ¶å¥åº·ç¸±å‘æª”æ¡ˆï¼›å…¶ä¸‰æ˜¯åŸºæ–¼ Django çš„ã€Œæ•¸æ“šå¹³å°èˆ‡é†«ç™‚é ç´„æ•´åˆå°ˆæ¡ˆã€ï¼Œè² è²¬ç”¨æˆ¶ç®¡ç†ã€çµæœå‘ˆç¾ã€é†«ç™‚è³‡æºè·¯ç”±èˆ‡åˆè¦æ€§ä¿éšœã€‚é€™ä¸‰è€…å…±åŒæ§‹æˆ Health Mirror çš„æŠ€è¡“åº•åº§èˆ‡æœå‹™èƒ½åŠ›é‚Šç•Œï¼Œç›´æ¥å°æ‡‰æ—¢å®šçš„å¯åŠæ€§ã€æº–ç¢ºæ€§èˆ‡é–‰ç’°æœå‹™çš„æ¥­å‹™ç›®æ¨™ã€‚

The business vision of Health Mirror is to make health monitoring accessible, accurate, and sustainable. From this vision, three potential IT projects are identified: an AI-based real-time visual detection project using YOLO and OpenCV; a personalization project leveraging InsightFace and DeepSORT to maintain longitudinal, privacy-preserving user profiles; and a Django-based data platform and medical appointment integration project handling user management, result visualization, routing to care, and compliance. Together, these projects form the technical foundation and service boundary aligned with the established objectives of accessibility, accuracy, and closed-loop care.

### 1.2 å°ˆæ¡ˆå¯è¡Œæ€§ç ”ç©¶ (Perform a project feasibility study)

æŠ€è¡“å±¤é¢ä¸Šï¼ŒYOLO å°å°ç›®æ¨™èˆ‡å¤šé¡åˆ¥æª¢æ¸¬çš„æˆç†Ÿåº¦ï¼Œä»¥åŠ OpenCV åœ¨å½±åƒå‰è™•ç†çš„ç©©å®šæ€§ï¼Œä½¿å³æ™‚é¢éƒ¨å¥åº·åˆ†æå…·å‚™è½åœ°æ¢ä»¶ï¼›InsightFace åœ¨äººè‡‰ç‰¹å¾µåµŒå…¥èˆ‡ç›¸ä¼¼åº¦åŒ¹é…ä¸Šçš„å…ˆé€²æ€§ï¼Œç¢ºä¿å€‹äººåŒ–è¿½è¹¤çš„ç²¾æº–åº¦ï¼›Django ä½œç‚ºå¾Œç«¯æ¡†æ¶åœ¨èªè­‰ã€ORM èˆ‡å®‰å…¨æ€§æ–¹é¢å®Œå–„ï¼Œåˆ©æ–¼å¿«é€Ÿè¿­ä»£èˆ‡åˆè¦éƒ¨ç½²ã€‚ç¶“æ¿Ÿå±¤é¢ä¸Šï¼Œå°ˆæ¡ˆæ¡ç”¨é–‹æºæŠ€è¡“ã€é›²ç«¯æŒ‰éœ€è³‡æºèˆ‡æ¨¡çµ„åŒ–è¨­è¨ˆï¼Œæœ‰åŠ©æ–¼æ§åˆ¶å‰æœŸæŠ•å…¥ä¸¦æ”¯æ’å½ˆæ€§æ“´å±•ï¼›å•†æ¥­æ¨¡å¼å¯æ¡å…è²»å¢å€¼èˆ‡ B2B é†«ç™‚åˆä½œä¸¦è¡Œï¼Œé€æ­¥å»ºç«‹æ”¶ç›Šé–‰ç’°ã€‚å¸‚å ´å±¤é¢ä¸Šï¼Œæ•¸ä½å¥åº·èˆ‡é é˜²é†«ç™‚éœ€æ±‚æŒçºŒå¢é•·ï¼Œç¾æœ‰ç«¶å“å¤šèšç„¦æ´»å‹•ç›£æ¸¬èˆ‡ç”Ÿå‘½è·¡è±¡ï¼Œå°æ–¼é¢éƒ¨å¥åº·ç‰¹å¾µçš„å³æ™‚è©•ä¼°ä»å­˜åœ¨å·®ç•°åŒ–ç©ºé–“ã€‚ç¶œåˆè§€ä¹‹ï¼Œå°ˆæ¡ˆåœ¨æŠ€è¡“ã€ç¶“æ¿Ÿèˆ‡å¸‚å ´ä¸‰æ–¹é¢å…·å‚™å¯è¡Œæ€§ã€‚

From a technical perspective, the maturity of YOLO for small-object and multi-class detection and OpenCV for stable preprocessing enables deployable facial analysis; the strength of InsightFace in feature embedding and matching ensures accurate personalization, while Django provides authentication, ORM, and security for rapid iteration and compliant deployment. Economically, open-source stacks, on-demand cloud resources, and modular design reduce upfront costs and support scalable growth; a freemium plus B2B medical partnership model establishes a viable revenue loop. The market shows sustained demand for digital health and preventive care, with a differentiation opportunity in real-time facial health assessment compared to activity/biometric-focused incumbents. Overall, the project is feasible across technical, economic, and market dimensions.

### 1.3 èˆ‡é—œéµåˆ©å®³é—œä¿‚äººç¢ºç«‹ç›®æ¨™èˆ‡ç›®çš„ (Determine aims and objectives with key stakeholders)

æœ¬å°ˆæ¡ˆçš„æ ¸å¿ƒç›®æ¨™èˆ‡åˆ©å®³é—œä¿‚äººå…±åŒåˆ¶å®šï¼šå°æœ€çµ‚ç”¨æˆ¶è€Œè¨€ï¼Œç›®æ¨™æ˜¯æä¾›ä½é–€æª»ã€æ˜“ç†è§£ä¸”å¯è¡Œå‹•çš„å¥åº·æ´å¯Ÿï¼Œä¸¦å¯ç›´æ¥éŠœæ¥é†«ç™‚æœå‹™ï¼›å°åˆä½œé†«é™¢èˆ‡ä¿éšªæ–¹ï¼Œç›®æ¨™æ˜¯æå‡åˆ†è¨ºæ•ˆç‡ã€ç¸®çŸ­ç­‰å¾…æ™‚é–“èˆ‡å„ªåŒ–é†«ç™‚è³‡æºé…ç½®ï¼›å°ç›£ç®¡æ©Ÿæ§‹ï¼Œç›®æ¨™æ˜¯ç¢ºä¿è³‡æ–™ä¿è­·ã€å¯©è¨ˆå¯è¿½èˆ‡é†«ç™‚åˆè¦ï¼›å°æŠ•è³‡æ–¹èˆ‡åˆä½œå¤¥ä¼´ï¼Œç›®æ¨™æ˜¯ä»¥æ˜ç¢ºçš„é‡Œç¨‹ç¢‘é©…å‹•å¯é æœŸçš„å•†æ¥­åŒ–è·¯å¾‘ã€‚æ“šæ­¤å½¢æˆé‡åŒ–ç›®çš„ï¼šåœ¨ MVP éšæ®µé”æˆä¸»è¦æ¨¡å‹çš„æº–ç¢ºåº¦é–€æª»ã€å®Œå‚™ç”¨æˆ¶èˆ‡é ç´„æµç¨‹ã€å»ºç«‹åˆæ­¥åˆä½œç¶²çµ¡èˆ‡ç”¨æˆ¶é©—è­‰ï¼Œä¸¦ä»¥å¾ªç’°è¿­ä»£æ–¹å¼æŒçºŒæå‡é«”é©—èˆ‡å¯ä¿¡åº¦ã€‚

Project aims are co-defined with stakeholders: for end users, low-barrier, comprehensible, and actionable insights with direct pathways to care; for partner hospitals and insurers, improved triage efficiency, reduced waiting times, and better resource allocation; for regulators, strong data protection, auditable processes, and medical compliance; for investors and partners, milestone-driven commercialization. Quantified objectives include meeting model accuracy thresholds in MVP, completing user and booking flows, securing initial partnerships and user validation, and iteratively improving experience and trust.

### 1.4 å¯©è¦–é©ç”¨çš„æ–¹æ³•è«– (Review suitable project methodologies)

é‘‘æ–¼ AI å°ˆæ¡ˆçš„æ¢ç´¢æ€§èˆ‡ä¸ç¢ºå®šæ€§ï¼Œé«˜åº¦è¿­ä»£çš„æ•æ·æ–¹æ³•è«–æœ‰åŠ©æ–¼ä»¥çŸ­é€±æœŸäº¤ä»˜å¯é©—è­‰å¢é‡ï¼Œå¿«é€Ÿå¸æ”¶ç”¨æˆ¶èˆ‡è‡¨åºŠå›é¥‹ï¼›èºæ—‹/é¢¨éšªé©…å‹•æ–¹æ³•å¯åœ¨é—œéµæŠ€è¡“é»ï¼ˆå¦‚æ¨¡å‹æ³›åŒ–ã€è³‡æ–™åå·®èˆ‡éš±ç§ä¿è­·ï¼‰è¨­ç½®é¢¨éšªé–€æª»èˆ‡ç·©è§£ç­–ç•¥ï¼›è€Œ DevOps æ–‡åŒ–å‰‡ç¢ºä¿å¾é–‹ç™¼ã€æ¸¬è©¦åˆ°éƒ¨ç½²èˆ‡ç›£æ§çš„è‡ªå‹•åŒ–èˆ‡ä¸€è‡´æ€§ï¼Œç¸®çŸ­äº¤ä»˜éˆè·¯ä¸¦æå‡å¯ç”¨æ€§ã€‚ç›¸è¼ƒæ–¼ç€‘å¸ƒæ¨¡å‹ï¼Œä»¥ä¸Šæ–¹æ³•æ›´èƒ½åŒ¹é…ã€Œå¯¦é©—â€”é©—è­‰â€”èª¿å„ªã€çš„è¿­ä»£ç¯€å¥èˆ‡åˆè¦ä¸Šç·šçš„é›™é‡è¦æ±‚ã€‚

Given the exploratory nature of AI, Agile supports short-cycle, verifiable increments and rapid incorporation of user/clinical feedback; a spiral/risk-driven layer enforces gates around model generalization, data bias, and privacy; DevOps ensures automation and consistency from build to monitoring, shortening delivery cycles and improving availability. Compared to waterfall, this triad better matches the experimentâ€“validateâ€“optimize rhythm while meeting compliance requirements.

### 1.5 æ–¹æ³•è«–é¸æ“‡ä¹‹è«–è­‰ (Justify the chosen methodology)

Health Mirror æ¡ç”¨ã€Œæ•æ· + é¢¨éšªé©…å‹• + DevOpsã€çš„æ··åˆæ–¹æ³•ã€‚å…¶åˆç†æ€§åœ¨æ–¼ï¼šAI æª¢æ¸¬èˆ‡å€‹äººåŒ–æœå‹™æ¶‰åŠå¤šæºè³‡æ–™ã€æ¨¡å‹èª¿åƒèˆ‡äººå› è®Šé‡ï¼Œéœ€ä»¥çŸ­è¿­ä»£æŒçºŒé©—è­‰ï¼›åŒæ™‚é†«ç™‚å ´æ™¯å°ç©©å®šæ€§èˆ‡åˆè¦æœ‰é«˜è¦æ±‚ï¼Œéœ€ä»¥é¢¨éšªé–€è¨­è¨ˆç¢ºä¿é—œéµå“è³ªé–€æª»ï¼›è€Œåœ¨å¤šæ¨¡çµ„æ•´åˆèˆ‡é›²ç«¯éƒ¨ç½²ä¸‹ï¼ŒCI/CD èˆ‡å¯è§€æ¸¬æ€§æ˜¯ç¶­é‹æ•ˆç‡èˆ‡ç”¨æˆ¶é«”é©—çš„å‰ç½®æ¢ä»¶ã€‚æ­¤çµ„åˆæ—¢ä¿éšœäº†å‰µæ–°çš„é€Ÿåº¦ï¼Œä¹Ÿç¢ºä¿ç”¢å“æˆç†Ÿåº¦èˆ‡å¯é æ€§ã€‚

Health Mirror adopts a hybrid of Agile, risk-driven governance, and DevOps. Short iterations validate models and features amidst data diversity and human factors; risk gates enforce quality for sensitive medical contexts; CI/CD and observability underpin integration and cloud deployment. The combination balances innovation speed with product maturity and reliability.

---

## ç¬¬äºŒç«  æ¼”ç®—æ³•èˆ‡å°ˆæ¡ˆå¯¦æ–½è¨ˆç•« (Chapter II: Algorithms and Implementation Planning)

æœ¬ç« ä»¥ç³»çµ±ã€Œç”¨åˆ°äº†å“ªäº›æ¼”ç®—æ³•ã€ç‚ºä»€éº¼ç”¨ã€å¦‚ä½•è¨“ç·´èˆ‡éƒ¨ç½²ã€å¦‚ä½•é©—è­‰èˆ‡å„ªåŒ–ã€ç‚ºä¸»è»¸ï¼Œå¾ªåºèªªæ˜å¾å½±åƒå‰è™•ç†ã€åµæ¸¬ã€è¾¨è­˜åˆ°è¿½è¹¤èˆ‡æ¨è«–æœ€ä½³åŒ–çš„å®Œæ•´æŠ€è¡“è·¯å¾‘ã€‚é¦–å…ˆç¸½è¦½æ‰€æ¡ç”¨çš„é—œéµæ¼”ç®—æ³•èˆ‡æŠ€è¡“å…ƒä»¶ï¼šYOLO ç³»åˆ—ç›®æ¨™åµæ¸¬ã€ç‰¹å¾µé‡‘å­—å¡” FPN/PANã€å¤šå°ºåº¦è³‡æ–™å¢å¼·ã€IoU å®¶æ—é‚Šæ¡†å›æ­¸æå¤±ã€NMS/Soft-NMS æŠ‘åˆ¶ã€OpenCV å‰è™•ç†ï¼ˆå»å™ªã€å°æ¯”èˆ‡ä¼½ç‘ªæ ¡æ­£ã€CLAHEã€è‰²å½©ç©ºé–“è½‰æ›ã€å½¢æ…‹å­¸é‹ç®—ã€Canny é‚Šç·£åµæ¸¬ã€ROI æ¨™æº–åŒ–ï¼‰ã€InsightFace + ArcFace åµŒå…¥èˆ‡é¤˜å¼¦ç›¸ä¼¼åº¦åŒ¹é…ã€DeepSORT ä»¥å¡çˆ¾æ›¼æ¿¾æ³¢ + åŒˆç‰™åˆ©æ¼”ç®—æ³• + å¤–è§€åµŒå…¥/IoU åšé—œè¯ã€ä»¥åŠæ•´é«”æ¨è«–çš„ä¸¦è¡ŒåŒ–èˆ‡æ··åˆç²¾åº¦æœ€ä½³åŒ–ã€‚èˆ‡æ­¤åŒæ™‚ï¼Œæˆ‘å€‘çµ¦å‡ºå°æ‡‰çš„å¯¦ä½œç´°ç¯€ã€è¨“ç·´èˆ‡è©•ä¼°æµç¨‹ï¼Œä»¥åŠèª¤å·®åˆ†æèˆ‡æ¶ˆèå¯¦é©—ç­–ç•¥ï¼Œä»¥ç¢ºä¿æ¼”ç®—æ³•ä¸åƒ…èƒ½åœ¨ç ”ç©¶ç’°å¢ƒä¸­è¡¨ç¾è‰¯å¥½ï¼Œæ›´èƒ½ç©©å¥è½åœ°åˆ°å¯¦éš›å ´æ™¯ã€‚

This chapter explains which algorithms are used, why they are chosen, how they are trained and deployed, and how they are validated and optimized across preprocessing, detection, recognition, tracking, and inference. Key components include: YOLO object detection, FPN/PAN multi-scale fusion, multi-scale data augmentation, IoU-family box regression losses, NMS/Soft-NMS, OpenCV preprocessing (denoising, contrast/gamma correction, CLAHE, color space transforms, morphology, Canny edges, ROI normalization), InsightFace with ArcFace embeddings and cosine matching, DeepSORT with a Kalman filter, Hungarian assignment, and appearance/IoU association, as well as pipeline-level parallelism and mixed-precision optimization. We detail implementation, training and evaluation, error analysis, and ablations to ensure robustness from lab to real-world deployment.

### 2.1 YOLO ç›®æ¨™æª¢æ¸¬èˆ‡è¨“ç·´ (YOLO Object Detection and Training)

ä»»å‹™èˆ‡æ¨¡å‹ï¼šæœ¬ç³»çµ±ä»¥ YOLO ç³»åˆ—ç‚ºä¸»è¦åµæ¸¬å¼•æ“ï¼Œé‡å°å¥åº·å ´æ™¯æ‰“é€ å››å¥—å°ˆç”¨æ¬Šé‡ï¼šDarkCircles.ptï¼ˆé»‘çœ¼åœˆï¼‰ã€Lip_types.ptï¼ˆå”‡éƒ¨ç‹€æ³/é¡è‰²ï¼‰ã€skin.ptï¼ˆçš®è†šç‹€æ³ï¼‰ã€health.ptï¼ˆç¶œåˆå¥åº·æŒ‡æ¨™ï¼‰ï¼Œå„è‡ªèšç„¦æ–¼ä¸åŒçš„è‡¨åºŠé—œè¯ç‰¹å¾µä»¥æå‡ç²¾æº–åº¦èˆ‡å¬å›ç‡ã€‚

Tasks and models: We use the YOLO family as the main detection engine with four task-specific weights: DarkCircles.pt (dark circles), Lip_types.pt (lip condition/color), skin.pt (skin condition), and health.pt (composite indicators), each tuned for clinically relevant features to improve precision and recall.

ç¶²è·¯æ¶æ§‹èˆ‡é ­éƒ¨ï¼šéª¨å¹¹æ¡è¼•é‡åŒ–è¨­è¨ˆä»¥å…¼é¡§é‚Šç·£è£ç½®ï¼Œå³åœ¨ä¿æŒæ„Ÿå—é‡çš„åŒæ™‚é™ä½åƒæ•¸é‡ï¼›é ¸éƒ¨ä»¥ FPN/PAN èåˆå¤šå°ºåº¦èªç¾©èˆ‡ç´°ç¯€ç‰¹å¾µï¼›åµæ¸¬é ­ä½¿ç”¨å¯†é›†é æ¸¬ï¼Œè¼”ä»¥ Anchor/Anchor-free é…ç½®èˆ‡å‹•æ…‹ç‰¹å¾µåˆ†é…ç­–ç•¥ã€‚è¼¸å‡ºç«¯é€é NMS æˆ– Soft-NMS æŠ‘åˆ¶é‡ç–Šæ¡†ï¼Œé¿å…é‡è¤‡è­¦ç¤ºèˆ‡èª¤è§¸ç™¼ã€‚

Architecture and heads: A lightweight backbone preserves receptive fields with fewer parameters; an FPN/PAN neck fuses multi-scale semantics and details; the dense detection head supports anchor/anchor-free settings with dynamic feature assignment. NMS or Soft-NMS reduces duplicates to prevent redundant alerts.

æå¤±èˆ‡æœ€ä½³åŒ–ï¼šé‚Šæ¡†å›æ­¸æ¡ IoU å®¶æ—ï¼ˆå¦‚ GIoU/CIoU/DIoUï¼‰å¼·åŒ–å®šä½ï¼›åˆ†é¡/ç‰©ä»¶æ€§ä½¿ç”¨ BCE/Focal Loss æ‡²ç½°é›£ä¾‹ï¼›å¯æ­é… Label smoothing èˆ‡ EMAï¼ˆExponential Moving Averageï¼‰ç©©å®šæ”¶æ–‚ã€‚å­¸ç¿’ç‡ä»¥é¤˜å¼¦é€€ç«æˆ– OneCycle èª¿åº¦ï¼Œå„ªåŒ–å™¨ä¾è³‡æ–™åˆ†å¸ƒåœ¨ SGD(momentum) èˆ‡ AdamW ä¹‹é–“é¸æ“‡ã€‚

Losses and optimization: IoU-family losses (e.g., GIoU/CIoU/DIoU) for box regression; BCE/Focal for classification/objectness with label smoothing and EMA for stability. Learning rate schedules use cosine or OneCycle; optimizers are chosen between SGD (momentum) and AdamW based on data characteristics.

è³‡æ–™èˆ‡å¢å¼·ï¼šè³‡æ–™é›†æ¡åˆ†å±¤åˆ‡åˆ†ï¼ˆTrain/Val/Testï¼‰ï¼Œä¸¦æ–¼å¿…è¦æ™‚ä»¥ K-fold äº¤å‰é©—è­‰æª¢é©—ç©©å¥æ€§ã€‚å¢å¼·åŒ…å« Mosaic/MixUpã€RandomAffine/Perspectiveã€Resizeã€HSV æŠ–å‹•ã€æ°´å¹³ç¿»è½‰èˆ‡éš¨æ©Ÿè£åˆ‡ï¼Œä»¥æ“´å¼µé•·å°¾æ¨£æœ¬èˆ‡å…‰ç…§/å§¿æ…‹è®ŠåŒ–è¦†è“‹é¢ã€‚é€é AutoAnchor æˆ–å‹•æ…‹éŒ¨é»èª¿æ•´é™ä½ä½ˆå±€åå·®ï¼Œä¸¦ä»¥é/æ¬ æ¡æ¨£ç­–ç•¥ç·©è§£é¡åˆ¥ä¸å‡è¡¡ã€‚

Data and augmentation: Stratified splits into Train/Val/Test with optional K-fold cross-validation for robustness. Augmentations include Mosaic, MixUp, RandomAffine/Perspective, Resize, HSV jitter, horizontal flip, and random crop to cover long tails and illumination/pose variations. AutoAnchor or dynamic anchors reduce layout bias; over-/under-sampling mitigates class imbalance.

è¨“ç·´èˆ‡è©•ä¼°ï¼šæ¡ç”¨æ—©åœèˆ‡æœ€ä½³æ¬Šé‡ä¿å­˜ï¼ˆmAP@0.5:0.95 ç‚ºä¸»é¸æ¨™æº–ï¼‰ï¼Œä¸¦è¼¸å‡º PR æ›²ç·šã€æ··æ·†çŸ©é™£èˆ‡ per-class æŒ‡æ¨™ã€‚é‡å°é—œéµå ´æ™¯ï¼ˆå¼±å…‰ã€é®æ“‹ã€ä½©æˆ´å£ç½©/çœ¼é¡ï¼‰é€²è¡Œæƒ…å¢ƒåŒ–æ¸¬è©¦ã€‚éŒ¯èª¤é¡å‹ï¼ˆé‡ç–Šåµæ¸¬ã€èª¤åˆ†é¡æ··æ·†ã€æ¼æª¢ï¼‰å°‡åé¥‹è‡³è¶…åƒæ•¸èˆ‡å¢å¼·ç­–ç•¥èª¿æ•´ã€‚

Training and evaluation: Early stopping with best-weight selection by mAP@0.5:0.95; PR curves, confusion matrices, and per-class metrics are reported. Scenario tests (low light, occlusion, masks/glasses) assess robustness. Error types (duplicate detections, class confusion, misses) feed back into hyperparameter and augmentation tuning.

æ¶ˆèèˆ‡éƒ¨ç½²ï¼šé€²è¡Œå¢å¼·ç­–ç•¥ã€æå¤±çµ„åˆã€NMS é–¾å€¼èˆ‡è¼¸å…¥å°ºå¯¸çš„æ¶ˆèå¯¦é©—ï¼Œé‡åŒ–ç²¾åº¦-å»¶é²æ¬Šè¡¡ã€‚æ¨è«–æ™‚ä¾ç¡¬é«”é¸æ“‡ FP32/FP16ï¼ˆæˆ–å•Ÿç”¨ AMPï¼‰ï¼Œå¯å°å‡º ONNX ä»¥åˆ©è·¨æ¡†æ¶éƒ¨ç½²ï¼›æ ¹æ“šè² è¼‰èª¿æ•´æ‰¹é‡å¤§å°èˆ‡å½±åƒè§£æåº¦ã€‚

Ablations and deployment: We ablate augmentations, loss combinations, NMS thresholds, and input sizes to quantify accuracyâ€“latency trade-offs. Inference uses FP32/FP16 (or AMP), with optional ONNX export for portability; batch size and resolution are tuned to workload.

### 2.2 OpenCV å½±åƒè™•ç†ç®¡é“ (OpenCV Image Processing Pipeline)

å‰è™•ç†æ ¸å¿ƒï¼š
- å»å™ªèˆ‡å¹³æ»‘ï¼šé«˜æ–¯/é›™é‚Š/ä¸­å€¼æ¿¾æ³¢é™ä½æ„Ÿæ¸¬å™¨é›œè¨Šä¸¦ä¿ç•™é‚Šç·£ï¼›å¿…è¦æ™‚çµåˆéå€åŸŸå‡å€¼ï¼ˆNLMï¼‰åœ¨ä½å…‰æºä¸‹æŠ‘å™ªã€‚
- æ›å…‰èˆ‡å°æ¯”ï¼šç·šæ€§å°æ¯”æ‹‰ä¼¸èˆ‡ä¼½ç‘ªæ ¡æ­£ï¼›åœ¨ YCrCb/Lab äº®åº¦é€šé“ä½¿ç”¨ CLAHE åšå€åŸŸå°æ¯”å¢å¼·ï¼Œæ”¹å–„é™°å½±ã€‚
- è‰²å½©æ ¡æ­£èˆ‡æ†å¸¸æ€§ï¼šç°ä¸–ç•Œï¼ˆGray Worldï¼‰èˆ‡ Shades-of-Gray ç™½å¹³è¡¡ä¼°è¨ˆï¼Œæ¸›å°‘è‰²åå°è†šè‰²/å”‡è‰²åˆ¤è®€å½±éŸ¿ã€‚
- é‚Šç·£èˆ‡å½¢æ…‹å­¸ï¼šCanny é‚Šç·£åµæ¸¬è¼”åŠ©è¼ªå»“ç©©å®šï¼›è†¨è„¹/è…è•ã€é–‹é–‰é‹ç®—æ¸…ç†å°å¡Šé›œè¨Šä¸¦è¦æ•´å€åŸŸé‚Šç•Œã€‚
- è‰²å½©ç©ºé–“ï¼šBGR/HSV/YCrCb/Lab è½‰æ›ï¼›ä»¥ HSV/Lab æ¸¬åº¦é¡è‰²å·®ç•°ï¼ˆå¦‚ Î”E/å¹³å‡ a*ï¼‰æ”¯æ´å”‡è‰²é‡åŒ–ã€‚
- ROI èˆ‡å¹¾ä½•ï¼šåˆ©ç”¨è‡‰éƒ¨æ¡†èˆ‡é—œéµé»åšä»¿å°„æ ¡æ­£èˆ‡å°ºåº¦æ¨™æº–åŒ–ï¼Œæé«˜ YOLO èˆ‡è¾¨è­˜çš„ä¸€è‡´æ€§ã€‚

Core preprocessing: Gaussian/bilateral/median (and NLM) denoising; contrast/gamma correction and CLAHE on luminance; Gray-World and Shades-of-Gray white balance; Canny edges and morphology (erode/dilate, open/close); color space transforms (BGR/HSV/YCrCb/Lab) with Î”E/a* for color quantification; and ROI/affine normalization with face boxes/landmarks.

ç‰¹å¾µé‡æ¸¬èˆ‡è¼”åŠ©åˆ¤è®€ï¼š
- é»‘çœ¼åœˆï¼šä»¥çœ¼çœ¶ ROI çš„äº®åº¦/é£½å’Œåº¦åˆ†ä½ˆèˆ‡é„°åŸŸå°æ¯”å·®ä¼°è¨ˆåš´é‡åº¦ã€‚
- å”‡éƒ¨ï¼šåœ¨ Lab/HSV ä¼°è¨ˆå¹³å‡è‰²åº¦èˆ‡é£½å’Œåº¦ï¼Œçµåˆ Î”E èˆ‡çš®è†šå€åŸŸä½œç›¸å°åº¦é‡ï¼Œæå‡å€‹é«”åŒ–ç©©å®šæ€§ã€‚
- çš®è†šï¼šä»¥è‰²å½©å‡å‹»åº¦ã€ç´‹ç†çµ±è¨ˆï¼ˆå¦‚ LBP/GLCM æŒ‡æ¨™ï¼‰è¼”åŠ©é»ƒæ°£/æ³›ç´…/æ–‘é»çš„å®šæ€§åµæ¸¬ï¼Œèˆ‡ YOLO çš„é¡åˆ¥è¼¸å‡ºäº’ç‚ºæ ¡é©—ã€‚

Feature measurements: For dark circles, we use luminance/saturation distributions and local contrast around eye sockets; for lips, mean chroma/saturation in Lab/HSV with Î”E against skin as a personalized baseline; for skin, color uniformity and texture stats (e.g., LBP/GLCM) cross-check YOLO classifications.

æ•ˆèƒ½å·¥ç¨‹ï¼šä»¥ ROI è£åˆ‡ã€SIMD/å‘é‡åŒ–èˆ‡è¨˜æ†¶é«”é‡ç”¨é™ä½å»¶é²ï¼›é‡å°è³‡æºç·Šå¼µç’°å¢ƒå‹•æ…‹èª¿æ•´è§£æåº¦èˆ‡è™•ç†é »ç‡ï¼Œä¿è­‰ç•«é¢æµæš¢èˆ‡åˆ†ææº–ç¢ºçš„å¹³è¡¡ã€‚

Performance engineering: ROI cropping, SIMD/vectorization, and memory reuse reduce latency; dynamic resolution and processing cadence balance smoothness and accuracy under resource pressure.

### 2.3 InsightFace äººè‡‰è¾¨è­˜èˆ‡åµŒå…¥ (InsightFace Recognition and Embedding)

å°é½Šèˆ‡å“è³ªæ§åˆ¶ï¼šä½¿ç”¨è‡‰éƒ¨é—œéµé»ï¼ˆé›™çœ¼ã€é¼»å°–ã€å£è§’ï¼‰é€²è¡Œä»¿å°„å°é½Šï¼Œçµ±ä¸€å°ºåº¦èˆ‡å§¿æ…‹ï¼›è¼¸å…¥åœ–åƒç¶“å“è³ªæª¢æ¸¬ï¼ˆæ¨¡ç³Šåº¦å¦‚æ‹‰æ™®æ‹‰æ–¯æ–¹å·®ã€é®æ“‹æ¯”ç‡ã€äº®åº¦ç¯„åœï¼‰éæ¿¾ä½è³ªæ¨£æœ¬ï¼Œé™ä½èª¤åŒ¹é…ã€‚

Alignment and quality control: Landmark-based affine normalization standardizes pose/scale; quality screening (e.g., Laplacian variance for blur, occlusion ratio, luminance range) filters poor samples to reduce mismatches.

åµŒå…¥èˆ‡è¨“ç·´ç›®æ¨™ï¼šæ¡ç”¨ L2 æ­£è¦åŒ–çš„ 512 ç¶­ç‰¹å¾µåµŒå…¥ï¼Œè¨“ç·´æ™‚ä½¿ç”¨ ArcFace é¡è§’åº¦é‚Šç•Œæå¤±ï¼ˆå¸¸è¦‹è¨­ç½®å¦‚ sâ‰ˆ64ã€mâ‰ˆ0.5ï¼‰æå‡é¡é–“é–“éš”èˆ‡é¡å…§ç·Šæ¹Šåº¦ï¼Œå¼·åŒ–è·¨å…‰ç…§/å¹´é½¡/è¡¨æƒ…æ¢ä»¶çš„åˆ¤åˆ¥åŠ›ã€‚

Embeddings and objectives: L2-normalized 512-D embeddings trained with ArcFace-like angular-margin losses (typical sâ‰ˆ64, mâ‰ˆ0.5) increase inter-class margins and intra-class compactness, improving invariance to illumination, age, and expression.

åŒ¹é…èˆ‡æ¨£æœ¬åº«ï¼šä»¥é¤˜å¼¦ç›¸ä¼¼åº¦èˆ‡å¯é…ç½®é–¾å€¼åšä¸€å°ä¸€åŒ¹é…ï¼›æ¯ä½ä½¿ç”¨è€…ç¶­è­·å¤šæ¨£æœ¬æ¨¡æ¿ï¼Œé€éç§»å‹•å¹³å‡æˆ–èšé¡æ›´æ–°ä»¥é©æ‡‰é•·æœŸå¤–è§€æ¼‚ç§»ã€‚å°æ•æ„Ÿå ´æ™¯æä¾›åŒ¿ååŒ–èˆ‡ã€Œåƒ…æœ¬åœ°åµŒå…¥ã€åˆ†é›¢å­˜æ”¾å€‹è³‡ã€çš„éš±ç§ä¿è­·æ¨¡å¼ã€‚

Matching and galleries: Cosine similarity with configurable thresholds; per-user multi-sample templates updated via moving averages or clustering to adapt to long-term drift. Privacy modes include local-only embeddings and separate storage from PII.

æ“´å±•èˆ‡é˜²å½ï¼šå¯é¸ç”¨ç°¡å–®æ´»é«”æª¢æ¸¬ï¼ˆçœ¨çœ¼/é ­éƒ¨å¾®å‹•æ…‹ã€ç´‹ç†åå°„ç‰¹å¾µï¼‰ä½œé˜²å½é–€æª»ï¼Œå¹³è¡¡é«”é©—èˆ‡å®‰å…¨æ€§éœ€æ±‚ã€‚

Extensions and anti-spoofing: Optional lightweight liveness checks (blink/micro-motion cues, texture reflectance) provide anti-spoofing with balanced UX and security.

### 2.4 DeepSORT è¿½è¹¤èˆ‡é—œè¯ (DeepSORT Tracking and Association)

ç‹€æ…‹æ¨¡å‹èˆ‡é æ¸¬ï¼šæ¡ç”¨å¸¸é€Ÿæ¨¡å‹çš„å¡çˆ¾æ›¼æ¿¾æ³¢å™¨ï¼Œç‹€æ…‹å‘é‡åŒ…å«ä¸­å¿ƒåº§æ¨™ã€ç¸±æ©«æ¯”èˆ‡é«˜åº¦åŠå…¶é€Ÿåº¦åˆ†é‡ï¼Œå°åµæ¸¬é–“éš™é€²è¡Œæ™‚åŸŸå¤–æ¨ï¼ŒæŠ‘åˆ¶çŸ­æš«æ¼æª¢å¼•èµ·çš„æŠ–å‹•ã€‚

State and prediction: A constant-velocity Kalman filter with state vector (center coordinates, aspect ratio, height, and their velocities) extrapolates between detections to reduce jitter during brief misses.

é—œè¯åº¦é‡èˆ‡æŒ‡æ´¾ï¼šä»¥é¦¬æ°è·é›¢åšé–€æª»ï¼ˆåŸºæ–¼ç‹€æ…‹ä¸ç¢ºå®šåº¦çš„ gatingï¼‰éæ¿¾ä¸å¯è¡Œé…å°ï¼Œå†ä»¥åŒˆç‰™åˆ©æ¼”ç®—æ³•æ±‚è§£æœ€å°æˆæœ¬æŒ‡æ´¾ï¼›æˆæœ¬ç¶œåˆ IoU èˆ‡å¤–è§€åµŒå…¥çš„é¤˜å¼¦è·é›¢ï¼Œæ–¼é®æ“‹èˆ‡é‡ç–Šæ™‚ä»ä¿æŒ ID ä¸€è‡´æ€§ã€‚

Association and assignment: Mahalanobis gating filters infeasible matches per state uncertainty, followed by the Hungarian algorithm for minimum-cost assignment combining IoU and cosine distances of appearance embeddings to maintain identity through occlusions/overlaps.

è»Œè·¡ç”Ÿå‘½é€±æœŸï¼šæ–°ç”Ÿè»Œè·¡éœ€é€£çºŒå‘½ä¸­è‡³ min_hits æ–¹å¯ç¢ºèªï¼›é•·æ™‚é–“æœªåŒ¹é…å‰‡åœ¨ max_age ä¹‹å¾ŒéŠ·æ¯€ã€‚å°æ–¼å†å…¥å ´æ™¯ï¼Œè—‰ç”±å¤–è§€å‘é‡èˆ‡ç©ºé–“é„°è¿‘æ¢å¾©å…ˆå‰ IDï¼Œé™ä½ ID switchã€‚

Track lifecycle: Tracks are confirmed after min_hits consecutive matches; they are deleted after max_age misses. Re-entry is handled by combining appearance vectors and spatial proximity to recover prior IDs and reduce switches.

### 2.5 æ¨è«–æµç¨‹èˆ‡æ•ˆèƒ½æœ€ä½³åŒ– (Inference Workflow and Performance Optimization)

ç«¯åˆ°ç«¯æµç¨‹ï¼šæ”å½±æ©Ÿå–æµ â†’ OpenCV å‰è™•ç†/ç™½å¹³è¡¡/ROI æ¨™æº–åŒ– â†’ YOLO åµæ¸¬ï¼ˆå››æ¨¡å‹ä¹‹ä¸€æˆ–ä¾å ´æ™¯é¸æ“‡çµ„åˆï¼‰â†’ NMS/Soft-NMS â†’ DeepSORT é—œè¯ â†’ï¼ˆå¯é¸ï¼‰InsightFace èº«ä»½åŒ¹é…å¯«å›å€‹äººè¨˜éŒ„ â†’ çµæœå¯è¦–åŒ–/äº‹ä»¶è§¸ç™¼ï¼ˆå¦‚é ç´„å»ºè­°ï¼‰ã€‚

End-to-end pipeline: Camera capture â†’ OpenCV preprocessing/white balance/ROI normalization â†’ YOLO detection (one or a combo of four models) â†’ NMS/Soft-NMS â†’ DeepSORT association â†’ optional InsightFace identity logging â†’ visualization/event triggers (e.g., appointment suggestions).

ä½µè¡Œèˆ‡ä½å»¶é²ï¼šæ¡å¤šåŸ·è¡Œç·’åˆ†é›¢æ“·å–ã€å‰è™•ç†ã€æ¨è«–èˆ‡å¾Œè™•ç†ä¸¦ä»¥éšŠåˆ—è§£è€¦ï¼›åœ¨ GPU å•Ÿç”¨ FP16/AMP èˆ‡å±¤èåˆï¼›åœ¨ CPU æ¡ç”¨å‘é‡åŒ–ã€OpenMP/Threadingã€å¾®æ‰¹è™•ç†ï¼ˆbatch=1â€“2ï¼‰èˆ‡å¹€ç‡èª¿åº¦ï¼Œå…¼é¡§äº’å‹•æ€§èˆ‡ååã€‚

Parallelism and latency: Multithreaded capture, preprocessing, inference, and postprocessing with queue decoupling; FP16/AMP and layer fusion on GPUs; vectorization, OpenMP/threading, micro-batches (1â€“2), and frame scheduling on CPUs to balance interactivity and throughput.

æ¨¡å‹è¼¸å‡ºèˆ‡å¿«å–ï¼šé€²è¡Œé ç†±é™ä½é¦–å¹€å»¶é²ï¼›å°é‡è¤‡ç”¨æˆ¶å¿«å–è‡‰éƒ¨åµŒå…¥èˆ‡ Tracking ç‹€æ…‹ï¼›å°å›ºå®šå ´æ™¯å¿«å–èƒŒæ™¯çµ±è¨ˆï¼ˆäº®åº¦/ç™½å¹³è¡¡ï¼‰ä»¥åŠ é€Ÿç©©æ…‹ã€‚

Model outputs and caching: Warm-up reduces first-frame latency; cache face embeddings and tracking states for returning users; cache background statistics (luminance/white balance) in static scenes for faster steady-state operation.

å°å‡ºèˆ‡å¯æ”œï¼šè¦–éƒ¨ç½²éœ€æ±‚å°å‡º ONNXï¼›åœ¨é›²ç«¯/é‚Šç·£ç’°å¢ƒæä¾›å‹•æ…‹å½¢ç‹€æ”¯æ´èˆ‡å¼µé‡ç¶­åº¦å°é½Šï¼Œé¿å…è¨˜æ†¶é«”ç¢ç‰‡åŒ–ï¼›è¨˜éŒ„æ€§èƒ½æŒ‡æ¨™ï¼ˆå»¶é²/å¹€ç‡/å ç”¨ï¼‰ä»¥ä¾¿æŒçºŒå„ªåŒ–ã€‚

Export and portability: ONNX export when needed; dynamic shapes and tensor alignment in cloud/edge environments to avoid fragmentation; instrument latency/FPS/utilization for continuous optimization.

### 2.6 æ¶µè“‹æˆæœ¬ã€ç¯„åœã€æ™‚é–“ã€å“è³ªã€æºé€šã€é¢¨éšªèˆ‡è³‡æºçš„ IT å°ˆæ¡ˆç®¡ç†è¨ˆç•« (Project management plan)

æœ¬å°ˆæ¡ˆçš„ç¯„åœä»¥ã€Œå³æ™‚é¢éƒ¨å¥åº·æª¢æ¸¬ + å€‹äººåŒ–è­˜åˆ¥è¿½è¹¤ + é†«ç™‚é ç´„æ•´åˆã€ç‚ºæ ¸å¿ƒï¼Œäº¤ä»˜å¯æ–¼æ¨™æº–æ”åƒé ­ç’°å¢ƒé‹è¡Œçš„ Web æ‡‰ç”¨ã€‚æ™‚é–“ä¸Šä»¥å…­å€‹æœˆç‚ºç¬¬ä¸€éšæ®µç›®æ¨™ï¼šå®Œæˆæ¨¡å‹è¨“ç·´èˆ‡é©—è­‰ã€å‰å¾Œç«¯æ•´åˆã€åˆæ­¥é†«ç™‚åˆä½œèˆ‡ç”¨æˆ¶é©—è­‰ã€‚å“è³ªæŒ‡æ¨™ä»¥æ¨¡å‹æº–ç¢ºæ€§ã€ç³»çµ±éŸ¿æ‡‰æ™‚é–“ã€å¯ç”¨æ€§èˆ‡å®‰å…¨åˆè¦ç‚ºä¸»ï¼Œä¸¦ä»¥è‡ªå‹•åŒ–æ¸¬è©¦èˆ‡ä»£ç¢¼å¯©æŸ¥æŠŠé—œã€‚æˆæœ¬èˆ‡è³‡æºæ–¹é¢ï¼Œæ¡å°è€Œå°ˆç²¾çš„è·¨è·èƒ½åœ˜éšŠï¼Œé…åˆé›²ç«¯å½ˆæ€§è³‡æºï¼›ä»¥é–‹æºæŠ€è¡“é™ä½æˆæ¬Šæˆæœ¬ä¸¦ä¿ç•™å¯æ“´å±•æ€§ã€‚æºé€šæ©Ÿåˆ¶ä»¥æ¯æ—¥ç«™æœƒã€é›™é€±è¿­ä»£è©•å¯©èˆ‡æœˆåº¦åˆ©å®³é—œä¿‚äººå½™å ±ç‚ºä¸»ï¼Œç¢ºä¿éœ€æ±‚èˆ‡äº¤ä»˜åŒæ­¥ã€‚é¢¨éšªç®¡ç†èšç„¦æ–¼è³‡æ–™åå·®ã€æ¨¡å‹æ³›åŒ–ä¸è¶³ã€ç¬¬ä¸‰æ–¹æœå‹™ä¸ç©©èˆ‡åˆè¦æ€§æŒ‘æˆ°ï¼Œå°æ‡‰é å‚™æ•¸æ“šå¢è£œã€å‚™æ´æ¨¡å‹ã€æœå‹™é™ç´šèˆ‡æ³•å¾‹é¡§å•å”ä½œç­‰ç·©è§£ç­–ç•¥ã€‚

The project scope centers on real-time facial health detection, personalized identification/tracking, and medical appointment integration, delivered as a web app operating with standard cameras. The first six months target model training/validation, end-to-end integration, initial partnerships, and user validation. Quality metrics include model accuracy, response time, availability, and security/compliance, enforced via automated tests and code review. A small cross-functional team with elastic cloud resources manages cost and capacity, leveraging open source for extensibility. Communication relies on daily standups, biweekly reviews, and monthly stakeholder updates. Risk management focuses on data bias, model generalization, third-party instability, and regulatory hurdles, with mitigation including data augmentation, fallback models, service degradation, and legal counsel engagement.

### 2.7 å·¥ä½œåˆ†è§£çµæ§‹ (Work breakdown structure)

å·¥ä½œåˆ†è§£ä»¥æˆæœå°å‘æ‹†è§£è‡³å¯é©—è­‰çš„å­ä»»å‹™ï¼šåœ¨ AI åµæ¸¬ä¸Šï¼Œå¾è³‡æ–™æ”¶é›†ã€æ¨™è¨»ã€è¨“ç·´åˆ°éƒ¨ç½²æ ¼å¼è½‰æ›ï¼Œå½¢æˆå¯é‡è¤‡çš„è¨“ç·´èˆ‡è©•ä¼°æµç¨‹ï¼›åœ¨äººè‡‰è­˜åˆ¥èˆ‡è¿½è¹¤ä¸Šï¼Œå®Œæˆç‰¹å¾µåµŒå…¥ã€ç›¸ä¼¼åº¦é–¾å€¼æ¨™å®šèˆ‡å¤šç”¨æˆ¶å ´æ™¯æ¸¬è©¦ï¼›åœ¨ Web èˆ‡è³‡æ–™å¹³å°ä¸Šï¼Œå»ºç«‹èªè­‰ã€æ•¸æ“šæ¨¡å‹ã€API èˆ‡å‰ç«¯å±•ç¤ºï¼ŒåŒæ­¥åŠ å…¥æ”åƒé ­ä¸²æµèˆ‡çµæœå¯è¦–åŒ–ï¼›æ–¼é†«ç™‚é ç´„æ•´åˆä¸Šï¼Œå®Œæˆåˆä½œé†«ç™‚æ©Ÿæ§‹è³‡è¨Šå»ºæ¨¡ã€æ¨è–¦é‚è¼¯èˆ‡é ç´„æµç¨‹æ‰“é€šï¼›æ¸¬è©¦èˆ‡å“è³ªä¿è­‰è¦†è“‹å–®å…ƒã€æ•´åˆã€æ€§èƒ½èˆ‡å®‰å…¨ï¼›æœ€çµ‚ä»¥éƒ¨ç½²èˆ‡ç›£æ§ç¢ºä¿ä¸Šç·šå“è³ªèˆ‡æŒçºŒå¯ç”¨ã€‚æ­¤ç¨®åˆ†è§£ä½¿æ¯ä¸€å±¤ç´šçš†å°æ‡‰æ˜ç¢ºå¯äº¤ä»˜æˆæœèˆ‡é©—æ”¶æº–å‰‡ã€‚

The work is decomposed into verifiable sub-deliverables: for AI detection, a repeatable loop from data collection/labeling to training and deployable formats; for identity/tracking, embedding calibration, similarity thresholds, and multi-user testing; for web and data, authentication, data models, APIs, and UI with camera streaming and result visualization; for appointment integration, provider data modeling, recommendation logic, and booking flow; testing spans unit, integration, performance, and security; deployment and monitoring ensure launch quality and availability. Each level maps to concrete deliverables and acceptance criteria.

### 2.8 é‡Œç¨‹ç¢‘æ’ç¨‹ (Milestone schedules)

é‡Œç¨‹ç¢‘è¦åŠƒéµå¾ªã€Œå…ˆå…§æ ¸ã€å¾Œæ•´åˆã€å†æ“´å±•ã€çš„ç¯€å¥ï¼šç¬¬ä¸€éšæ®µå®Œæˆå››æ¨¡å‹ï¼ˆé»‘çœ¼åœˆã€å”‡éƒ¨ã€çš®è†šã€ç¶œåˆï¼‰çš„è¨“ç·´èˆ‡é”æ¨™é©—è­‰ï¼Œä¸¦å»ºç«‹ç©©å®šçš„äººè‡‰è­˜åˆ¥èˆ‡è¿½è¹¤èƒ½åŠ›ï¼›ç¬¬äºŒéšæ®µå®ŒæˆåŠŸèƒ½å®Œæ•´çš„ MVPï¼Œæ‰“é€šæ”åƒé ­ä¸²æµã€å‰å¾Œç«¯æœå‹™èˆ‡åˆæ­¥é ç´„æµç¨‹ï¼Œä¸¦é€šéå…§éƒ¨æ¸¬è©¦ï¼›ç¬¬ä¸‰éšæ®µèšç„¦é†«ç™‚ç³»çµ±æ•´åˆèˆ‡è³‡æ–™å®‰å…¨æ²»ç†ï¼Œå®Œæˆç«¯åˆ°ç«¯å¯é æ€§é©—è­‰èˆ‡è² è¼‰æ¸¬è©¦ï¼›æœ€çµ‚å®Œæˆç”Ÿç”¢ç’°å¢ƒéƒ¨ç½²ã€ç”¨æˆ¶é©—è­‰èˆ‡ç›£æ§ä½ˆç½²ï¼Œä»¥å¯è§€æ¸¬æ€§èˆ‡å›é¥‹å¾ªç’°æŒçºŒå„ªåŒ–ã€‚å„éšæ®µå‡è¨­å®šé‡åŒ–æˆåŠŸæº–å‰‡ï¼Œç¢ºä¿é€²åº¦ã€å“è³ªèˆ‡å•†æ¥­åŒ–ç¯€é»å¯è¢«æœ‰æ•ˆç›£æ§èˆ‡è¿­ä»£ä¿®æ­£ã€‚

Milestones follow a core-first, integration-second, expansion-third cadence: Phase 1 delivers four validated core models and stable identity/tracking; Phase 2 ships a functional MVP with live camera, end-to-end flows, and internal testing; Phase 3 completes medical integration and data security governance with end-to-end reliability and load testing; the final phase deploys to production with user validation and monitoring, enabling continuous optimization via observability and feedback.

---

## ç¬¬ä¸‰ç«  ç³»çµ±æ¶æ§‹èˆ‡æŠ€è¡“å·¥å…· (Chapter III: System Architecture and Technical Tools)

æœ¬ç« è©³ç´°ä»‹ç´¹ Health Mirror ç³»çµ±æ‰€æ¡ç”¨çš„æ ¸å¿ƒæŠ€è¡“å·¥å…·èˆ‡é–‹ç™¼ç’°å¢ƒï¼ŒåŒ…æ‹¬ Anaconda ç§‘å­¸è¨ˆç®—å¹³å°ã€Jupyter Notebook äº’å‹•å¼é–‹ç™¼ç’°å¢ƒã€Python æ©Ÿå™¨å­¸ç¿’ç”Ÿæ…‹ç³»çµ±ã€Django ç¶²é æ¡†æ¶ï¼Œä»¥åŠå„æ¼”ç®—æ³•çš„æ­·å²ç™¼å±•è„ˆçµ¡èˆ‡æ•¸å­¸åŸç†ã€‚é€™äº›æŠ€è¡“é¸æ“‡ä¸åƒ…æ”¯æ’äº†ç³»çµ±çš„æ ¸å¿ƒåŠŸèƒ½å¯¦ç¾ï¼Œæ›´ç‚ºå¾ŒçºŒçš„æ“´å±•èˆ‡ç¶­è­·å¥ å®šäº†å …å¯¦çš„æŠ€è¡“åŸºç¤ã€‚

This chapter provides a detailed introduction to the core technical tools and development environments adopted by the Health Mirror system, including the Anaconda scientific computing platform, Jupyter Notebook interactive development environment, Python machine learning ecosystem, Django web framework, and the historical development context and mathematical principles of various algorithms. These technical choices not only support the core functionality implementation of the system but also establish a solid technical foundation for future expansion and maintenance.

### 3.1 Anaconda ç§‘å­¸è¨ˆç®—å¹³å° (Anaconda Scientific Computing Platform)

Anaconda ä½œç‚º Health Mirror å°ˆæ¡ˆçš„æ ¸å¿ƒé–‹ç™¼ç’°å¢ƒï¼Œæä¾›äº†å®Œæ•´çš„ Python ç§‘å­¸è¨ˆç®—ç”Ÿæ…‹ç³»çµ±ã€‚Anaconda ç”± Continuum Analyticsï¼ˆç¾ç‚º Anaconda Inc.ï¼‰æ–¼ 2012 å¹´é¦–æ¬¡ç™¼å¸ƒï¼Œæ—¨åœ¨simplifying Python and R languages in data science domain. The platform integrates over 1,500 open-source packages, including core scientific computing libraries such as NumPy, SciPy, Pandas, Matplotlib, and Scikit-learn, providing a one-stop solution for machine learning and deep learning projects.

Anaconda serves as the core development environment for the Health Mirror project, providing a complete Python scientific computing ecosystem. Anaconda was first released by Continuum Analytics (now Anaconda Inc.) in 2012, aimed at simplifying package management and environment configuration for Python and R languages in the data science field. The platform integrates over 1,500 open-source packages, including core scientific computing libraries such as NumPy, SciPy, Pandas, Matplotlib, and Scikit-learn, providing a one-stop solution for machine learning and deep learning projects.

åœ¨ Health Mirror å°ˆæ¡ˆä¸­ï¼ŒAnaconda çš„ conda åŒ…ç®¡ç†å™¨ç¢ºä¿äº†ä¸åŒé–‹ç™¼ç’°å¢ƒé–“çš„ä¸€è‡´æ€§èˆ‡å¯é‡ç¾æ€§ã€‚é€éå»ºç«‹å°ˆç”¨çš„è™›æ“¬ç’°å¢ƒï¼Œæˆ‘å€‘èƒ½å¤ ç²¾ç¢ºæ§åˆ¶æ¯å€‹ä¾è³´å¥—ä»¶çš„ç‰ˆæœ¬ï¼Œé¿å…ç‰ˆæœ¬è¡çªä¸¦ä¿è­‰æ¨¡å‹è¨“ç·´çµæœçš„ç©©å®šæ€§ã€‚ç‰¹åˆ¥æ˜¯åœ¨è™•ç† PyTorchã€OpenCVã€InsightFace ç­‰æ·±åº¦å­¸ç¿’æ¡†æ¶æ™‚ï¼Œconda çš„äºŒé€²åˆ¶åŒ…åˆ†ç™¼æ©Ÿåˆ¶å¤§å¹…ç°¡åŒ–äº†è¤‡é›œä¾è³´é—œä¿‚çš„è§£æ±ºéç¨‹ï¼Œæå‡äº†é–‹ç™¼æ•ˆç‡ã€‚

In the Health Mirror project, Anaconda's conda package manager ensures consistency and reproducibility across different development environments. By creating dedicated virtual environments, we can precisely control the version of each dependency package, avoiding version conflicts and ensuring the stability of model training results. Particularly when dealing with deep learning frameworks such as PyTorch, OpenCV, and InsightFace, conda's binary package distribution mechanism significantly simplifies the resolution of complex dependency relationships and improves development efficiency.

### 3.2 Jupyter Notebook äº’å‹•å¼é–‹ç™¼ç’°å¢ƒ (Jupyter Notebook Interactive Development Environment)

Jupyter Notebook åœ¨ Health Mirror å°ˆæ¡ˆä¸­æ‰®æ¼”è‘—é—œéµçš„åŸå‹é–‹ç™¼èˆ‡å¯¦é©—é©—è­‰è§’è‰²ã€‚Jupyter å°ˆæ¡ˆèµ·æºæ–¼ 2014 å¹´çš„ IPython Notebookï¼Œç”± Fernando PÃ©rez ç­‰äººç™¼èµ·ï¼Œæ—¨åœ¨å‰µå»ºä¸€å€‹èªè¨€ç„¡é—œçš„äº’å‹•å¼è¨ˆç®—ç’°å¢ƒã€‚å…¶åç¨±ä¾†è‡ªæ–¼ Juliaã€Python å’Œ R ä¸‰ç¨®ç¨‹å¼èªè¨€çš„çµ„åˆï¼Œé«”ç¾äº†è·¨èªè¨€æ”¯æ´çš„è¨­è¨ˆç†å¿µã€‚

Jupyter Notebook plays a crucial role in prototype development and experimental validation in the Health Mirror project. The Jupyter project originated from IPython Notebook in 2014, initiated by Fernando PÃ©rez and others, aiming to create a language-agnostic interactive computing environment. Its name comes from the combination of Julia, Python, and R programming languages, reflecting the design philosophy of cross-language support.

åœ¨æ¨¡å‹é–‹ç™¼éšæ®µï¼ŒJupyter Notebook çš„ç´°èƒï¼ˆCellï¼‰åŸ·è¡Œæ©Ÿåˆ¶å…è¨±é–‹ç™¼è€…é€æ­¥é©—è­‰æ¼”ç®—æ³•é‚è¼¯ï¼Œå³æ™‚è§€å¯Ÿä¸­é–“çµæœèˆ‡è¦–è¦ºåŒ–è¼¸å‡ºã€‚é€™ç¨®äº’å‹•å¼çš„é–‹ç™¼æ¨¡å¼ç‰¹åˆ¥é©åˆæ·±åº¦å­¸ç¿’æ¨¡å‹çš„èª¿è©¦èˆ‡å„ªåŒ–ï¼Œé–‹ç™¼è€…å¯ä»¥å¿«é€Ÿè¿­ä»£è¶…åƒæ•¸é…ç½®ã€è§€å¯Ÿè¨“ç·´æ›²ç·šè®ŠåŒ–ï¼Œä¸¦é€éè±å¯Œçš„è¦–è¦ºåŒ–å·¥å…·ï¼ˆå¦‚ Matplotlibã€Seabornã€Plotlyï¼‰ç›´è§€åœ°åˆ†ææ¨¡å‹æ€§èƒ½ã€‚å°æ–¼ YOLO ç›®æ¨™æª¢æ¸¬æ¨¡å‹çš„è¨“ç·´éç¨‹ï¼Œæˆ‘å€‘åˆ©ç”¨ Jupyter Notebook å»ºç«‹äº†å®Œæ•´çš„å¯¦é©—è¨˜éŒ„ç³»çµ±ï¼ŒåŒ…æ‹¬æå¤±å‡½æ•¸è®ŠåŒ–ã€ç²¾ç¢ºåº¦-å¬å›ç‡æ›²ç·šã€æ··æ·†çŸ©é™£åˆ†æç­‰é—œéµæŒ‡æ¨™çš„å³æ™‚ç›£æ§ã€‚

During the model development phase, Jupyter Notebook's cell execution mechanism allows developers to gradually verify algorithm logic and observe intermediate results and visualization outputs in real-time. This interactive development mode is particularly suitable for debugging and optimizing deep learning models, enabling developers to quickly iterate hyperparameter configurations, observe training curve changes, and intuitively analyze model performance through rich visualization tools (such as Matplotlib, Seaborn, Plotly). For the training process of YOLO object detection models, we utilized Jupyter Notebook to establish a complete experimental recording system, including real-time monitoring of key metrics such as loss function changes, precision-recall curves, and confusion matrix analysis.

### 3.3 Python æ©Ÿå™¨å­¸ç¿’ç”Ÿæ…‹ç³»çµ± (Python Machine Learning Ecosystem)

Python ä½œç‚º Health Mirror å°ˆæ¡ˆçš„ä¸»è¦é–‹ç™¼èªè¨€ï¼Œå…¶è±å¯Œçš„æ©Ÿå™¨å­¸ç¿’ç”Ÿæ…‹ç³»çµ±ç‚ºç³»çµ±å¯¦ç¾æä¾›äº†å¼·å¤§æ”¯æ’ã€‚Python åœ¨æ©Ÿå™¨å­¸ç¿’é ˜åŸŸçš„å´›èµ·å¯è¿½æº¯è‡³ 1990 å¹´ä»£æœ«æœŸï¼Œéš¨è‘— NumPyï¼ˆ1995 å¹´çš„ Numeric å‰èº«ï¼‰ã€SciPyï¼ˆ2001ï¼‰ã€Matplotlibï¼ˆ2003ï¼‰ç­‰åŸºç¤ç§‘å­¸è¨ˆç®—åº«çš„ç™¼å±•ï¼ŒPython é€æ¼¸æˆç‚ºæ•¸æ“šç§‘å­¸èˆ‡æ©Ÿå™¨å­¸ç¿’çš„é¦–é¸èªè¨€ã€‚

Python serves as the primary development language for the Health Mirror project, and its rich machine learning ecosystem provides strong support for system implementation. Python's rise in the machine learning field can be traced back to the late 1990s. With the development of fundamental scientific computing libraries such as NumPy (predecessor Numeric in 1995), SciPy (2001), and Matplotlib (2003), Python gradually becomes the preferred language for data science and machine learning.

åœ¨æ·±åº¦å­¸ç¿’æ¡†æ¶æ–¹é¢ï¼Œæˆ‘å€‘ä¸»è¦æ¡ç”¨ PyTorch ä½œç‚ºæ¨¡å‹è¨“ç·´èˆ‡æ¨è«–çš„æ ¸å¿ƒå¼•æ“ã€‚PyTorch ç”± Facebook AI Research åœ˜éšŠæ–¼ 2016 å¹´é–‹æºï¼Œå…¶å‹•æ…‹è¨ˆç®—åœ–ï¼ˆDynamic Computational Graphï¼‰è¨­è¨ˆç†å¿µç‚ºæ¨¡å‹é–‹ç™¼å¸¶ä¾†äº†å‰æ‰€æœªæœ‰çš„éˆæ´»æ€§ã€‚ç›¸è¼ƒæ–¼éœæ…‹åœ–æ¡†æ¶ï¼ŒPyTorch çš„å³æ™‚åŸ·è¡Œæ¨¡å¼ï¼ˆEager Executionï¼‰ä½¿å¾—æ¨¡å‹èª¿è©¦æ›´åŠ ç›´è§€ï¼Œç‰¹åˆ¥é©åˆç ”ç©¶å‹å°ˆæ¡ˆçš„å¿«é€ŸåŸå‹é–‹ç™¼ã€‚åœ¨ Health Mirror å°ˆæ¡ˆä¸­ï¼Œæˆ‘å€‘åˆ©ç”¨ PyTorch çš„è‡ªå‹•å¾®åˆ†æ©Ÿåˆ¶ï¼ˆAutogradï¼‰å¯¦ç¾äº†è¤‡é›œçš„å¤šä»»å‹™å­¸ç¿’æ¶æ§‹ï¼ŒåŒæ™‚é€é TorchVision é è¨“ç·´æ¨¡å‹åŠ é€Ÿäº† YOLO æª¢æ¸¬å™¨çš„æ”¶æ–‚éç¨‹ã€‚

In terms of deep learning frameworks, we primarily adopt PyTorch as the core engine for model training and inference. PyTorch was open-sourced by the Facebook AI Research team in 2016, and its Dynamic Computational Graph design philosophy brought unprecedented flexibility to model development. Compared to static graph frameworks, PyTorch's Eager Execution mode makes model debugging more intuitive, particularly suitable for rapid prototype development in research projects. In the Health Mirror project, we utilized PyTorch's automatic differentiation mechanism (Autograd) to implement complex multi-task learning architectures, while accelerating the convergence process of YOLO detectors through TorchVision pre-trained models.

### 3.4 Django ç¶²é æ¡†æ¶æ¶æ§‹ (Django Web Framework Architecture)

Django ä½œç‚º Health Mirror ç³»çµ±çš„å¾Œç«¯æ ¸å¿ƒï¼Œæä¾›äº†å¾ç”¨æˆ¶èªè­‰ã€æ•¸æ“šç®¡ç†åˆ° API æœå‹™çš„å®Œæ•´è§£æ±ºæ–¹æ¡ˆã€‚Django ç”± Adrian Holovaty å’Œ Simon Willison æ–¼ 2003 å¹´åœ¨ Lawrence Journal-World å ±ç¤¾é–‹ç™¼ï¼Œä¸¦æ–¼ 2005 å¹´é–‹æºç™¼å¸ƒã€‚å…¶è¨­è¨ˆå“²å­¸ã€ŒDon't Repeat Yourself (DRY)ã€èˆ‡ã€ŒConvention over Configurationã€ç‚ºå¿«é€Ÿé–‹ç™¼é«˜å“è³ªç¶²é æ‡‰ç”¨å¥ å®šäº†åŸºç¤ã€‚

Django serves as the backend core of the Health Mirror system, providing a complete solution from user authentication and data management to API services. Django was developed by Adrian Holovaty and Simon Willison in 2003 at the Lawrence Journal-World newspaper and was open-sourced in 2005. Its design philosophy of "Don't Repeat Yourself (DRY)" and "Convention over Configuration" laid the foundation for rapid development of high-quality web applications.

Django çš„ Model-View-Template (MVT) æ¶æ§‹æ¨¡å¼åœ¨ Health Mirror å°ˆæ¡ˆä¸­ç™¼æ®äº†é—œéµä½œç”¨ã€‚Model å±¤é€é Object-Relational Mapping (ORM) æŠ€è¡“æŠ½è±¡åŒ–äº†æ•¸æ“šåº«æ“ä½œï¼Œæˆ‘å€‘å®šç¾©äº† Userã€HealthRecordã€DetectionResultã€Appointment ç­‰æ ¸å¿ƒæ•¸æ“šæ¨¡å‹ï¼Œä¸¦é€é Django çš„é·ç§»ç³»çµ±ï¼ˆMigrationï¼‰ç¢ºä¿æ•¸æ“šåº«çµæ§‹çš„ç‰ˆæœ¬æ§åˆ¶èˆ‡ä¸€è‡´æ€§ã€‚View å±¤è² è²¬æ¥­å‹™é‚è¼¯è™•ç†ï¼ŒåŒ…æ‹¬ AI æ¨¡å‹æ¨è«–çµæœçš„è™•ç†ã€ç”¨æˆ¶å¥åº·æ•¸æ“šçš„åˆ†æèˆ‡é†«ç™‚é ç´„çš„æ™ºèƒ½æ¨è–¦ã€‚Template å±¤å‰‡æä¾›äº†éˆæ´»çš„å‰ç«¯æ¸²æŸ“æ©Ÿåˆ¶ï¼Œæ”¯æ´éŸ¿æ‡‰å¼è¨­è¨ˆèˆ‡å¤šè¨­å‚™é©é…ã€‚

Django's Model-View-Template (MVT) architectural pattern plays a key role in the Health Mirror project. The Model layer abstracts database operations through Object-Relational Mapping (ORM) technology. We defined core data models such as User, HealthRecord, DetectionResult, and Appointment, and ensured version control and consistency of database structure through Django's Migration system. The View layer handles business logic processing, including processing of AI model inference results, analysis of user health data, and intelligent recommendations for medical appointments. The Template layer provides a flexible frontend rendering mechanism, supporting responsive design and multi-device adaptation.

### 3.5 æ¼”ç®—æ³•æ­·å²ç™¼å±•èˆ‡æ•¸å­¸åŸç† (Algorithm Historical Development and Mathematical Principles)

#### 3.5.1 YOLO æ¼”ç®—æ³•ç™¼å±•å²èˆ‡æ ¸å¿ƒå…¬å¼ (YOLO Algorithm History and Core Formulas)

YOLOï¼ˆYou Only Look Onceï¼‰æ¼”ç®—æ³•ç”± Joseph Redmon ç­‰äººæ–¼ 2015 å¹´åœ¨è¯ç››é “å¤§å­¸æå‡ºï¼Œé©å‘½æ€§åœ°å°‡ç›®æ¨™æª¢æ¸¬å•é¡Œé‡æ–°å®šç¾©ç‚ºå–®ä¸€ç¥ç¶“ç¶²è·¯çš„å›æ­¸å•é¡Œã€‚ç›¸è¼ƒæ–¼å‚³çµ±çš„å…©éšæ®µæª¢æ¸¬æ–¹æ³•ï¼ˆå¦‚ R-CNN ç³»åˆ—ï¼‰ï¼ŒYOLO çš„ä¸€éšæ®µè¨­è¨ˆå¤§å¹…æå‡äº†æª¢æ¸¬é€Ÿåº¦ï¼Œä½¿å¯¦æ™‚ç›®æ¨™æª¢æ¸¬æˆç‚ºå¯èƒ½ã€‚åœ¨ Health Mirror ç³»çµ±ä¸­ï¼Œæˆ‘å€‘æ¡ç”¨ YOLOv8 ä½œç‚ºä¸»è¦æª¢æ¸¬å¼•æ“ï¼Œé‡å°å¥åº·ç›£æ¸¬å ´æ™¯é–‹ç™¼äº†å››å€‹å°ˆç”¨æ¨¡å‹ï¼šDarkCircles.ptï¼ˆé»‘çœ¼åœˆæª¢æ¸¬ï¼‰ã€Lip_types.ptï¼ˆå”‡éƒ¨ç‹€æ³ç›£æ¸¬ï¼‰ã€skin.ptï¼ˆçš®è†šå•é¡Œåˆ†æï¼‰å’Œ health.ptï¼ˆç¶œåˆå¥åº·æŒ‡æ¨™ï¼‰ã€‚

The YOLO (You Only Look Once) algorithm was proposed by Joseph Redmon and others at the University of Washington in 2015, revolutionarily redefining the object detection problem as a single neural network regression problem. Compared to traditional two-stage detection methods (such as the R-CNN series), YOLO's one-stage design significantly improved detection speed, making real-time object detection possible. In the Health Mirror system, we utilize YOLOv8 as the primary detection engine with four specialized models: DarkCircles.pt (dark circle detection), Lip_types.pt (lip condition monitoring), skin.pt (skin problem analysis), and health.pt (comprehensive health indicators).

YOLOv8 æ¡ç”¨æ”¹è‰¯çš„ CSPDarknet è¼•é‡åŒ–éª¨å¹¹ç¶²è·¯ï¼ˆCross-Stage Partial Networkï¼‰ï¼Œé€šéè·¨éšæ®µçš„ç‰¹å¾µåˆ†å‰²èˆ‡åˆä½µï¼Œæœ‰æ•ˆæ¸›å°‘å†—é¤˜è¨ˆç®—åŒæ™‚ä¿æŒå®Œæ•´çš„æ„Ÿå—é‡å’Œæ¢¯åº¦æµå‹•ã€‚é ¸éƒ¨æ¶æ§‹çµåˆç‰¹å¾µé‡‘å­—å¡”ç¶²è·¯ï¼ˆFPNï¼‰å’Œè·¯å¾‘èšåˆç¶²è·¯ï¼ˆPANï¼‰ï¼Œå¯¦ç¾é›™å‘å¤šå°ºåº¦ç‰¹å¾µèåˆã€‚æª¢æ¸¬é ­æ¡ç”¨æ··åˆé æ¸¬æ¶æ§‹ï¼Œæ”¯æ´åŸºæ–¼éŒ¨é»å’Œç„¡éŒ¨é»çš„é æ¸¬æ–¹å¼ï¼Œä¸¦å¼•å…¥å‹•æ…‹ç‰¹å¾µåˆ†é…ç­–ç•¥ä»¥é©æ‡‰ä¸åŒå ´æ™¯éœ€æ±‚ã€‚

YOLOv8 utilizes a modified CSPDarknet lightweight backbone network (Cross-Stage Partial Network), effectively reducing redundant computation while preserving full receptive field and gradient flow through cross-stage feature splitting and merging. The neck architecture combines Feature Pyramid Network (FPN) and Path Aggregation Network (PAN) for bidirectional multi-scale feature fusion. The detection head adopts a hybrid prediction architecture supporting both anchor-based and anchor-free predictions, with dynamic feature allocation strategy for different scenarios.

YOLO çš„æ ¸å¿ƒæ€æƒ³æ˜¯å°‡è¼¸å…¥åœ–åƒåŠƒåˆ†ç‚º SÃ—S çš„ç¶²æ ¼ï¼Œæ¯å€‹ç¶²æ ¼è² è²¬é æ¸¬ B å€‹é‚Šç•Œæ¡†åŠå…¶ç½®ä¿¡åº¦åˆ†æ•¸ã€‚å°æ–¼æ¯å€‹é‚Šç•Œæ¡†ï¼Œç¶²è·¯é æ¸¬äº”å€‹å€¼ï¼šä¸­å¿ƒåº§æ¨™ (x, y)ã€å¯¬é«˜ (w, h) å’Œç½®ä¿¡åº¦ Cã€‚ç½®ä¿¡åº¦å®šç¾©ç‚ºï¼š

The core idea of YOLO is to divide the input image into an SÃ—S grid, with each grid cell responsible for predicting B bounding boxes and their confidence scores. For each bounding box, the network predicts five values: center coordinates (x, y), width and height (w, h), and confidence C. Confidence is defined as:

```
C = Pr(Object) Ã— IoU(pred, truth)
```

å…¶ä¸­ Pr(Object) è¡¨ç¤ºç¶²æ ¼åŒ…å«ç›®æ¨™çš„æ©Ÿç‡ï¼ŒIoU ç‚ºé æ¸¬æ¡†èˆ‡çœŸå¯¦æ¡†çš„äº¤é›†æ¯”è¯é›†ã€‚

Where Pr(Object) represents the probability that the grid contains an object, and IoU is the intersection over union of the predicted box and ground truth box.

æå¤±å‡½æ•¸çµåˆäº†å®šä½æå¤±ã€ç½®ä¿¡åº¦æå¤±å’Œåˆ†é¡æå¤±ï¼š

The loss function combines localization loss, confidence loss, and classification loss:

```
Loss = Î»coord âˆ‘âˆ‘ ğŸ™áµ¢â±¼áµ’áµ‡Ê² [(xi - xÌ‚i)Â² + (yi - Å·i)Â²]
     + Î»coord âˆ‘âˆ‘ ğŸ™áµ¢â±¼áµ’áµ‡Ê² [(âˆšwi - âˆšÅµi)Â² + (âˆšhi - âˆšÄ¥i)Â²]
     + âˆ‘âˆ‘ ğŸ™áµ¢â±¼áµ’áµ‡Ê² (Ci - Äˆi)Â²
     + Î»noobj âˆ‘âˆ‘ ğŸ™áµ¢â±¼â¿áµ’áµ’áµ‡Ê² (Ci - Äˆi)Â²
     + âˆ‘ ğŸ™áµ¢áµ’áµ‡Ê² âˆ‘ (pi(c) - pÌ‚i(c))Â²
```

ç‚ºæå‡é‹ç®—æ•ˆç‡ä¸¦æ¸›å°‘æ¨¡å‹å¤§å°ï¼Œæˆ‘å€‘å¼•å…¥è¨“ç·´å¾Œæ¨¡å‹å£“ç¸®ç­–ç•¥ï¼ŒåŒ…æ‹¬å‰ªæï¼ˆç§»é™¤ä½æ¬Šé‡é€šé“ï¼‰å’ŒçŸ¥è­˜è’¸é¤¾ï¼ˆä½¿ç”¨å®Œæ•´ YOLOv8 ä½œç‚ºæ•™å¸«æ¨¡å‹ï¼‰ã€‚æ•¸æ“šå¢å¼·çµåˆ Mosaicã€MixUpã€éš¨æ©Ÿä»¿å°„è®Šæ›ã€é€è¦–è®Šæ›ã€HSV æŠ–å‹•ç­‰æŠ€è¡“ï¼Œè©•ä¼°æ¡ç”¨ mAP@0.70:0.95 ä½œç‚ºæ ¸å¿ƒæŒ‡æ¨™ã€‚

To improve operational efficiency and reduce model size, we introduce post-training model compression strategies including pruning (removing low-weight channels) and knowledge distillation (using full YOLOv8 as teacher model). Data augmentation combines Mosaic, MixUp, random affine transformation, perspective transformation, and HSV jittering, with evaluation using mAP@0.70:0.95 as the core metric.

#### 3.5.2 OpenCV å½±åƒè™•ç†æ¼”ç®—æ³•åŸç† (OpenCV Image Processing Algorithm Principles)

OpenCVï¼ˆOpen Source Computer Vision Libraryï¼‰ç”± Intel æ–¼ 1999 å¹´ç™¼èµ·ï¼ŒGary Bradski é ˜å°é–‹ç™¼ï¼Œæ˜¯ç›®å‰æœ€å»£æ³›ä½¿ç”¨çš„é–‹æºè¨ˆç®—æ©Ÿè¦–è¦ºåº«ã€‚åœ¨ Health Mirror ç³»çµ±ä¸­ï¼ŒOpenCV è² è²¬å½±åƒå‰è™•ç†æ¨¡çµ„ï¼Œæä¾›éˆæ´»ä¸”é«˜æ•ˆèƒ½çš„å·¥ä½œæµç¨‹ã€‚

OpenCV (Open Source Computer Vision Library) was initiated by Intel in 1999 under the leadership of Gary Bradski, and is currently the most widely used open-source computer vision library. In the Health Mirror system, OpenCV handles the image preprocessing module, providing a flexible and high-performance workflow.

å»å™ªèˆ‡å¹³æ»‘è™•ç†æ¡ç”¨å¤šç¨®æ¿¾æ³¢æŠ€è¡“ï¼šé«˜æ–¯æ¿¾æ³¢å™¨ä½¿ç”¨äºŒç¶­é«˜æ–¯æ ¸é€²è¡Œå·ç©ï¼Œæ•¸å­¸è¡¨é”å¼ç‚ºï¼š

Denoising and smoothing employ various filtering techniques. Gaussian filtering uses 2D Gaussian kernel convolution with the mathematical expression:

```
G(x,y) = (1/(2Ï€ÏƒÂ²)) * e^(-(xÂ²+yÂ²)/(2ÏƒÂ²))
```

é›™é‚Šæ¿¾æ³¢å™¨åœ¨ä¿æŒé‚Šç·£çš„åŒæ™‚é€²è¡Œå¹³æ»‘ï¼Œå…¶æ¬Šé‡å‡½æ•¸çµåˆç©ºé–“è·é›¢å’Œåƒç´ å€¼å·®ç•°ï¼š

Bilateral filtering performs smoothing while preserving edges, with weight function combining spatial distance and pixel value differences:

```
w(i,j,k,l) = exp(-(i-k)Â²+(j-l)Â²)/(2ÏƒdÂ²)) * exp(-||I(i,j)-I(k,l)||Â²/(2ÏƒrÂ²))
```

è‰²å½©æ ¡æ­£æ¡ç”¨ç°ä¸–ç•Œå‡è¨­å’Œ Shades-of-Gray ç™½å¹³è¡¡ä¼°è¨ˆã€‚ç°ä¸–ç•Œå‡è¨­èªç‚ºåœ–åƒçš„å¹³å‡åå°„ç‡ç‚ºç°è‰²ï¼Œæ ¡æ­£å…¬å¼ç‚ºï¼š

Color correction uses Gray World assumption and Shades-of-Gray white balance estimation. The Gray World assumption considers the average reflectance of an image to be gray, with correction formula:

```
R' = R * (Gavg/Ravg), G' = G * (Gavg/Gavg), B' = B * (Gavg/Bavg)
```

Canny é‚Šç·£æª¢æ¸¬æ¡ç”¨å¤šéšæ®µæ¼”ç®—æ³•ï¼šé¦–å…ˆä½¿ç”¨é«˜æ–¯æ¿¾æ³¢å»å™ªï¼Œç„¶å¾Œè¨ˆç®—æ¢¯åº¦å¹…å€¼å’Œæ–¹å‘ï¼Œé€²è¡Œéæ¥µå¤§å€¼æŠ‘åˆ¶ï¼Œæœ€å¾Œä½¿ç”¨é›™é–¾å€¼æª¢æ¸¬å’Œé‚Šç·£é€£æ¥ã€‚æ¢¯åº¦è¨ˆç®—ä½¿ç”¨ Sobel é‹ç®—å­ï¼š

Canny edge detection uses a multi-stage algorithm: Gaussian filtering for denoising, gradient magnitude and direction calculation, non-maximum suppression, and finally double threshold detection with edge linking. Gradient calculation uses Sobel operators:

```
Gx = [-1 0 1; -2 0 2; -1 0 1], Gy = [-1 -2 -1; 0 0 0; 1 2 1]
```

#### 3.5.3 InsightFace èˆ‡ ArcFace æå¤±å‡½æ•¸ (InsightFace and ArcFace Loss Function)

InsightFace æ¡†æ¶ç”± Jiankang Deng ç­‰äººé–‹ç™¼ï¼Œæ˜¯ç›®å‰æœ€å…ˆé€²çš„äººè‡‰è­˜åˆ¥é–‹æºæ¡†æ¶ä¹‹ä¸€ã€‚è©²æ¡†æ¶æ¡ç”¨çš„ ArcFace æå¤±å‡½æ•¸æ–¼ 2018 å¹´æå‡ºï¼Œé€šéåœ¨è§’åº¦ç©ºé–“å¼•å…¥åŠ æ€§é‚Šç•Œä¾†å¢å¼·äººè‡‰ç‰¹å¾µçš„åˆ¤åˆ¥æ€§ã€‚åœ¨ Health Mirror ç³»çµ±ä¸­ï¼Œæˆ‘å€‘ä½¿ç”¨ InsightFace é€²è¡Œåš´æ ¼çš„å“è³ªæ§åˆ¶å’Œèº«ä»½é©—è­‰ã€‚

The InsightFace framework, developed by Jiankang Deng and others, is one of the most advanced open-source face recognition frameworks. The ArcFace loss function adopted by this framework was proposed in 2018, enhancing the discriminability of facial features by introducing additive margins in the angular space. In the Health Mirror system, we use InsightFace for rigorous quality control and identity verification.

ç³»çµ±é¦–å…ˆæª¢æ¸¬é¢éƒ¨é—œéµé»ï¼ˆé›™çœ¼ã€é¼»å°–ã€å˜´è§’ï¼‰ï¼ŒåŸ·è¡Œé«˜ç²¾åº¦ä»¿å°„è®Šæ›ä»¥æ¨™æº–åŒ–è¼¸å…¥åœ–åƒçš„å°ºåº¦ã€ä½ç½®å’Œå§¿æ…‹ã€‚å“è³ªæª¢æŸ¥åŒ…æ‹¬ä½¿ç”¨æ‹‰æ™®æ‹‰æ–¯æ–¹å·®é‡åŒ–åœ–åƒæ¸…æ™°åº¦ã€è¨ˆç®—æœ‰æ•ˆé¢éƒ¨å€åŸŸå’Œé®æ“‹æ¯”ä¾‹ã€æª¢æŸ¥äº®åº¦ç¯„åœã€‚

The system first detects facial landmarks (eyes, nose tip, mouth corners) and performs high-precision affine transformation to standardize the scale, position, and pose of input images. Quality checks include using Laplacian variance to quantify image sharpness, calculating effective facial area and occlusion ratio, and checking brightness range.

ArcFace æå¤±å‡½æ•¸å®šç¾©ç‚ºï¼š

The ArcFace loss function is defined as:

```
L = -1/N âˆ‘áµ¢â‚Œâ‚á´º log(e^(sÂ·cos(Î¸yáµ¢ + m)) / (e^(sÂ·cos(Î¸yáµ¢ + m)) + âˆ‘â±¼â‚Œâ‚,â±¼â‰ yáµ¢á¶œ e^(sÂ·cos(Î¸â±¼))))
```

å…¶ä¸­ Î¸yáµ¢ æ˜¯ç‰¹å¾µå‘é‡èˆ‡å°æ‡‰é¡åˆ¥æ¬Šé‡å‘é‡ä¹‹é–“çš„è§’åº¦ï¼Œm æ˜¯åŠ æ€§è§’åº¦é‚Šç•Œï¼ˆå…¸å‹å€¼ mâ‰ˆ0.5ï¼‰ï¼Œs æ˜¯ç‰¹å¾µå°ºåº¦åƒæ•¸ï¼ˆå…¸å‹å€¼ sâ‰ˆ64ï¼‰ã€‚ç³»çµ±å°‡æ¯å¼µé¢éƒ¨åœ–åƒè½‰æ›ç‚ºç¶“ L2 æ­£è¦åŒ–çš„ 512 ç¶­å‘é‡ï¼Œä½¿ç”¨é¤˜å¼¦ç›¸ä¼¼åº¦é€²è¡ŒåŒ¹é…ï¼Œä¸¦ç¶­è­·å¤šæ¨£æœ¬æ¨¡æ¿ä»¥é©æ‡‰é•·æœŸå¤–è§€è®ŠåŒ–ã€‚

Where Î¸yáµ¢ is the angle between the feature vector and the corresponding class weight vector, m is the additive angular margin (typical value mâ‰ˆ0.5), and s is the feature scale parameter (typical value sâ‰ˆ64). The system converts each facial image into an L2-normalized 512-dimensional vector, uses cosine similarity for matching, and maintains multi-sample templates to adapt to long-term appearance changes.

#### 3.5.4 DeepSORT è¿½è¹¤æ¼”ç®—æ³•èˆ‡å¡çˆ¾æ›¼æ¿¾æ³¢å™¨ (DeepSORT Tracking Algorithm and Kalman Filter)

DeepSORT æ¼”ç®—æ³•ç”± Nicolai Wojke ç­‰äººæ–¼ 2017 å¹´æå‡ºï¼Œæ˜¯ SORTï¼ˆSimple Online and Realtime Trackingï¼‰æ¼”ç®—æ³•çš„æ”¹é€²ç‰ˆæœ¬ï¼Œçµåˆäº†é‹å‹•æ¨¡å‹å’Œå¤–è§€ç‰¹å¾µä»¥ç¢ºä¿è·¨å¹€èº«ä»½ä¸€è‡´æ€§ã€‚è©²æ¼”ç®—æ³•çš„æ ¸å¿ƒæ˜¯å¡çˆ¾æ›¼æ¿¾æ³¢å™¨ï¼Œç”± Rudolf Kalman æ–¼ 1960 å¹´æå‡ºï¼Œæ˜¯ä¸€ç¨®ç”¨æ–¼ç·šæ€§å‹•æ…‹ç³»çµ±ç‹€æ…‹ä¼°è¨ˆçš„æœ€å„ªéæ­¸æ¿¾æ³¢å™¨ã€‚

The DeepSORT algorithm was proposed by Nicolai Wojke and others in 2017 as an improved version of the SORT (Simple Online and Realtime Tracking) algorithm, combining motion models with appearance features to ensure cross-frame identity consistency. The core of this algorithm is the Kalman filter, proposed by Rudolf Kalman in 1960, which is an optimal recursive filter for state estimation in linear dynamic systems.

åœ¨ Health Mirror ç³»çµ±ä¸­ï¼ŒDeepSORT æ¡ç”¨å¸¸é€Ÿåº¦é‹å‹•æ¨¡å‹ï¼Œå‡è¨­ç›®æ¨™åœ¨çŸ­æ™‚é–“å…§è¡¨ç¾å‡ºè¿‘ä¼¼æ†å®šçš„é€Ÿåº¦ã€‚ç‹€æ…‹å‘é‡åŒ…å«ç›®æ¨™é‚Šç•Œæ¡†çš„ä¸­å¿ƒåº§æ¨™ã€ç¸±æ©«æ¯”ã€é«˜åº¦åŠå…¶é€Ÿåº¦åˆ†é‡ï¼š

In the Health Mirror system, DeepSORT adopts a constant velocity motion model, assuming targets exhibit approximately constant velocity over short periods. The state vector contains the center coordinates, aspect ratio, height of the target's bounding box, and their velocity components:

```
x = [u, v, Î³, h, uÌ‡, vÌ‡, Î³Ì‡, á¸£]áµ€
```

å…¶ä¸­ (u, v) ç‚ºé‚Šç•Œæ¡†ä¸­å¿ƒåº§æ¨™ï¼ŒÎ³ ç‚ºç¸±æ©«æ¯”ï¼Œh ç‚ºé«˜åº¦ï¼Œé»è¡¨ç¤ºå°æ‡‰çš„é€Ÿåº¦åˆ†é‡ã€‚

Where (u, v) are the center coordinates of the bounding box, Î³ is the aspect ratio, h is the height, and dots represent the corresponding velocity components.

å¡çˆ¾æ›¼æ¿¾æ³¢å™¨çš„é æ¸¬æ­¥é©Ÿï¼š

Kalman filter prediction step:

```
xâ‚–|â‚–â‚‹â‚ = Fâ‚–xâ‚–â‚‹â‚|â‚–â‚‹â‚
Pâ‚–|â‚–â‚‹â‚ = Fâ‚–Pâ‚–â‚‹â‚|â‚–â‚‹â‚Fâ‚–áµ€ + Qâ‚–
```

æ›´æ–°æ­¥é©Ÿï¼š

Update step:

```
Kâ‚– = Pâ‚–|â‚–â‚‹â‚Hâ‚–áµ€(Hâ‚–Pâ‚–|â‚–â‚‹â‚Hâ‚–áµ€ + Râ‚–)â»Â¹
xâ‚–|â‚– = xâ‚–|â‚–â‚‹â‚ + Kâ‚–(zâ‚– - Hâ‚–xâ‚–|â‚–â‚‹â‚)
Pâ‚–|â‚– = (I - Kâ‚–Hâ‚–)Pâ‚–|â‚–â‚‹â‚
```

å…¶ä¸­ F ç‚ºç‹€æ…‹è½‰ç§»çŸ©é™£ï¼ŒH ç‚ºè§€æ¸¬çŸ©é™£ï¼ŒQ ç‚ºéç¨‹å™ªè²å”æ–¹å·®ï¼ŒR ç‚ºè§€æ¸¬å™ªè²å”æ–¹å·®ï¼ŒK ç‚ºå¡çˆ¾æ›¼å¢ç›Šã€‚

Where F is the state transition matrix, H is the observation matrix, Q is the process noise covariance, R is the observation noise covariance, and K is the Kalman gain.

ç›®æ¨™é—œè¯éç¨‹é¦–å…ˆä½¿ç”¨é¦¬æ°è·é›¢é€²è¡Œåˆæ­¥ç¯©é¸ï¼Œæ¶ˆé™¤èˆ‡ç•¶å‰ç‹€æ…‹ä¸ç¢ºå®šæ€§åˆ†ä½ˆä¸ç¬¦çš„é…å°ã€‚é¦¬æ°è·é›¢å®šç¾©ç‚ºï¼š

The target association process first uses Mahalanobis distance for preliminary screening, eliminating pairs that don't align with current state uncertainty distribution. Mahalanobis distance is defined as:

```
dÂ²(i,j) = (dâ±¼ - yáµ¢)áµ€Sáµ¢â»Â¹(dâ±¼ - yáµ¢)
```

å…¶ä¸­ dâ±¼ ç‚ºç¬¬ j å€‹æª¢æ¸¬çµæœï¼Œyáµ¢ ç‚ºç¬¬ i å€‹è»Œè·¡çš„é æ¸¬ä½ç½®ï¼ŒSáµ¢ ç‚ºå‰µæ–°å”æ–¹å·®çŸ©é™£ã€‚ç¯©é¸å¾Œä½¿ç”¨åŒˆç‰™åˆ©æ¼”ç®—æ³•æ±‚è§£æœ€å°æˆæœ¬æŒ‡æ´¾å•é¡Œï¼Œæˆæœ¬å‡½æ•¸çµåˆé‚Šç•Œæ¡† IoU å’Œå¤–è§€åµŒå…¥çš„é¤˜å¼¦è·é›¢ã€‚

Where dâ±¼ is the j-th detection result, yáµ¢ is the predicted position of the i-th track, and Sáµ¢ is the innovation covariance matrix. After screening, the Hungarian algorithm solves the minimum cost assignment problem, with cost function combining bounding box IoU and cosine distance of appearance embeddings.

è»Œè·¡ç®¡ç†å¯¦æ–½ç¢ºèªéšæ®µï¼Œæ–°æª¢æ¸¬ç›®æ¨™éœ€é€£çºŒå‘½ä¸­è¶…é min_hits é–¾å€¼æ‰è¢«è¦–ç‚ºæœ‰æ•ˆè»Œè·¡ï¼Œé•·æ™‚é–“æœªåŒ¹é…çš„è»Œè·¡åœ¨è¶…é max_age é–¾å€¼å¾Œè‡ªå‹•åˆªé™¤ã€‚å°æ–¼é‡æ–°é€²å…¥å ´æ™¯çš„ç›®æ¨™ï¼Œç³»çµ±çµåˆå¤–è§€ç‰¹å¾µå’Œç©ºé–“é„°è¿‘æ€§æ¢å¾©åŸå§‹ IDï¼Œæœ€å°åŒ–èº«ä»½é‡ç½®çš„ç™¼ç”Ÿã€‚

Track management implements a confirmation phase where newly detected objects require consecutive hits exceeding the min_hits threshold to be considered valid tracks. Tracks that haven't been matched for extended periods are automatically deleted after exceeding the max_age threshold. For targets re-entering the scene, the system combines appearance features and spatial proximity to recover original IDs, minimizing identity resets.

### 3.6 ç³»çµ±æ•´åˆèˆ‡éƒ¨ç½²æ¶æ§‹ (System Integration and Deployment Architecture)

åœ¨ç³»çµ±æ•´åˆå±¤é¢ï¼ŒHealth Mirror æ¡ç”¨å¾®æœå‹™æ¶æ§‹è¨­è¨ˆï¼Œå°‡ AI æ¨è«–ã€ç”¨æˆ¶ç®¡ç†ã€æ•¸æ“šå­˜å„²å’Œé†«ç™‚é ç´„ç­‰åŠŸèƒ½æ¨¡çµ„åŒ–ã€‚é€é Docker å®¹å™¨åŒ–æŠ€è¡“ç¢ºä¿è·¨å¹³å°éƒ¨ç½²çš„ä¸€è‡´æ€§ï¼Œä¸¦åˆ©ç”¨ Kubernetes é€²è¡Œå®¹å™¨ç·¨æ’èˆ‡è‡ªå‹•æ“´ç¸®å®¹ã€‚å‰ç«¯æ¡ç”¨éŸ¿æ‡‰å¼è¨­è¨ˆï¼Œæ”¯æ´æ¡Œé¢ç€è¦½å™¨ã€å¹³æ¿é›»è…¦å’Œæ™ºæ…§å‹æ‰‹æ©Ÿç­‰å¤šç¨®è¨­å‚™è¨ªå•ã€‚

At the system integration level, Health Mirror adopts a microservices architecture design, modularizing functions such as AI inference, user management, data storage, and medical appointments. Docker containerization technology ensures consistency in cross-platform deployment, while Kubernetes is used for container orchestration and auto-scaling. The frontend adopts responsive design, supporting access from various devices including desktop browsers, tablets, and smartphones.

ç³»çµ±çš„å®‰å…¨æ€§è¨­è¨ˆéµå¾ªé†«ç™‚æ•¸æ“šä¿è­·çš„æœ€é«˜æ¨™æº–ï¼Œå¯¦æ–½ç«¯åˆ°ç«¯åŠ å¯†ã€è¨ªå•æ§åˆ¶å’Œå¯©è¨ˆæ—¥èªŒç­‰å®‰å…¨æªæ–½ã€‚æ‰€æœ‰å¥åº·æ•¸æ“šçš„å‚³è¼¸å’Œå­˜å„²å‡æ¡ç”¨ AES-256 åŠ å¯†ï¼Œç”¨æˆ¶èº«ä»½é©—è­‰æ”¯æ´å¤šå› å­èªè­‰ï¼ˆMFAï¼‰ï¼Œç¢ºä¿å€‹äººéš±ç§å’Œé†«ç™‚æ•¸æ“šçš„å®‰å…¨æ€§ã€‚

The system's security design follows the highest standards for medical data protection, implementing security measures such as end-to-end encryption, access control, and audit logs. All health data transmission and storage use AES-256 encryption, and user authentication supports multi-factor authentication (MFA) to ensure the security of personal privacy and medical data.

---

## Chapter IV: é–‹ç™¼ç’°å¢ƒå»ºç½®èˆ‡å¯¦ä½œæµç¨‹ (Development Environment Setup and Implementation Process)

### 4.1 Conda ç’°å¢ƒå»ºç½®èˆ‡ä¾è³´ç®¡ç† (Conda Environment Setup and Dependency Management)

Health Mirror ç³»çµ±çš„é–‹ç™¼ç’°å¢ƒå»ºç½®æ¡ç”¨ Anaconda ä½œç‚º Python ç’°å¢ƒç®¡ç†å·¥å…·ï¼Œç¢ºä¿è·¨å¹³å°é–‹ç™¼çš„ä¸€è‡´æ€§å’Œä¾è³´å¥—ä»¶çš„ç‰ˆæœ¬æ§åˆ¶ã€‚Anaconda æä¾›äº†å®Œæ•´çš„æ•¸æ“šç§‘å­¸ç”Ÿæ…‹ç³»çµ±ï¼ŒåŒ…å« Jupyter Notebookã€NumPyã€Pandasã€Matplotlib ç­‰æ ¸å¿ƒå¥—ä»¶ï¼Œç‚º AI æ¨¡å‹é–‹ç™¼æä¾›ç©©å®šçš„åŸºç¤ç’°å¢ƒã€‚

The Health Mirror system's development environment setup uses Anaconda as the Python environment management tool, ensuring cross-platform development consistency and dependency package version control. Anaconda provides a complete data science ecosystem, including Jupyter Notebook, NumPy, Pandas, Matplotlib, and other core packages, providing a stable foundation for AI model development.

#### 4.1.1 ç’°å¢ƒå»ºç«‹æ­¥é©Ÿ (Environment Setup Steps)

é¦–å…ˆå»ºç«‹å°ˆç”¨çš„ Conda è™›æ“¬ç’°å¢ƒï¼Œéš”é›¢å°ˆæ¡ˆä¾è³´é¿å…ç‰ˆæœ¬è¡çªï¼š

First, create a dedicated Conda virtual environment to isolate project dependencies and avoid version conflicts:

```bash
# å»ºç«‹æ–°çš„ Conda ç’°å¢ƒ
conda create -n health_mirror python=3.9

# å•Ÿå‹•ç’°å¢ƒ
conda activate health_mirror

# å®‰è£æ ¸å¿ƒæ©Ÿå™¨å­¸ç¿’å¥—ä»¶
conda install pytorch torchvision torchaudio pytorch-cuda=11.8 -c pytorch -c nvidia
conda install opencv matplotlib pandas numpy scikit-learn

# å®‰è£ YOLOv8 å’Œç›¸é—œå¥—ä»¶
pip install ultralytics
pip install insightface
pip install deep-sort-realtime

# å®‰è£ Django å’Œ Web é–‹ç™¼å¥—ä»¶
pip install django djangorestframework
pip install pillow
pip install python-decouple
```

#### 4.1.2 Google Colab é›²ç«¯é–‹ç™¼ç’°å¢ƒ (Google Colab Cloud Development Environment)

ç‚ºäº†åˆ©ç”¨å…è²»çš„ GPU è³‡æºé€²è¡Œæ¨¡å‹è¨“ç·´ï¼Œæˆ‘å€‘åŒæ™‚é…ç½® Google Colab ç’°å¢ƒã€‚Colab æä¾› Tesla T4 GPUï¼Œé©åˆä¸­å°å‹æ¨¡å‹çš„è¨“ç·´å’Œå¯¦é©—ï¼š

To utilize free GPU resources for model training, we also configure the Google Colab environment. Colab provides Tesla T4 GPU, suitable for training and experimenting with small to medium-sized models:

```python
# Google Colab ç’°å¢ƒè¨­å®š
from google.colab import drive
import os

# æ›è¼‰ Google Drive
drive.mount('/content/drive', force_remount=True)

# å®‰è£å¿…è¦å¥—ä»¶
!pip install ultralytics
!pip install roboflow

# è¨­å®š GPU ç’°å¢ƒ
import torch
print(f"CUDA available: {torch.cuda.is_available()}")
print(f"GPU count: {torch.cuda.device_count()}")
if torch.cuda.is_available():
    print(f"Current GPU: {torch.cuda.get_device_name(0)}")
```

### 4.2 æ•¸æ“šæº–å‚™èˆ‡æ¨™è¨»æµç¨‹ (Data Preparation and Annotation Process)

#### 4.2.1 æ•¸æ“šé›†çµæ§‹è¨­è¨ˆ (Dataset Structure Design)

Health Mirror ç³»çµ±æ¡ç”¨ YOLO æ ¼å¼çš„æ•¸æ“šé›†çµæ§‹ï¼Œæ¯å€‹å¥åº·æª¢æ¸¬ä»»å‹™ï¼ˆé»‘çœ¼åœˆã€å”‡éƒ¨ç‹€æ³ã€çš®è†šå•é¡Œã€ç¶œåˆå¥åº·æŒ‡æ¨™ï¼‰éƒ½æœ‰ç¨ç«‹çš„æ•¸æ“šé›†ï¼š

The Health Mirror system adopts YOLO format dataset structure, with each health detection task (dark circles, lip conditions, skin problems, comprehensive health indicators) having independent datasets:

```
DATA-Train/
â”œâ”€â”€ Dark_Circles/
â”‚   â”œâ”€â”€ train/
â”‚   â”‚   â”œâ”€â”€ images/
â”‚   â”‚   â””â”€â”€ labels/
â”‚   â”œâ”€â”€ valid/
â”‚   â”‚   â”œâ”€â”€ images/
â”‚   â”‚   â””â”€â”€ labels/
â”‚   â”œâ”€â”€ test/
â”‚   â”‚   â”œâ”€â”€ images/
â”‚   â”‚   â””â”€â”€ labels/
â”‚   â””â”€â”€ data.yaml
â”œâ”€â”€ Lip_types/
â”œâ”€â”€ skin/
â””â”€â”€ health/
```

æ¯å€‹ data.yaml æª”æ¡ˆå®šç¾©äº†é¡åˆ¥æ¨™ç±¤å’Œè·¯å¾‘é…ç½®ï¼š

Each data.yaml file defines class labels and path configurations:

```yaml
# Dark_Circles/data.yaml
train: /content/drive/MyDrive/DATA-Train/Dark_Circles/train/images
val: /content/drive/MyDrive/DATA-Train/Dark_Circles/valid/images
test: /content/drive/MyDrive/DATA-Train/Dark_Circles/test/images

nc: 2  # é¡åˆ¥æ•¸é‡
names: ['no_dark_circles', 'dark_circles']  # é¡åˆ¥åç¨±
```

### 4.3 æ¨¡å‹è¨“ç·´æµç¨‹è©³è§£ (Detailed Model Training Process)

#### 4.3.1 YOLOv8 æ¨¡å‹è¨“ç·´å¯¦ä½œ (YOLOv8 Model Training Implementation)

åŸºæ–¼ Training.md çš„è¨“ç·´æµç¨‹ï¼Œæˆ‘å€‘æ¡ç”¨é·ç§»å­¸ç¿’ç­–ç•¥ï¼Œå¾é è¨“ç·´çš„ YOLOv8 æ¨¡å‹é–‹å§‹ï¼Œé‡å°å¥åº·æª¢æ¸¬ä»»å‹™é€²è¡Œå¾®èª¿ï¼š

Based on the training process in Training.md, we adopt a transfer learning strategy, starting from pre-trained YOLOv8 models and fine-tuning for health detection tasks:

```python
# è¼‰å…¥é è¨“ç·´æ¨¡å‹
from ultralytics import YOLO
import os

# é¸æ“‡é©ç•¶çš„æ¨¡å‹å¤§å°ï¼ˆæ ¹æ“šè¨ˆç®—è³‡æºå’Œç²¾åº¦éœ€æ±‚ï¼‰
model = YOLO("yolov8l.pt")  # Large model for better accuracy

# è¨“ç·´é…ç½®
training_config = {
    "data": "/content/drive/MyDrive/DATA-Train/Dark_Circles/data.yaml",
    "epochs": 30,
    "batch": 16,
    "imgsz": 640,
    "device": 0,  # GPU device
    "save_dir": "/content/drive/MyDrive/DATA-Train/Dark_Circles",
    "name": "DarkCirclesTrain_v1",
    "patience": 10,  # Early stopping
    "save_period": 5,  # Save checkpoint every 5 epochs
    "val": True,  # Validate during training
    "plots": True,  # Generate training plots
    "verbose": True  # Detailed logging
}

# é–‹å§‹è¨“ç·´
results = model.train(**training_config)
```

#### 4.3.2 è¨“ç·´ç›£æ§èˆ‡å„ªåŒ– (Training Monitoring and Optimization)

è¨“ç·´éç¨‹ä¸­å¯¦æ–½å¤šé …ç›£æ§å’Œå„ªåŒ–ç­–ç•¥ï¼š

Multiple monitoring and optimization strategies are implemented during training:

```python
# è¨“ç·´å¾Œè©•ä¼°
metrics = model.val()  # åœ¨é©—è­‰é›†ä¸Šè©•ä¼°
print(f"mAP50: {metrics.box.map50}")
print(f"mAP50-95: {metrics.box.map}")

# æ¨¡å‹æ¨è«–æ¸¬è©¦
test_results = model("/path/to/test/image.jpg")

# å¯è¦–åŒ–è¨“ç·´çµæœ
import matplotlib.pyplot as plt

# é¡¯ç¤ºè¨“ç·´æ›²ç·š
training_results_path = "/content/drive/MyDrive/DATA-Train/Dark_Circles/DarkCirclesTrain_v1/results.png"
plt.figure(figsize=(12, 8))
plt.imshow(plt.imread(training_results_path))
plt.axis('off')
plt.title('Training Results')
plt.show()
```

#### 4.3.3 æ¨¡å‹é©—è­‰èˆ‡æ¸¬è©¦ (Model Validation and Testing)

è¨“ç·´å®Œæˆå¾Œé€²è¡Œå…¨é¢çš„æ¨¡å‹é©—è­‰ï¼Œç¢ºä¿æ¨¡å‹æ€§èƒ½ç¬¦åˆé æœŸï¼š

After training completion, comprehensive model validation is performed to ensure model performance meets expectations:

```python
# è¼‰å…¥æœ€ä½³æ¨¡å‹
best_model = YOLO("/content/drive/MyDrive/DATA-Train/Dark_Circles/DarkCirclesTrain_v15/weights/best.pt")

# éš¨æ©Ÿæ¸¬è©¦æ¨è«–
import random
import cv2
import numpy as np

test_path = "/content/drive/MyDrive/DATA-Train/Dark_Circles/test/images"
img_list = os.listdir(test_path)
random_img = random.choice(img_list)
test_img_path = os.path.join(test_path, random_img)

# åŸ·è¡Œæ¨è«–
results = best_model(test_img_path)[0]

# è¦–è¦ºåŒ–çµæœ
img = cv2.imread(test_img_path)
for box in results.boxes:
    x1, y1, x2, y2 = box.xyxy[0].tolist()
    cls = int(box.cls[0])
    label = best_model.names[cls]
    conf = box.conf[0]
    
    # ç¹ªè£½é‚Šç•Œæ¡†å’Œæ¨™ç±¤
    cv2.rectangle(img, (int(x1), int(y1)), (int(x2), int(y2)), (255, 0, 0), 2)
    cv2.putText(img, f"{label} {conf:.2f}", (int(x1), int(y1) - 10),
                cv2.FONT_HERSHEY_SIMPLEX, 0.9, (255, 0, 0), 2)

# é¡¯ç¤ºçµæœ
img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
plt.figure(figsize=(10, 8))
plt.imshow(img_rgb)
plt.axis('off')
plt.title(f"Inference Result: {random_img}")
plt.show()

# å„²å­˜æ¨è«–çµæœ
save_path = "/content/drive/MyDrive/DATA-Train/Dark_Circles"
save_img_path = os.path.join(save_path, f"inference_{random_img}")
cv2.imwrite(save_img_path, img)
print(f"æ¨è«–çµæœå·²å„²å­˜åˆ°: {save_img_path}")
```

### 4.4 Django Web æ‡‰ç”¨é–‹ç™¼æµç¨‹ (Django Web Application Development Process)

#### 4.4.1 Django å°ˆæ¡ˆæ¶æ§‹è¨­è¨ˆ (Django Project Architecture Design)

Health Mirror çš„ Web æ‡‰ç”¨æ¡ç”¨ Django æ¡†æ¶ï¼Œå¯¦ç¾æ¨¡å‹-è¦–åœ–-æ¨¡æ¿ï¼ˆMVTï¼‰æ¶æ§‹æ¨¡å¼ã€‚å°ˆæ¡ˆçµæ§‹éµå¾ª Django æœ€ä½³å¯¦è¸ï¼Œå°‡åŠŸèƒ½æ¨¡çµ„åŒ–ä»¥æé«˜å¯ç¶­è­·æ€§ï¼š

The Health Mirror web application uses the Django framework, implementing the Model-View-Template (MVT) architecture pattern. The project structure follows Django best practices, modularizing functionality to improve maintainability:

```
safety/  # Django å°ˆæ¡ˆæ ¹ç›®éŒ„
â”œâ”€â”€ safety/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ settings.py     # å°ˆæ¡ˆè¨­å®š
â”‚   â”œâ”€â”€ urls.py         # URL è·¯ç”±é…ç½®
â”‚   â”œâ”€â”€ wsgi.py         # WSGI éƒ¨ç½²é…ç½®
â”‚   â””â”€â”€ asgi.py         # ASGI ç•°æ­¥é…ç½®
â”œâ”€â”€ base/               # ä¸»è¦æ‡‰ç”¨æ¨¡çµ„
â”‚   â”œâ”€â”€ models.py       # æ•¸æ“šæ¨¡å‹å®šç¾©
â”‚   â”œâ”€â”€ views.py        # è¦–åœ–é‚è¼¯
â”‚   â”œâ”€â”€ urls.py         # æ‡‰ç”¨ URL é…ç½®
â”‚   â”œâ”€â”€ forms.py        # è¡¨å–®å®šç¾©
â”‚   â”œâ”€â”€ admin.py        # ç®¡ç†ä»‹é¢é…ç½®
â”‚   â””â”€â”€ templates/      # HTML æ¨¡æ¿
â”œâ”€â”€ static/             # éœæ…‹æª”æ¡ˆ
â”‚   â”œâ”€â”€ styles/         # CSS æ¨£å¼
â”‚   â”œâ”€â”€ js/             # JavaScript
â”‚   â””â”€â”€ images/         # åœ–ç‰‡è³‡æº
â”œâ”€â”€ media/              # ç”¨æˆ¶ä¸Šå‚³æª”æ¡ˆ
â”œâ”€â”€ AIModels/           # AI æ¨¡å‹æª”æ¡ˆ
â””â”€â”€ manage.py           # Django ç®¡ç†è…³æœ¬
```

#### 4.4.2 æ•¸æ“šæ¨¡å‹è¨­è¨ˆ (Data Model Design)

ç³»çµ±çš„æ ¸å¿ƒæ•¸æ“šæ¨¡å‹åŒ…æ‹¬ç”¨æˆ¶ç®¡ç†ã€å¥åº·è¨˜éŒ„å’Œé†«ç™‚é ç´„ç­‰åŠŸèƒ½ï¼š

The system's core data models include user management, health records, and medical appointment functions:

```python
# base/models.py
from django.db import models
from django.contrib.auth.models import AbstractUser
from django.utils import timezone

class User(AbstractUser):
    """æ“´å±•ç”¨æˆ¶æ¨¡å‹"""
    phone = models.CharField(max_length=15, blank=True)
    mykad = models.CharField(max_length=12, unique=True, blank=True)
    race = models.CharField(max_length=50, blank=True)
    admin = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    
class HealthRecord(models.Model):
    """å¥åº·æª¢æ¸¬è¨˜éŒ„"""
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    image_path = models.ImageField(upload_to='health_images/')
    detection_results = models.JSONField()  # å„²å­˜ AI æª¢æ¸¬çµæœ
    dark_circles_score = models.FloatField(null=True, blank=True)
    lip_condition = models.CharField(max_length=100, blank=True)
    skin_analysis = models.JSONField(null=True, blank=True)
    overall_health_score = models.FloatField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    
class Booking(models.Model):
    """é†«ç™‚é ç´„æ¨¡å‹"""
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    appointment_date = models.DateTimeField()
    doctor_name = models.CharField(max_length=100)
    department = models.CharField(max_length=100)
    status = models.CharField(max_length=20, default='pending')
    notes = models.TextField(blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
```

#### 4.4.3 AI æ¨¡å‹æ•´åˆ (AI Model Integration)

Django è¦–åœ–ä¸­æ•´åˆ AI æ¨¡å‹é€²è¡Œå³æ™‚å¥åº·æª¢æ¸¬ï¼š

Integrating AI models in Django views for real-time health detection:

```python
# base/views.py
from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required
from django.http import JsonResponse
from ultralytics import YOLO
import cv2
import numpy as np
import os
from .models import HealthRecord

# è¼‰å…¥é è¨“ç·´æ¨¡å‹
DARK_CIRCLES_MODEL = YOLO('AIModels/DarkCircles.pt')
LIP_MODEL = YOLO('AIModels/Lip_types.pt')
SKIN_MODEL = YOLO('AIModels/skin.pt')
HEALTH_MODEL = YOLO('AIModels/health.pt')

@login_required
def health_detection(request):
    """å¥åº·æª¢æ¸¬ä¸»é é¢"""
    if request.method == 'POST' and request.FILES.get('image'):
        image_file = request.FILES['image']
        
        # å„²å­˜ä¸Šå‚³çš„åœ–ç‰‡
        health_record = HealthRecord.objects.create(
            user=request.user,
            image_path=image_file
        )
        
        # åŸ·è¡Œ AI æª¢æ¸¬
        detection_results = perform_ai_detection(health_record.image_path.path)
        
        # æ›´æ–°æª¢æ¸¬çµæœ
        health_record.detection_results = detection_results
        health_record.dark_circles_score = detection_results.get('dark_circles_score')
        health_record.lip_condition = detection_results.get('lip_condition')
        health_record.skin_analysis = detection_results.get('skin_analysis')
        health_record.overall_health_score = detection_results.get('overall_health_score')
        health_record.save()
        
        return JsonResponse({
            'success': True,
            'results': detection_results,
            'record_id': health_record.id
        })
    
    return render(request, 'base/health_detection.html')

def perform_ai_detection(image_path):
    """åŸ·è¡Œå¤šæ¨¡å‹ AI æª¢æ¸¬"""
    # è®€å–åœ–ç‰‡
    image = cv2.imread(image_path)
    
    # é»‘çœ¼åœˆæª¢æ¸¬
    dark_circles_results = DARK_CIRCLES_MODEL(image)
    dark_circles_score = calculate_dark_circles_score(dark_circles_results)
    
    # å”‡éƒ¨ç‹€æ³æª¢æ¸¬
    lip_results = LIP_MODEL(image)
    lip_condition = analyze_lip_condition(lip_results)
    
    # çš®è†šåˆ†æ
    skin_results = SKIN_MODEL(image)
    skin_analysis = analyze_skin_condition(skin_results)
    
    # ç¶œåˆå¥åº·è©•ä¼°
    health_results = HEALTH_MODEL(image)
    overall_health_score = calculate_overall_health_score(health_results)
    
    return {
        'dark_circles_score': dark_circles_score,
        'lip_condition': lip_condition,
        'skin_analysis': skin_analysis,
        'overall_health_score': overall_health_score,
        'timestamp': timezone.now().isoformat()
    }
```

#### 4.4.4 å‰ç«¯ä»‹é¢é–‹ç™¼ (Frontend Interface Development)

æ¡ç”¨éŸ¿æ‡‰å¼è¨­è¨ˆï¼Œçµåˆ HTML5ã€CSS3 å’Œ JavaScript å‰µå»ºç›´è§€çš„ç”¨æˆ¶ä»‹é¢ï¼š

Using responsive design, combining HTML5, CSS3, and JavaScript to create an intuitive user interface:

```html
<!-- templates/base/health_detection.html -->
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Health Mirror - å¥åº·æª¢æ¸¬</title>
    <link rel="stylesheet" href="{% static 'styles/style.css' %}">
</head>
<body>
    <div class="container">
        <h1>AI å¥åº·æª¢æ¸¬</h1>
        
        <!-- åœ–ç‰‡ä¸Šå‚³å€åŸŸ -->
        <div class="upload-section">
            <form id="detection-form" enctype="multipart/form-data">
                {% csrf_token %}
                <div class="upload-area" id="upload-area">
                    <input type="file" id="image-input" name="image" accept="image/*" required>
                    <label for="image-input">
                        <i class="upload-icon"></i>
                        <p>é»æ“Šæˆ–æ‹–æ‹½ä¸Šå‚³ç…§ç‰‡</p>
                    </label>
                </div>
                <button type="submit" id="detect-btn">é–‹å§‹æª¢æ¸¬</button>
            </form>
        </div>
        
        <!-- æª¢æ¸¬çµæœé¡¯ç¤ºå€åŸŸ -->
        <div class="results-section" id="results-section" style="display: none;">
            <h2>æª¢æ¸¬çµæœ</h2>
            <div class="result-cards">
                <div class="result-card">
                    <h3>é»‘çœ¼åœˆæª¢æ¸¬</h3>
                    <div class="score" id="dark-circles-score">--</div>
                </div>
                <div class="result-card">
                    <h3>å”‡éƒ¨ç‹€æ³</h3>
                    <div class="condition" id="lip-condition">--</div>
                </div>
                <div class="result-card">
                    <h3>çš®è†šåˆ†æ</h3>
                    <div class="analysis" id="skin-analysis">--</div>
                </div>
                <div class="result-card">
                    <h3>ç¶œåˆå¥åº·è©•åˆ†</h3>
                    <div class="score" id="overall-score">--</div>
                </div>
            </div>
        </div>
    </div>
    
    <script src="{% static 'js/health_detection.js' %}"></script>
</body>
</html>
```

### 4.5 ç³»çµ±éƒ¨ç½²èˆ‡ç¶­é‹ (System Deployment and Operations)

#### 4.5.1 æœ¬åœ°é–‹ç™¼ç’°å¢ƒéƒ¨ç½² (Local Development Environment Deployment)

```bash
# å•Ÿå‹• Django é–‹ç™¼æœå‹™å™¨
python manage.py makemigrations
python manage.py migrate
python manage.py collectstatic
python manage.py runserver 0.0.0.0:8000
```

#### 4.5.2 ç”Ÿç”¢ç’°å¢ƒéƒ¨ç½²è€ƒé‡ (Production Environment Deployment Considerations)

ç”Ÿç”¢ç’°å¢ƒéƒ¨ç½²éœ€è¦è€ƒæ…®æ€§èƒ½å„ªåŒ–ã€å®‰å…¨æ€§å’Œå¯æ“´å±•æ€§ï¼š

Production environment deployment requires consideration of performance optimization, security, and scalability:

- **Web æœå‹™å™¨é…ç½®**ï¼šä½¿ç”¨ Nginx + Gunicorn éƒ¨ç½² Django æ‡‰ç”¨
- **æ•¸æ“šåº«å„ªåŒ–**ï¼šå¾ SQLite é·ç§»åˆ° PostgreSQL æˆ– MySQL
- **éœæ…‹æª”æ¡ˆæœå‹™**ï¼šé…ç½® CDN åŠ é€Ÿéœæ…‹è³‡æºè¼‰å…¥
- **AI æ¨¡å‹å„ªåŒ–**ï¼šä½¿ç”¨ ONNX æˆ– TensorRT å„ªåŒ–æ¨è«–é€Ÿåº¦
- **è² è¼‰å‡è¡¡**ï¼šå¯¦æ–½æ°´å¹³æ“´å±•ä»¥è™•ç†é«˜ä½µç™¼è«‹æ±‚
- **ç›£æ§èˆ‡æ—¥èªŒ**ï¼šéƒ¨ç½² ELK Stack é€²è¡Œç³»çµ±ç›£æ§

---

## ç¬¬äº”ç«  ç³»çµ±æ¶æ§‹èˆ‡æŠ€è¡“ç´°ç¯€ (Chapter V: System Architecture and Technical Details)

æœ¬ç« å°‡æ·±å…¥æ¢è¨ Health Mirror ç³»çµ±çš„æŠ€è¡“æ¶æ§‹ã€å¯¦ç¾ç´°ç¯€å’Œé—œéµçµ„ä»¶ï¼Œç‚ºè®€è€…æä¾›å…¨é¢çš„ç³»çµ±æŠ€è¡“è¦–è§’ã€‚å¾ Django å°ˆæ¡ˆçµæ§‹åˆ° AI æ¨¡å‹æ•´åˆï¼Œå¾æ•¸æ“šæµè™•ç†åˆ°å®‰å…¨æ€§è€ƒé‡ï¼Œæœ¬ç« æ—¨åœ¨å±•ç¤ºç³»çµ±å¦‚ä½•å°‡ç†è«–è¨­è¨ˆè½‰åŒ–ç‚ºå¯¦éš›å¯é‹è¡Œçš„å¥åº·ç›£æ¸¬å¹³å°ã€‚

This chapter delves into the technical architecture, implementation details, and key components of the Health Mirror system, providing readers with a comprehensive technical perspective. From Django project structure to AI model integration, from data flow processing to security considerations, this chapter aims to demonstrate how the system transforms theoretical design into a practical, operational health monitoring platform.

### 5.1 Django å°ˆæ¡ˆçµæ§‹è©³è§£ (Django Project Structure Detailed Explanation)

Health Mirror ç³»çµ±æ¡ç”¨ Django æ¡†æ¶ä½œç‚ºå¾Œç«¯é–‹ç™¼çš„æ ¸å¿ƒï¼Œå…¶å°ˆæ¡ˆçµæ§‹éµå¾ª Django çš„æœ€ä½³å¯¦è¸ï¼ŒåŒæ™‚èå…¥äº† AI æ¨¡å‹æ•´åˆçš„ç‰¹æ®Šéœ€æ±‚ã€‚Django çš„é¸æ“‡åŸºæ–¼å…¶å¼·å¤§çš„ ORM ç³»çµ±ã€å…§ç½®çš„å®‰å…¨æ©Ÿåˆ¶ã€å¯æ“´å±•æ€§å’Œè±å¯Œçš„ç”Ÿæ…‹ç³»çµ±ï¼Œé€™äº›ç‰¹æ€§ä½¿å…¶æˆç‚ºå¥åº·ç›£æ¸¬ç³»çµ±çš„ç†æƒ³æ¡†æ¶ã€‚ä»¥ä¸‹æ˜¯å°å°ˆæ¡ˆçµæ§‹çš„è©³ç´°è§£æï¼š

The Health Mirror system uses the Django framework as the core of backend development. Its project structure follows Django best practices while incorporating special requirements for AI model integration. The choice of Django is based on its powerful ORM system, built-in security mechanisms, scalability, and rich ecosystem, which make it an ideal framework for health monitoring systems. Below is a detailed analysis of the project structure:

#### 5.1.1 å°ˆæ¡ˆæ ¹ç›®éŒ„çµæ§‹ (Project Root Directory Structure)

```
safety/  # Django å°ˆæ¡ˆæ ¹ç›®éŒ„
```

å°ˆæ¡ˆæ ¹ç›®éŒ„ã€Œsafetyã€æ˜¯æ•´å€‹ç³»çµ±çš„å®¹å™¨ï¼ŒåŒ…å«æ‰€æœ‰å­æ¨¡çµ„å’Œé…ç½®æ–‡ä»¶ã€‚é¸æ“‡ã€Œsafetyã€ä½œç‚ºåç¨±åæ˜ äº†ç³»çµ±çš„æ ¸å¿ƒåƒ¹å€¼ï¼šç‚ºç”¨æˆ¶æä¾›å®‰å…¨ã€å¯é çš„å¥åº·ç›£æ¸¬æœå‹™ã€‚

The project root directory "safety" is the container for the entire system, containing all submodules and configuration files. The choice of "safety" as the name reflects the core value of the system: providing users with safe and reliable health monitoring services.

#### 5.1.2 æ ¸å¿ƒé…ç½®ç›®éŒ„ (Core Configuration Directory)

```
â”œâ”€â”€ safety/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ settings.py     # å°ˆæ¡ˆè¨­å®š
â”‚   â”œâ”€â”€ urls.py         # URL è·¯ç”±é…ç½®
â”‚   â”œâ”€â”€ wsgi.py         # WSGI éƒ¨ç½²é…ç½®
â”‚   â””â”€â”€ asgi.py         # ASGI ç•°æ­¥é…ç½®
```

æ ¸å¿ƒé…ç½®ç›®éŒ„åŒ…å« Django å°ˆæ¡ˆçš„åŸºç¤è¨­å®šï¼š

The core configuration directory contains the basic settings for the Django project:

- **settings.py**ï¼šå®šç¾©äº†è³‡æ–™åº«é€£æ¥ã€éœæ…‹æ–‡ä»¶è·¯å¾‘ã€å·²å®‰è£æ‡‰ç”¨ã€ä¸­é–“ä»¶ã€èªè­‰å¾Œç«¯ç­‰é—œéµé…ç½®ã€‚ç‰¹åˆ¥åœ°ï¼Œæˆ‘å€‘åœ¨æ­¤æ–‡ä»¶ä¸­é…ç½®äº† AI æ¨¡å‹è·¯å¾‘å’Œç›¸é—œåƒæ•¸ã€‚
- **urls.py**ï¼šå¯¦ç¾äº† URL è·¯ç”±ç³»çµ±ï¼Œå°‡è«‹æ±‚åˆ†ç™¼åˆ°é©ç•¶çš„è¦–åœ–å‡½æ•¸ã€‚åŒ…å«ä¸»è¦è·¯ç”±å’Œå° base æ‡‰ç”¨çš„è·¯ç”±åŒ…å«ã€‚
- **wsgi.py** å’Œ **asgi.py**ï¼šåˆ†åˆ¥æä¾›äº†åŒæ­¥å’Œç•°æ­¥çš„æ‡‰ç”¨æœå‹™å™¨æ¥å£ï¼Œæ”¯æŒä¸åŒéƒ¨ç½²å ´æ™¯çš„éœ€æ±‚ã€‚

- **settings.py**: Defines key configurations such as database connections, static file paths, installed applications, middleware, authentication backends, etc. Specifically, we configure AI model paths and related parameters in this file.
- **urls.py**: Implements the URL routing system, dispatching requests to appropriate view functions. Includes main routes and route inclusions for the base application.
- **wsgi.py** and **asgi.py**: Provide synchronous and asynchronous application server interfaces respectively, supporting the needs of different deployment scenarios.

#### 5.1.3 ä¸»è¦æ‡‰ç”¨æ¨¡çµ„ (Main Application Module)

```
â”œâ”€â”€ base/               # ä¸»è¦æ‡‰ç”¨æ¨¡çµ„
â”‚   â”œâ”€â”€ models.py       # æ•¸æ“šæ¨¡å‹å®šç¾©
â”‚   â”œâ”€â”€ views.py        # è¦–åœ–é‚è¼¯
â”‚   â”œâ”€â”€ urls.py         # æ‡‰ç”¨ URL é…ç½®
â”‚   â”œâ”€â”€ forms.py        # è¡¨å–®å®šç¾©
â”‚   â”œâ”€â”€ admin.py        # ç®¡ç†ä»‹é¢é…ç½®
â”‚   â””â”€â”€ templates/      # HTML æ¨¡æ¿
```

ã€Œbaseã€æ‡‰ç”¨æ˜¯ç³»çµ±çš„æ ¸å¿ƒåŠŸèƒ½æ¨¡çµ„ï¼Œå¯¦ç¾äº†æ‰€æœ‰æ¥­å‹™é‚è¼¯ï¼š

The "base" application is the core functional module of the system, implementing all business logic:

- **models.py**ï¼šå®šç¾©äº†æ•¸æ“šæ¨¡å‹ï¼ŒåŒ…æ‹¬ç”¨æˆ¶æ“´å±•æ¨¡å‹ã€å¥åº·è¨˜éŒ„æ¨¡å‹å’Œé ç´„æ¨¡å‹ï¼Œå»ºç«‹äº†ç³»çµ±çš„æ•¸æ“šçµæ§‹åŸºç¤ã€‚
- **views.py**ï¼šåŒ…å«æ‰€æœ‰è¦–åœ–å‡½æ•¸ï¼Œè™•ç† HTTP è«‹æ±‚ä¸¦è¿”å›éŸ¿æ‡‰ã€‚ç‰¹åˆ¥åœ°ï¼Œé€™è£¡å¯¦ç¾äº† AI æ¨¡å‹çš„èª¿ç”¨é‚è¼¯å’Œçµæœè™•ç†ã€‚
- **urls.py**ï¼šå®šç¾©äº†æ‡‰ç”¨ç´šåˆ¥çš„ URL è·¯ç”±ï¼Œå°‡è«‹æ±‚æ˜ å°„åˆ°å…·é«”è¦–åœ–å‡½æ•¸ã€‚
- **forms.py**ï¼šå®šç¾©äº†è¡¨å–®é¡ï¼Œè™•ç†ç”¨æˆ¶è¼¸å…¥é©—è­‰å’Œæ•¸æ“šé è™•ç†ã€‚
- **admin.py**ï¼šé…ç½®äº† Django ç®¡ç†ç•Œé¢ï¼Œæ–¹ä¾¿ç®¡ç†å“¡ç®¡ç†ç³»çµ±æ•¸æ“šã€‚
- **templates/**ï¼šåŒ…å«æ‰€æœ‰ HTML æ¨¡æ¿ï¼Œå¯¦ç¾äº†å‰ç«¯é é¢çš„çµæ§‹å’Œå¸ƒå±€ã€‚

- **models.py**: Defines data models, including user extension model, health record model, and appointment model, establishing the data structure foundation of the system.
- **views.py**: Contains all view functions, handling HTTP requests and returning responses. Specifically, it implements the calling logic and result processing of AI models.
- **urls.py**: Defines application-level URL routing, mapping requests to specific view functions.
- **forms.py**: Defines form classes, handling user input validation and data preprocessing.
- **admin.py**: Configures the Django admin interface, facilitating administrators to manage system data.
- **templates/**: Contains all HTML templates, implementing the structure and layout of frontend pages.

#### 5.1.4 éœæ…‹è³‡æºèˆ‡åª’é«”æ–‡ä»¶ (Static Resources and Media Files)

```
â”œâ”€â”€ static/             # éœæ…‹æª”æ¡ˆ
â”‚   â”œâ”€â”€ styles/         # CSS æ¨£å¼
â”‚   â”œâ”€â”€ js/             # JavaScript
â”‚   â””â”€â”€ images/         # åœ–ç‰‡è³‡æº
â”œâ”€â”€ media/              # ç”¨æˆ¶ä¸Šå‚³æª”æ¡ˆ
```

éœæ…‹è³‡æºå’Œåª’é«”æ–‡ä»¶ç›®éŒ„åˆ†åˆ¥å­˜å„²äº†ç³»çµ±çš„å›ºå®šè³‡æºå’Œç”¨æˆ¶ç”Ÿæˆå…§å®¹ï¼š

Static resources and media file directories store the system's fixed resources and user-generated content respectively:

- **static/**ï¼šåŒ…å«æ‰€æœ‰é å®šç¾©çš„éœæ…‹è³‡æºï¼Œå¦‚ CSS æ¨£å¼è¡¨ã€JavaScript è…³æœ¬å’Œåœ–ç‰‡è³‡æºã€‚é€™äº›æ–‡ä»¶åœ¨éƒ¨ç½²æ™‚æœƒè¢«æ”¶é›†åˆ°çµ±ä¸€ä½ç½®ï¼Œæé«˜è¨ªå•æ•ˆç‡ã€‚
- **media/**ï¼šå­˜å„²ç”¨æˆ¶ä¸Šå‚³çš„æ–‡ä»¶ï¼Œå¦‚å¥åº·æª¢æ¸¬çš„åœ–ç‰‡ã€‚ç³»çµ±æœƒè‡ªå‹•ç®¡ç†é€™äº›æ–‡ä»¶çš„å­˜å„²å’Œè¨ªå•æ¬Šé™ã€‚

- **static/**: Contains all predefined static resources, such as CSS stylesheets, JavaScript scripts, and image resources. These files are collected to a unified location during deployment to improve access efficiency.
- **media/**: Stores user-uploaded files, such as health detection images. The system automatically manages the storage and access permissions of these files.

#### 5.1.5 AI æ¨¡å‹èˆ‡ç®¡ç†è…³æœ¬ (AI Models and Management Script)

```
â”œâ”€â”€ AIModels/           # AI æ¨¡å‹æª”æ¡ˆ
â””â”€â”€ manage.py           # Django ç®¡ç†è…³æœ¬
```

- **AIModels/**ï¼šå­˜å„²äº†ç³»çµ±ä½¿ç”¨çš„æ‰€æœ‰ AI æ¨¡å‹æ–‡ä»¶ï¼ŒåŒ…æ‹¬ YOLO æ¨¡å‹æ¬Šé‡å’Œé…ç½®æ–‡ä»¶ã€‚é€™äº›æ¨¡å‹åœ¨ç³»çµ±å•Ÿå‹•æ™‚è¢«åŠ è¼‰åˆ°å…§å­˜ä¸­ï¼Œä»¥æä¾›å³æ™‚çš„å¥åº·æª¢æ¸¬æœå‹™ã€‚
- **manage.py**ï¼šDjango çš„å‘½ä»¤è¡Œå·¥å…·ï¼Œæä¾›äº†å„ç¨®ç®¡ç†å‘½ä»¤ï¼Œå¦‚å•Ÿå‹•é–‹ç™¼æœå‹™å™¨ã€å‰µå»ºæ•¸æ“šåº«é·ç§»ã€æ‡‰ç”¨é·ç§»ç­‰ã€‚

- **AIModels/**: Stores all AI model files used by the system, including YOLO model weights and configuration files. These models are loaded into memory when the system starts to provide real-time health detection services.
- **manage.py**: Django's command-line tool, providing various management commands such as starting the development server, creating database migrations, applying migrations, etc.

### 5.2 ç³»çµ±æ ¸å¿ƒåŠŸèƒ½å¯¦ç¾ (Implementation of System Core Functions)

æœ¬ç¯€è©³ç´°ä»‹ç´¹ Health Mirror ç³»çµ±çš„æ ¸å¿ƒåŠŸèƒ½å¯¦ç¾ï¼ŒåŒ…æ‹¬ç”¨æˆ¶èªè­‰èˆ‡æˆæ¬Šã€AI æ¨¡å‹æ•´åˆèˆ‡å¥åº·æª¢æ¸¬ã€å¥åº·æ•¸æ“šå¯è¦–åŒ–ç­‰é—œéµæŠ€è¡“é»ã€‚ç³»çµ±æ¡ç”¨åˆ†å±¤æ¶æ§‹è¨­è¨ˆï¼Œå°‡è¡¨ç¤ºå±¤ã€æ¥­å‹™é‚è¼¯å±¤å’Œæ•¸æ“šè¨ªå•å±¤æ¸…æ™°åˆ†é›¢ï¼Œç¢ºä¿ä»£ç¢¼çš„å¯ç¶­è­·æ€§å’Œå¯æ“´å±•æ€§ã€‚åŒæ™‚ï¼Œæˆ‘å€‘å¯¦æ–½äº†å®Œæ•´çš„éŒ¯èª¤è™•ç†å’Œæ—¥èªŒè¨˜éŒ„æ©Ÿåˆ¶ï¼Œä»¥æé«˜ç³»çµ±çš„ç©©å®šæ€§å’Œå¯è¿½æº¯æ€§ã€‚

This section details the implementation of the core functions of the Health Mirror system, including user authentication and authorization, AI model integration and health detection, health data visualization, and other key technical points. The system adopts a layered architectural design, clearly separating the presentation layer, business logic layer, and data access layer to ensure code maintainability and scalability. Additionally, we have implemented comprehensive error handling and logging mechanisms to enhance system stability and traceability.

#### 5.2.1 ç”¨æˆ¶èªè­‰èˆ‡æˆæ¬Š (User Authentication and Authorization)

Health Mirror ç³»çµ±å¯¦ç¾äº†å®Œæ•´çš„ç”¨æˆ¶èªè­‰å’Œæˆæ¬Šæ©Ÿåˆ¶ï¼Œç¢ºä¿ç”¨æˆ¶æ•¸æ“šçš„å®‰å…¨æ€§å’Œéš±ç§æ€§ã€‚æˆ‘å€‘æ“´å±•äº† Django çš„å…§ç½®ç”¨æˆ¶æ¨¡å‹ï¼Œæ·»åŠ äº†å¥åº·ç›¸é—œçš„å€‹äººè³‡æ–™å­—æ®µï¼Œä¸¦å¯¦æ–½äº†åŸºæ–¼è§’è‰²çš„è¨ªå•æ§åˆ¶ç³»çµ±ï¼Œå€åˆ†æ™®é€šç”¨æˆ¶ã€é†«ç™‚å°ˆæ¥­äººå“¡å’Œç³»çµ±ç®¡ç†å“¡çš„æ¬Šé™ç¯„åœï¼š

The Health Mirror system implements a complete user authentication and authorization mechanism to ensure the security and privacy of user data. We extended Django's built-in user model by adding health-related profile fields and implemented a role-based access control system that differentiates permission scopes for regular users, healthcare professionals, and system administrators:

```python
# base/models.py - æ“´å±•ç”¨æˆ¶æ¨¡å‹
from django.contrib.auth.models import User
from django.db import models

class UserProfile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='profile')
    date_of_birth = models.DateField(null=True, blank=True)
    gender = models.CharField(max_length=10, choices=[
        ('male', 'ç”·æ€§'),
        ('female', 'å¥³æ€§'),
        ('other', 'å…¶ä»–')
    ])
    phone_number = models.CharField(max_length=15, blank=True)
    medical_history = models.TextField(blank=True)
    role = models.CharField(max_length=20, choices=[
        ('user', 'æ™®é€šç”¨æˆ¶'),
        ('doctor', 'é†«ç™‚å°ˆæ¥­äººå“¡'),
        ('admin', 'ç³»çµ±ç®¡ç†å“¡')
    ], default='user')
    last_health_check = models.DateTimeField(null=True, blank=True)
    
    def __str__(self):
        return f"{self.user.username}'s Profile"

# base/views.py - èªè­‰èˆ‡æˆæ¬Šå¯¦ç¾
from django.contrib.auth import authenticate, login, logout
from django.contrib.auth.decorators import login_required, user_passes_test
from django.contrib import messages
from django.shortcuts import render, redirect, get_object_or_404
from .models import UserProfile, HealthRecord

def login_view(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        user = authenticate(request, username=username, password=password)
        
        if user is not None:
            login(request, user)
            # è¨˜éŒ„ç™»éŒ„æ´»å‹•
            from django.utils import timezone
            user.last_login = timezone.now()
            user.save()
            
            # æ ¹æ“šç”¨æˆ¶è§’è‰²é‡å®šå‘åˆ°ä¸åŒé é¢
            try:
                if user.profile.role == 'doctor':
                    return redirect('doctor_dashboard')
                elif user.profile.role == 'admin':
                    return redirect('admin_dashboard')
                else:
                    return redirect('home')
            except UserProfile.DoesNotExist:
                # å¦‚æœç”¨æˆ¶æ²’æœ‰é—œè¯çš„å€‹äººè³‡æ–™ï¼Œå‰µå»ºä¸€å€‹é»˜èªçš„
                UserProfile.objects.create(user=user, role='user')
                return redirect('home')
        else:
            messages.error(request, 'ç”¨æˆ¶åæˆ–å¯†ç¢¼éŒ¯èª¤')
    
    return render(request, 'base/login.html')

def logout_view(request):
    logout(request)
    return redirect('login')

@login_required
def home_view(request):
    # åªæœ‰ç™»éŒ„ç”¨æˆ¶æ‰èƒ½è¨ªå•
    return render(request, 'base/home.html')
```

ç³»çµ±ä½¿ç”¨ Django å…§ç½®çš„èªè­‰ç³»çµ±ï¼Œä¸¦é€šéè£é£¾å™¨ `@login_required` é™åˆ¶æœªèªè­‰ç”¨æˆ¶å°æ•æ„Ÿé é¢çš„è¨ªå•ã€‚æ­¤å¤–ï¼Œæˆ‘å€‘å¯¦ç¾äº†è‡ªå®šç¾©çš„ç”¨æˆ¶æ¨¡å‹ï¼Œæ“´å±•äº†æ¨™æº–ç”¨æˆ¶å­—æ®µä»¥æ»¿è¶³å¥åº·ç›£æ¸¬çš„ç‰¹å®šéœ€æ±‚ã€‚ç³»çµ±é‚„å¯¦æ–½äº†åŸºæ–¼è§’è‰²çš„è¨ªå•æ§åˆ¶ï¼Œé€šéä»¥ä¸‹æ–¹å¼å¯¦ç¾ï¼š

The system uses Django's built-in authentication system and restricts unauthenticated users' access to sensitive pages through the `@login_required` decorator. Additionally, we implemented a custom user model, extending standard user fields to meet the specific requirements of health monitoring. The system also implements role-based access control through the following methods:

```python
# åŸºæ–¼è§’è‰²çš„è¨ªå•æ§åˆ¶è£é£¾å™¨
def doctor_required(function):
    actual_decorator = user_passes_test(
        lambda u: hasattr(u, 'profile') and u.profile.role in ['doctor', 'admin']
    )
    return actual_decorator(function)

def admin_required(function):
    actual_decorator = user_passes_test(
        lambda u: hasattr(u, 'profile') and u.profile.role == 'admin'
    )
    return actual_decorator(function)

# ä½¿ç”¨è£é£¾å™¨é™åˆ¶è¨ªå•
@doctor_required
def doctor_dashboard(request):
    # åªæœ‰é†«ç”Ÿå’Œç®¡ç†å“¡å¯ä»¥è¨ªå•
    patients = User.objects.filter(profile__role='user')
    return render(request, 'base/doctor_dashboard.html', {'patients': patients})

@admin_required
def system_settings(request):
    # åªæœ‰ç®¡ç†å“¡å¯ä»¥è¨ªå•
    return render(request, 'base/system_settings.html')
```

#### 5.2.2 AI æ¨¡å‹æ•´åˆèˆ‡å¥åº·æª¢æ¸¬ (AI Model Integration and Health Detection)

ç³»çµ±çš„æ ¸å¿ƒåŠŸèƒ½æ˜¯ AI é©…å‹•çš„å¥åº·æª¢æ¸¬ï¼Œé€™éƒ¨åˆ†é€šéåœ¨ Django è¦–åœ–ä¸­æ•´åˆ YOLO æ¨¡å‹å¯¦ç¾ã€‚æˆ‘å€‘æ¡ç”¨äº†æ¨¡å‹é åŠ è¼‰ç­–ç•¥ï¼Œåœ¨æ‡‰ç”¨å•Ÿå‹•æ™‚å°‡æ¨¡å‹è¼‰å…¥å…§å­˜ï¼Œä»¥æ¸›å°‘æª¢æ¸¬æ™‚çš„å»¶é²ã€‚åŒæ™‚ï¼Œæˆ‘å€‘å¯¦ç¾äº†ç•°æ­¥è™•ç†æ©Ÿåˆ¶ï¼Œä½¿é•·æ™‚é–“é‹è¡Œçš„ AI æ¨ç†ä¸æœƒé˜»å¡ Web æœå‹™å™¨ï¼š

The core function of the system is AI-driven health detection, which is implemented by integrating YOLO models in Django views. We adopted a model pre-loading strategy, loading models into memory when the application starts to reduce detection latency. At the same time, we implemented an asynchronous processing mechanism so that long-running AI inference does not block the web server:

```python
# base/apps.py - åœ¨æ‡‰ç”¨å•Ÿå‹•æ™‚é åŠ è¼‰æ¨¡å‹
from django.apps import AppConfig
import os

class BaseConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'base'
    
    def ready(self):
        # åœ¨æ‡‰ç”¨å•Ÿå‹•æ™‚é åŠ è¼‰ AI æ¨¡å‹
        from django.conf import settings
        from ultralytics import YOLO
        import threading
        
        # ä½¿ç”¨ç·šç¨‹æ± é€²è¡Œæ¨¡å‹åŠ è¼‰ï¼Œé¿å…é˜»å¡æ‡‰ç”¨å•Ÿå‹•
        def load_models():
            from .models import AIModel
            # æ¸…é™¤èˆŠæ¨¡å‹è¨˜éŒ„
            AIModel.objects.all().delete()
            
            # åŠ è¼‰ä¸¦ä¿å­˜æ¨¡å‹å¼•ç”¨
            models = {
                'dark_circles': YOLO(os.path.join(settings.BASE_DIR, 'AIModels/DarkCircles.pt')),
                'lip': YOLO(os.path.join(settings.BASE_DIR, 'AIModels/Lip_types.pt')),
                'skin': YOLO(os.path.join(settings.BASE_DIR, 'AIModels/skin.pt')),
                'health': YOLO(os.path.join(settings.BASE_DIR, 'AIModels/health.pt'))
            }
            
            # å°‡æ¨¡å‹å¼•ç”¨ä¿å­˜åˆ°æ•¸æ“šåº«ï¼Œæ–¹ä¾¿åœ¨è¦–åœ–ä¸­è¨ªå•
            for name, model in models.items():
                AIModel.objects.create(name=name, model_instance=model)
                print(f"Model {name} loaded successfully")
        
        # ä½¿ç”¨ç·šç¨‹ç•°æ­¥åŠ è¼‰æ¨¡å‹ï¼Œé¿å…é˜»å¡æ‡‰ç”¨å•Ÿå‹•
        if not settings.TESTING:  # æ¸¬è©¦ç’°å¢ƒä¸‹ä¸åŠ è¼‰æ¨¡å‹
            thread = threading.Thread(target=load_models)
            thread.daemon = True
            thread.start()

# base/models.py - AIæ¨¡å‹å­˜å„²
class AIModel(models.Model):
    name = models.CharField(max_length=50, unique=True)
    model_path = models.CharField(max_length=255)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    # éæŒä¹…åŒ–å­—æ®µï¼Œç”¨æ–¼å­˜å„²æ¨¡å‹å¯¦ä¾‹
    model_instance = None
    
    def __str__(self):
        return f"AI Model: {self.name}"

# base/tasks.py - ç•°æ­¥ä»»å‹™è™•ç†
from celery import shared_task
import cv2
import numpy as np
import os
from django.conf import settings
from .models import HealthRecord, AIModel

@shared_task
def process_health_detection(user_id, image_path):
    """ç•°æ­¥è™•ç†å¥åº·æª¢æ¸¬ä»»å‹™"""
    from django.contrib.auth.models import User
    
    # ç²å–ç”¨æˆ¶
    user = User.objects.get(id=user_id)
    
    # è®€å–åœ–ç‰‡ä¸¦é€²è¡Œé è™•ç†
    img = cv2.imread(image_path)
    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    
    # ç²å–æ¨¡å‹å¯¦ä¾‹
    models = {model.name: model.model_instance for model in AIModel.objects.all()}
    
    # ä½¿ç”¨ AI æ¨¡å‹é€²è¡Œæª¢æ¸¬
    dark_circles_results = models['dark_circles'](img_rgb)
    lip_results = models['lip'](img_rgb)
    skin_results = models['skin'](img_rgb)
    health_results = models['health'](img_rgb)
    
    # è™•ç†æª¢æ¸¬çµæœ
    dark_circles_score = process_dark_circles(dark_circles_results)
    lip_condition = process_lip_condition(lip_results)
    skin_analysis = process_skin_analysis(skin_results)
    overall_health = process_overall_health(health_results)
    
    # ä¿å­˜æª¢æ¸¬è¨˜éŒ„
    record = HealthRecord.objects.create(
        user=user,
        image_path=image_path,
        detection_results={
            'dark_circles': dark_circles_results.tolist(),
            'lip': lip_results.tolist(),
            'skin': skin_results.tolist(),
            'health': health_results.tolist()
        },
        dark_circles_score=dark_circles_score,
        lip_condition=lip_condition,
        skin_analysis=skin_analysis,
        overall_health_score=overall_health
    )
    
    # è¿”å›çµæœIDï¼Œå‰ç«¯å¯ä»¥é€šéè¼ªè©¢ç²å–çµæœ
    return record.id

# base/views.py - å¥åº·æª¢æ¸¬è¦–åœ–
from django.http import JsonResponse
from django.contrib.auth.decorators import login_required
from .tasks import process_health_detection
import os

@login_required
def detect_health(request):
    """è™•ç†å¥åº·æª¢æ¸¬è«‹æ±‚ï¼Œä½¿ç”¨ç•°æ­¥ä»»å‹™é€²è¡Œè™•ç†"""
    if request.method == 'POST' and request.FILES.get('image'):
        # è™•ç†ä¸Šå‚³çš„åœ–ç‰‡
        image_file = request.FILES['image']
        image_path = os.path.join(settings.MEDIA_ROOT, 'temp', image_file.name)
        
        # ç¢ºä¿ç›®éŒ„å­˜åœ¨
        os.makedirs(os.path.dirname(image_path), exist_ok=True)
        
        with open(image_path, 'wb+') as destination:
            for chunk in image_file.chunks():
                destination.write(chunk)
        
        # å•Ÿå‹•ç•°æ­¥ä»»å‹™è™•ç†
        task = process_health_detection.delay(request.user.id, image_path)
        
        return JsonResponse({
            'success': True,
            'task_id': task.id,
            'message': 'å¥åº·æª¢æ¸¬æ­£åœ¨è™•ç†ä¸­ï¼Œè«‹ç¨å¾ŒæŸ¥çœ‹çµæœ'
        })
    
    return JsonResponse({'success': False, 'message': 'è«‹ä¸Šå‚³æœ‰æ•ˆçš„åœ–ç‰‡'})

@login_required
def get_detection_result(request, task_id):
    """ç²å–ç•°æ­¥ä»»å‹™çš„è™•ç†çµæœ"""
    from celery.result import AsyncResult
    
    result = AsyncResult(task_id)
    
    if result.ready():
        record_id = result.get()
        record = HealthRecord.objects.get(id=record_id)
        
        return JsonResponse({
            'success': True,
            'status': 'completed',
            'dark_circles_score': record.dark_circles_score,
            'lip_condition': record.lip_condition,
            'skin_analysis': skin_analysis,
            'overall_health': overall_health
        })
    
    return JsonResponse({'success': False, 'error': 'ç„¡æ•ˆçš„è«‹æ±‚'})
```

é€™æ®µä»£ç¢¼å±•ç¤ºäº†ç³»çµ±å¦‚ä½•åŠ è¼‰ AI æ¨¡å‹ã€è™•ç†ä¸Šå‚³çš„åœ–ç‰‡ã€åŸ·è¡Œå¥åº·æª¢æ¸¬ä¸¦ä¿å­˜çµæœã€‚ç³»çµ±ä½¿ç”¨ Ultralytics çš„ YOLO å¯¦ç¾ï¼Œçµåˆ OpenCV é€²è¡Œåœ–åƒè™•ç†ï¼Œå¯¦ç¾äº†é«˜æ•ˆçš„å¥åº·ç‰¹å¾µæª¢æ¸¬ã€‚

This code demonstrates how the system loads AI models, processes uploaded images, performs health detection, and saves results. The system uses Ultralytics' YOLO implementation combined with OpenCV for image processing, achieving efficient health feature detection.

#### 5.2.3 å¥åº·æ•¸æ“šå¯è¦–åŒ– (Health Data Visualization)

ç³»çµ±é€šé JavaScript å’Œ Chart.js å¯¦ç¾äº†å¥åº·æ•¸æ“šçš„å¯è¦–åŒ–ï¼Œç‚ºç”¨æˆ¶æä¾›ç›´è§€çš„å¥åº·è¶¨å‹¢åˆ†æã€‚æˆ‘å€‘è¨­è¨ˆäº†éŸ¿æ‡‰å¼åœ–è¡¨ç³»çµ±ï¼Œèƒ½å¤ è‡ªå‹•é©æ‡‰ä¸åŒè¨­å‚™çš„å±å¹•å°ºå¯¸ï¼Œä¸¦å¯¦ç¾äº†å¯¦æ™‚æ•¸æ“šæ›´æ–°æ©Ÿåˆ¶ï¼Œç¢ºä¿ç”¨æˆ¶å§‹çµ‚çœ‹åˆ°æœ€æ–°çš„å¥åº·ç‹€æ³ï¼š

The system implements health data visualization through JavaScript and Chart.js, providing users with intuitive health trend analysis. We designed a responsive chart system that automatically adapts to different device screen sizes and implemented a real-time data update mechanism to ensure users always see the latest health status:

```javascript
// static/js/chart.js - å¥åº·æ•¸æ“šå¯è¦–åŒ–èˆ‡å¯¦æ™‚æ›´æ–°

// å…¨å±€è®Šé‡å­˜å„²åœ–è¡¨å¯¦ä¾‹ï¼Œä¾¿æ–¼æ›´æ–°
let healthLineChart = null;
let skinLineChart = null;

// åˆå§‹åŒ–åœ–è¡¨ä¸¦è¨­ç½®è‡ªå‹•åˆ·æ–°
function initCharts() {
    // åˆå§‹åŠ è¼‰åœ–è¡¨æ•¸æ“š
    loadChartData3();
    loadSkinChartData();
    
    // è¨­ç½®å®šæ™‚åˆ·æ–° - æ¯60ç§’æ›´æ–°ä¸€æ¬¡æ•¸æ“š
    setInterval(() => {
        updateCharts();
    }, 60000);
    
    // æ·»åŠ çª—å£å¤§å°è®ŠåŒ–ç›£è½å™¨ï¼Œå¯¦ç¾éŸ¿æ‡‰å¼è¨­è¨ˆ
    window.addEventListener('resize', () => {
        if (healthLineChart) healthLineChart.resize();
        if (skinLineChart) skinLineChart.resize();
    });
}

// æ›´æ–°æ‰€æœ‰åœ–è¡¨æ•¸æ“š
function updateCharts() {
    console.log('Updating charts with latest data...');
    // ä½¿ç”¨å¸¶æœ‰ç·©å­˜ç ´å£åƒæ•¸çš„APIèª¿ç”¨ï¼Œç¢ºä¿ç²å–æœ€æ–°æ•¸æ“š
    fetch(`/api/health-stats/?_=${new Date().getTime()}`)
        .then(response => response.json())
        .then(data => {
            // æ›´æ–°ç¾æœ‰åœ–è¡¨è€Œä¸æ˜¯é‡æ–°å‰µå»º
            if (healthLineChart) {
                healthLineChart.data.labels = data.dates;
                healthLineChart.data.datasets[0].data = data.dark_circles_scores;
                healthLineChart.data.datasets[1].data = data.lip_issues;
                healthLineChart.update('none'); // ä½¿ç”¨'none'æ¨¡å¼é¿å…å‹•ç•«é‡æ’­
            }
            
            if (skinLineChart) {
                skinLineChart.data.labels = data.dates;
                skinLineChart.data.datasets[0].data = data.acne_scores;
                skinLineChart.data.datasets[1].data = data.dry_skin_scores;
                skinLineChart.data.datasets[2].data = data.oily_skin_scores;
                skinLineChart.data.datasets[3].data = data.sensitive_skin_scores;
                skinLineChart.update('none');
            }
        })
        .catch(error => console.error('Error updating charts:', error));
}

// å¥åº·å•é¡Œè¶¨å‹¢åœ–è¡¨
function loadChartData3() {
    fetch('/api/health-stats/')
        .then(response => response.json())
        .then(data => {
            const ctx = document.getElementById('lineChart').getContext('2d');
            
            // å‰µå»ºæ¼¸è®ŠèƒŒæ™¯
            const gradientFill1 = ctx.createLinearGradient(0, 0, 0, 400);
            gradientFill1.addColorStop(0, 'rgba(75, 192, 192, 0.6)');
            gradientFill1.addColorStop(0.7, 'rgba(75, 192, 192, 0.1)');
            
            const gradientFill2 = ctx.createLinearGradient(0, 0, 0, 400);
            gradientFill2.addColorStop(0, 'rgba(255, 99, 132, 0.6)');
            gradientFill2.addColorStop(0.7, 'rgba(255, 99, 132, 0.1)');
            
            // éŠ·æ¯€ç¾æœ‰åœ–è¡¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            if (healthLineChart) healthLineChart.destroy();
            
            // å‰µå»ºæ–°åœ–è¡¨
            healthLineChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.dates,
                    datasets: [
                        {
                            label: 'é»‘çœ¼åœˆæŒ‡æ•¸',
                            data: data.dark_circles_scores,
                            borderColor: 'rgba(75, 192, 192, 1)',
                            backgroundColor: gradientFill1,
                            tension: 0.4,
                            fill: true,
                            pointBackgroundColor: 'rgba(75, 192, 192, 1)',
                            pointBorderColor: '#fff',
                            pointHoverBackgroundColor: '#fff',
                            pointHoverBorderColor: 'rgba(75, 192, 192, 1)'
                        },
                        {
                            label: 'å”‡éƒ¨å•é¡Œ',
                            data: data.lip_issues,
                            borderColor: 'rgba(255, 99, 132, 1)',
                            backgroundColor: gradientFill2,
                            tension: 0.4,
                            fill: true,
                            pointBackgroundColor: 'rgba(255, 99, 132, 1)',
                            pointBorderColor: '#fff',
                            pointHoverBackgroundColor: '#fff',
                            pointHoverBorderColor: 'rgba(255, 99, 132, 1)'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'å¥åº·å•é¡Œè¶¨å‹¢',
                            font: {
                                size: 16,
                                weight: 'bold'
                            }
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 20
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += Math.round(context.parsed.y * 10) / 10;
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: {
                                drawBorder: false,
                                color: 'rgba(200, 200, 200, 0.15)'
                            },
                            ticks: {
                                font: {
                                    size: 12
                                }
                            }
                        },
                        x: {
                            grid: {
                                drawBorder: false,
                                color: 'rgba(200, 200, 200, 0.15)'
                            },
                            ticks: {
                                font: {
                                    size: 12
                                }
                            }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'nearest'
                    },
                    animation: {
                        duration: 1000,
                        easing: 'easeOutQuart'
                    }
                }
            });
        })
        .catch(error => console.error('Error loading health chart data:', error));
}

// çš®è†šå¥åº·è¶¨å‹¢åœ–è¡¨
function loadSkinChartData() {
    fetch('/api/skin-health-stats/')
        .then(response => response.json())
        .then(data => {
            const ctx = document.getElementById('skinChart').getContext('2d');
            
            // å‰µå»ºæ¼¸è®ŠèƒŒæ™¯
            const gradients = [
                createGradient(ctx, 'rgba(54, 162, 235, 1)'),  // ç—˜ç—˜å•é¡Œ
                createGradient(ctx, 'rgba(255, 206, 86, 1)'),  // ä¹¾ç‡¥å•é¡Œ
                createGradient(ctx, 'rgba(75, 192, 192, 1)'),  // æ²¹æ€§å•é¡Œ
                createGradient(ctx, 'rgba(153, 102, 255, 1)')  // æ•æ„Ÿå•é¡Œ
            ];
            
            // éŠ·æ¯€ç¾æœ‰åœ–è¡¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            if (skinLineChart) skinLineChart.destroy();
            
            // å‰µå»ºæ–°åœ–è¡¨
            skinLineChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.dates,
                    datasets: [
                        createDataset('ç—˜ç—˜å•é¡Œ', data.acne_scores, 'rgba(54, 162, 235, 1)', gradients[0]),
                        createDataset('ä¹¾ç‡¥å•é¡Œ', data.dry_skin_scores, 'rgba(255, 206, 86, 1)', gradients[1]),
                        createDataset('æ²¹æ€§å•é¡Œ', data.oily_skin_scores, 'rgba(75, 192, 192, 1)', gradients[2]),
                        createDataset('æ•æ„Ÿå•é¡Œ', data.sensitive_skin_scores, 'rgba(153, 102, 255, 1)', gradients[3])
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'çš®è†šå¥åº·è¶¨å‹¢',
                            font: {
                                size: 16,
                                weight: 'bold'
                            }
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 20
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += Math.round(context.parsed.y * 10) / 10;
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: {
                                drawBorder: false,
                                color: 'rgba(200, 200, 200, 0.15)'
                            }
                        },
                        x: {
                            grid: {
                                drawBorder: false,
                                color: 'rgba(200, 200, 200, 0.15)'
                            }
                        }
                    },
                    interaction: {
                        intersect: false,
                        mode: 'nearest'
                    }
                }
            });
        })
        .catch(error => console.error('Error loading skin chart data:', error));
}

// è¼”åŠ©å‡½æ•¸ - å‰µå»ºæ¼¸è®ŠèƒŒæ™¯
function createGradient(ctx, color) {
    const gradient = ctx.createLinearGradient(0, 0, 0, 400);
    // å¾é¡è‰²çš„RGBå€¼å‰µå»ºåŠé€æ˜ç‰ˆæœ¬
    const rgbValues = color.match(/\d+/g);
    gradient.addColorStop(0, color.replace('1)', '0.6)'));
    gradient.addColorStop(0.7, color.replace('1)', '0.1)'));
    return gradient;
}

// è¼”åŠ©å‡½æ•¸ - å‰µå»ºæ•¸æ“šé›†é…ç½®
function createDataset(label, data, color, gradient) {
    return {
        label: label,
        data: data,
        borderColor: color,
        backgroundColor: gradient,
        tension: 0.4,
        fill: true,
        pointBackgroundColor: color,
        pointBorderColor: '#fff',
        pointHoverBackgroundColor: '#fff',
        pointHoverBorderColor: color,
        borderWidth: 2
    };
}
```

å¾Œç«¯APIå¯¦ç¾ï¼š

```python
# base/views.py (APIéƒ¨åˆ†)

from django.http import JsonResponse
from django.db.models import Avg
from django.db.models.functions import TruncDate
from .models import HealthDetection
import json

@login_required
def health_stats_api(request):
    """æä¾›å¥åº·çµ±è¨ˆæ•¸æ“šAPIï¼Œç”¨æ–¼å‰ç«¯åœ–è¡¨é¡¯ç¤º"""
    # ç²å–ç”¨æˆ¶æœ€è¿‘30å¤©çš„å¥åº·æª¢æ¸¬æ•¸æ“š
    user_detections = HealthDetection.objects.filter(
        user=request.user,
        created_at__gte=timezone.now() - timezone.timedelta(days=30)
    ).annotate(
        date=TruncDate('created_at')
    ).values('date').annotate(
        dark_circles_avg=Avg('dark_circles_score'),
        lip_issues_avg=Avg('lip_health_score')
    ).order_by('date')
    
    # æ ¼å¼åŒ–æ•¸æ“šç”¨æ–¼Chart.js
    dates = []
    dark_circles_scores = []
    lip_issues = []
    
    for detection in user_detections:
        dates.append(detection['date'].strftime('%Y-%m-%d'))
        dark_circles_scores.append(round(detection['dark_circles_avg'], 2))
        lip_issues.append(round(detection['lip_issues_avg'], 2))
    
    return JsonResponse({
        'dates': dates,
        'dark_circles_scores': dark_circles_scores,
        'lip_issues': lip_issues
    })

@login_required
def skin_health_stats_api(request):
    """æä¾›çš®è†šå¥åº·çµ±è¨ˆæ•¸æ“šAPIï¼Œç”¨æ–¼å‰ç«¯åœ–è¡¨é¡¯ç¤º"""
    # ç²å–ç”¨æˆ¶æœ€è¿‘30å¤©çš„çš®è†šå¥åº·æ•¸æ“š
    user_detections = HealthDetection.objects.filter(
        user=request.user,
        created_at__gte=timezone.now() - timezone.timedelta(days=30)
    ).annotate(
        date=TruncDate('created_at')
    ).values('date').annotate(
        acne_avg=Avg('acne_score'),
        dry_skin_avg=Avg('dry_skin_score'),
        oily_skin_avg=Avg('oily_skin_score'),
        sensitive_skin_avg=Avg('sensitive_skin_score')
    ).order_by('date')
    
    # æ ¼å¼åŒ–æ•¸æ“šç”¨æ–¼Chart.js
    dates = []
    acne_scores = []
    dry_skin_scores = []
    oily_skin_scores = []
    sensitive_skin_scores = []
    
    for detection in user_detections:
        dates.append(detection['date'].strftime('%Y-%m-%d'))
        acne_scores.append(round(detection['acne_avg'], 2))
        dry_skin_scores.append(round(detection['dry_skin_avg'], 2))
        oily_skin_scores.append(round(detection['oily_skin_avg'], 2))
        sensitive_skin_scores.append(round(detection['sensitive_skin_avg'], 2))
    
    return JsonResponse({
        'dates': dates,
        'acne_scores': acne_scores,
        'dry_skin_scores': dry_skin_scores,
        'oily_skin_scores': oily_skin_scores,
        'sensitive_skin_scores': sensitive_skin_scores
    })
```
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100
                        }
                    }
                }
            });
        });
}
```

é€™æ®µä»£ç¢¼å±•ç¤ºäº†ç³»çµ±å¦‚ä½•å¾å¾Œç«¯ API ç²å–å¥åº·æ•¸æ“šï¼Œä¸¦ä½¿ç”¨ Chart.js å‰µå»ºç·šæ€§åœ–è¡¨ä¾†å±•ç¤ºå¥åº·å•é¡Œçš„è¶¨å‹¢è®ŠåŒ–ã€‚ç³»çµ±é‚„å¯¦ç¾äº†å…¶ä»–é¡å‹çš„åœ–è¡¨ï¼Œå¦‚ç”œç”œåœˆåœ–å’Œæ—¥æ›†è¦–åœ–ï¼Œæä¾›å¤šç¶­åº¦çš„å¥åº·æ•¸æ“šåˆ†æã€‚

This code demonstrates how the system retrieves health data from the backend API and uses Chart.js to create line charts to show trends in health issues. The system also implements other types of charts, such as donut charts and calendar views, providing multi-dimensional health data analysis.

### 5.3 ç³»çµ±å®‰å…¨èˆ‡æ€§èƒ½å„ªåŒ– (System Security and Performance Optimization)

#### 5.3.1 å®‰å…¨æªæ–½å¯¦ç¾ (Security Measures Implementation)

Health Mirror ç³»çµ±å¯¦æ–½äº†å¤šå±¤æ¬¡çš„å®‰å…¨æªæ–½ï¼Œä¿è­·ç”¨æˆ¶æ•¸æ“šå’Œç³»çµ±å®Œæ•´æ€§ï¼š

The Health Mirror system implements multi-layered security measures to protect user data and system integrity:

1. **èªè­‰èˆ‡æˆæ¬Š**ï¼šä½¿ç”¨ Django çš„èªè­‰ç³»çµ±å’Œæ¬Šé™æ§åˆ¶ï¼Œç¢ºä¿åªæœ‰æˆæ¬Šç”¨æˆ¶èƒ½è¨ªå•æ•æ„Ÿè³‡æºã€‚
2. **CSRF ä¿è­·**ï¼šåœ¨æ‰€æœ‰è¡¨å–®ä¸­å¯¦æ–½ CSRF ä»¤ç‰Œï¼Œé˜²æ­¢è·¨ç«™è«‹æ±‚å½é€ æ”»æ“Šã€‚
3. **å¯†ç¢¼å“ˆå¸Œ**ï¼šä½¿ç”¨ PBKDF2 ç®—æ³•å’Œ SHA256 å“ˆå¸Œå‡½æ•¸å®‰å…¨å­˜å„²ç”¨æˆ¶å¯†ç¢¼ã€‚
4. **SQL æ³¨å…¥é˜²è­·**ï¼šä½¿ç”¨ Django ORM çš„åƒæ•¸åŒ–æŸ¥è©¢ï¼Œé˜²æ­¢ SQL æ³¨å…¥æ”»æ“Šã€‚
5. **XSS é˜²è­·**ï¼šåœ¨æ¨¡æ¿ä¸­è‡ªå‹•è½‰ç¾© HTML ç‰¹æ®Šå­—ç¬¦ï¼Œé˜²æ­¢è·¨ç«™è…³æœ¬æ”»æ“Šã€‚
6. **å®‰å…¨ HTTP é ­**ï¼šé…ç½®é©ç•¶çš„å®‰å…¨é ­ï¼Œå¦‚ Content-Security-Policy å’Œ X-XSS-Protectionã€‚

1. **Authentication and Authorization**: Using Django's authentication system and permission control to ensure that only authorized users can access sensitive resources.
2. **CSRF Protection**: Implementing CSRF tokens in all forms to prevent cross-site request forgery attacks.
3. **Password Hashing**: Securely storing user passwords using the PBKDF2 algorithm and SHA256 hash function.
4. **SQL Injection Protection**: Using Django ORM's parameterized queries to prevent SQL injection attacks.
5. **XSS Protection**: Automatically escaping HTML special characters in templates to prevent cross-site scripting attacks.
6. **Secure HTTP Headers**: Configuring appropriate security headers such as Content-Security-Policy and X-XSS-Protection.

#### 5.3.2 æ€§èƒ½å„ªåŒ–ç­–ç•¥ (Performance Optimization Strategies)

ç³»çµ±æ¡ç”¨äº†å¤šç¨®ç­–ç•¥å„ªåŒ–æ€§èƒ½ï¼Œæé«˜ç”¨æˆ¶é«”é©—ï¼š

The system adopts various strategies to optimize performance and improve user experience:

1. **æ•¸æ“šåº«å„ªåŒ–**ï¼š
   - ä½¿ç”¨é©ç•¶çš„ç´¢å¼•åŠ é€ŸæŸ¥è©¢
   - å¯¦æ–½æ•¸æ“šåº«é€£æ¥æ± ç®¡ç†
   - å„ªåŒ–æŸ¥è©¢èªå¥ï¼Œæ¸›å°‘ä¸å¿…è¦çš„é€£æ¥å’Œå­æŸ¥è©¢

2. **AI æ¨¡å‹å„ªåŒ–**ï¼š
   - ä½¿ç”¨ ONNX æ ¼å¼è½‰æ›æ¨¡å‹ï¼Œæé«˜æ¨ç†é€Ÿåº¦
   - å¯¦æ–½æ‰¹è™•ç†æ©Ÿåˆ¶ï¼Œæ¸›å°‘æ¨¡å‹åŠ è¼‰é–‹éŠ·
   - ä½¿ç”¨æ··åˆç²¾åº¦è¨ˆç®—ï¼Œåœ¨ä¿æŒæº–ç¢ºæ€§çš„åŒæ™‚æé«˜æ€§èƒ½

3. **å‰ç«¯å„ªåŒ–**ï¼š
   - ä½¿ç”¨ç€è¦½å™¨ç·©å­˜å’Œ CDN åŠ é€Ÿéœæ…‹è³‡æºåŠ è¼‰
   - å¯¦æ–½æ‡¶åŠ è¼‰å’Œä»£ç¢¼åˆ†å‰²ï¼Œæ¸›å°‘åˆå§‹åŠ è¼‰æ™‚é–“
   - ä½¿ç”¨ AJAX å’Œ WebSocket å¯¦ç¾ç„¡åˆ·æ–°æ•¸æ“šæ›´æ–°

4. **æœå‹™å™¨å„ªåŒ–**ï¼š
   - ä½¿ç”¨ Gunicorn å’Œ Nginx æé«˜è«‹æ±‚è™•ç†èƒ½åŠ›
   - å¯¦æ–½é©ç•¶çš„ç·©å­˜ç­–ç•¥ï¼Œæ¸›å°‘é‡è¤‡è¨ˆç®—
   - ä½¿ç”¨ç•°æ­¥ä»»å‹™è™•ç†é•·æ™‚é–“é‹è¡Œçš„æ“ä½œ

1. **Database Optimization**:
   - Using appropriate indexes to accelerate queries
   - Implementing database connection pool management
   - Optimizing query statements to reduce unnecessary joins and subqueries

2. **AI Model Optimization**:
   - Converting models to ONNX format to improve inference speed
   - Implementing batch processing mechanisms to reduce model loading overhead
   - Using mixed-precision computation to improve performance while maintaining accuracy

3. **Frontend Optimization**:
   - Using browser caching and CDN to accelerate static resource loading
   - Implementing lazy loading and code splitting to reduce initial loading time
   - Using AJAX and WebSocket for refresh-free data updates

4. **Server Optimization**:
   - Using Gunicorn and Nginx to improve request handling capacity
   - Implementing appropriate caching strategies to reduce repeated calculations
   - Using asynchronous task processing for long-running operations

### 5.4 ç³»çµ±æ“´å±•æ€§èˆ‡æœªä¾†ç™¼å±• (System Scalability and Future Development)

#### 5.4.1 æ¨¡çµ„åŒ–è¨­è¨ˆèˆ‡æ“´å±•æ€§ (Modular Design and Scalability)

Health Mirror ç³»çµ±æ¡ç”¨æ¨¡çµ„åŒ–è¨­è¨ˆï¼Œä¾¿æ–¼æœªä¾†æ“´å±•å’ŒåŠŸèƒ½å¢å¼·ï¼š

The Health Mirror system adopts a modular design, facilitating future expansion and functional enhancement:

1. **æ¨¡çµ„åŒ– AI æ¨¡å‹**ï¼šæ¯å€‹å¥åº·æª¢æ¸¬åŠŸèƒ½ä½¿ç”¨ç¨ç«‹çš„ AI æ¨¡å‹ï¼Œå¯ä»¥å–®ç¨æ›´æ–°å’Œå„ªåŒ–ï¼Œç„¡éœ€ä¿®æ”¹æ•´å€‹ç³»çµ±ã€‚
2. **å¯æ’æ‹”æ‡‰ç”¨æ¶æ§‹**ï¼šä½¿ç”¨ Django çš„æ‡‰ç”¨æ©Ÿåˆ¶ï¼Œå¯ä»¥è¼•é¬†æ·»åŠ æ–°çš„åŠŸèƒ½æ¨¡çµ„ï¼Œå¦‚ç‡Ÿé¤Šå»ºè­°ã€é‹å‹•è¿½è¹¤ç­‰ã€‚
3. **API å„ªå…ˆè¨­è¨ˆ**ï¼šç³»çµ±æä¾› RESTful APIï¼Œä¾¿æ–¼èˆ‡ç§»å‹•æ‡‰ç”¨ã€ç©¿æˆ´è¨­å‚™å’Œç¬¬ä¸‰æ–¹æœå‹™é›†æˆã€‚
4. **å¯æ“´å±•çš„æ•¸æ“šæ¨¡å‹**ï¼šæ•¸æ“šæ¨¡å‹è¨­è¨ˆè€ƒæ…®äº†æœªä¾†æ“´å±•ï¼Œä½¿ç”¨ JSONField å­˜å„²éˆæ´»çš„çµæ§‹åŒ–æ•¸æ“šã€‚

1. **Modular AI Models**: Each health detection function uses an independent AI model that can be updated and optimized individually without modifying the entire system.
2. **Pluggable Application Architecture**: Using Django's application mechanism, new functional modules such as nutrition advice and exercise tracking can be easily added.
3. **API-First Design**: The system provides RESTful APIs, facilitating integration with mobile applications, wearable devices, and third-party services.
4. **Extensible Data Models**: Data model design considers future expansion, using JSONField to store flexible structured data.

#### 5.4.2 æœªä¾†ç™¼å±•è·¯ç·šåœ– (Future Development Roadmap)

ç³»çµ±çš„æœªä¾†ç™¼å±•è¨ˆåŠƒåŒ…æ‹¬ï¼š

Future development plans for the system include:

1. **å¢å¼· AI èƒ½åŠ›**ï¼š
   - æ•´åˆæ›´å¤šå¥åº·æŒ‡æ¨™æª¢æ¸¬ï¼Œå¦‚ç–²å‹åº¦ã€å£“åŠ›æ°´å¹³ç­‰
   - å¯¦æ–½æ™‚åºåˆ†æï¼Œæä¾›é•·æœŸå¥åº·è¶¨å‹¢é æ¸¬
   - å¼•å…¥å€‹æ€§åŒ–å¥åº·å»ºè­°å¼•æ“

2. **æ“´å±•å¹³å°åŠŸèƒ½**ï¼š
   - é–‹ç™¼ç§»å‹•æ‡‰ç”¨ï¼Œæä¾›éš¨æ™‚éš¨åœ°çš„å¥åº·ç›£æ¸¬
   - å¢åŠ ç¤¾å€åŠŸèƒ½ï¼Œä¿ƒé€²ç”¨æˆ¶é–“çš„å¥åº·çŸ¥è­˜åˆ†äº«
   - å¯¦æ–½é ç¨‹é†«ç™‚è«®è©¢ï¼Œç›´æ¥é€£æ¥ç”¨æˆ¶å’Œé†«ç™‚å°ˆæ¥­äººå“¡

3. **æŠ€è¡“å‡ç´š**ï¼š
   - é·ç§»åˆ°å¾®æœå‹™æ¶æ§‹ï¼Œæé«˜ç³»çµ±å½ˆæ€§å’Œå¯æ“´å±•æ€§
   - å¯¦æ–½é‚Šç·£è¨ˆç®—ï¼Œæ¸›å°‘é›²ç«¯ä¾è³´ä¸¦æé«˜éŸ¿æ‡‰é€Ÿåº¦
   - å¼•å…¥è¯é‚¦å­¸ç¿’ï¼Œåœ¨ä¿è­·éš±ç§çš„åŒæ™‚æé«˜æ¨¡å‹æ€§èƒ½

1. **Enhanced AI Capabilities**:
   - Integrating more health indicator detection, such as fatigue level, stress level, etc.
   - Implementing time series analysis to provide long-term health trend predictions
   - Introducing personalized health recommendation engines

2. **Expanded Platform Functions**:
   - Developing mobile applications for health monitoring anytime, anywhere
   - Adding community features to promote health knowledge sharing among users
   - Implementing telemedicine consultation, directly connecting users and healthcare professionals

3. **Technical Upgrades**:
   - Migrating to microservice architecture to improve system resilience and scalability
   - Implementing edge computing to reduce cloud dependency and improve response speed
   - Introducing federated learning to improve model performance while protecting privacy

## 5.5 ç³»çµ±éƒ¨ç½²èˆ‡ç¶­è­·

æœ¬ç¯€è©³ç´°èªªæ˜ç³»çµ±çš„éƒ¨ç½²æµç¨‹å’Œç¶­è­·ç­–ç•¥ï¼Œç¢ºä¿ç³»çµ±åœ¨ç”Ÿç”¢ç’°å¢ƒä¸­ç©©å®šé‹è¡Œä¸¦èƒ½å¤ æŒçºŒå„ªåŒ–ã€‚

> **System Deployment and Maintenance**
>
> This section details the system deployment process and maintenance strategies to ensure stable operation in the production environment and continuous optimization.

### 5.5.1 éƒ¨ç½²æµç¨‹èˆ‡ç’°å¢ƒé…ç½®

ç³»çµ±æ¡ç”¨å®¹å™¨åŒ–éƒ¨ç½²æ–¹æ¡ˆï¼Œä½¿ç”¨Dockerå’ŒDocker Composeå¯¦ç¾ç’°å¢ƒä¸€è‡´æ€§å’Œå¿«é€Ÿéƒ¨ç½²ã€‚éƒ¨ç½²æµç¨‹åŒ…æ‹¬ä»¥ä¸‹æ­¥é©Ÿï¼š

1. **ç’°å¢ƒæº–å‚™**ï¼šé…ç½®ç”Ÿç”¢æœå‹™å™¨ï¼Œå®‰è£Dockerå’ŒDocker Composeï¼Œè¨­ç½®ç¶²çµ¡å’Œå®‰å…¨è¦å‰‡ã€‚

2. **å®¹å™¨åŒ–æ‡‰ç”¨**ï¼šå°‡Djangoæ‡‰ç”¨ã€AIæ¨¡å‹æœå‹™å’Œæ•¸æ“šåº«æœå‹™åˆ†åˆ¥æ‰“åŒ…ç‚ºDockerå®¹å™¨ã€‚

```dockerfile
# Dockerfile for Django Application
FROM python:3.9-slim

WORKDIR /app

# å®‰è£ç³»çµ±ä¾è³´
RUN apt-get update && apt-get install -y --no-install-recommends \
    build-essential libpq-dev \
    && rm -rf /var/lib/apt/lists/*

# å®‰è£Pythonä¾è³´
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# è¤‡è£½æ‡‰ç”¨ä»£ç¢¼
COPY . .

# æ”¶é›†éœæ…‹æ–‡ä»¶
RUN python manage.py collectstatic --noinput

# è¨­ç½®ç’°å¢ƒè®Šé‡
ENV DJANGO_SETTINGS_MODULE=mirror_project.settings.production
ENV PYTHONUNBUFFERED=1

# æš´éœ²ç«¯å£
EXPOSE 8000

# å•Ÿå‹•å‘½ä»¤
CMD ["gunicorn", "--bind", "0.0.0.0:8000", "mirror_project.wsgi:application"]
```

3. **ç·¨æ’æœå‹™**ï¼šä½¿ç”¨Docker Composeå®šç¾©å’Œç®¡ç†å¤šå®¹å™¨æ‡‰ç”¨ã€‚

```yaml
# docker-compose.yml
version: '3.8'

services:
  db:
    image: postgres:13
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    env_file:
      - ./.env.db
    restart: always
  
  redis:
    image: redis:6
    volumes:
      - redis_data:/data
    restart: always
  
  web:
    build: .
    volumes:
      - static_volume:/app/staticfiles
      - media_volume:/app/media
    depends_on:
      - db
      - redis
    env_file:
      - ./.env.prod
    restart: always
  
  celery:
    build: .
    command: celery -A mirror_project worker -l info
    volumes:
      - ./:/app/
    depends_on:
      - db
      - redis
    env_file:
      - ./.env.prod
    restart: always
  
  nginx:
    image: nginx:1.21
    volumes:
      - ./nginx/conf.d:/etc/nginx/conf.d
      - static_volume:/home/app/staticfiles
      - media_volume:/home/app/media
    ports:
      - "80:80"
      - "443:443"
    depends_on:
      - web
    restart: always

volumes:
  postgres_data:
  redis_data:
  static_volume:
  media_volume:
```

4. **CI/CDæµç¨‹**ï¼šå¯¦ç¾æŒçºŒé›†æˆå’ŒæŒçºŒéƒ¨ç½²ï¼Œè‡ªå‹•åŒ–æ¸¬è©¦å’Œéƒ¨ç½²éç¨‹ã€‚

```yaml
# .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: '3.9'
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      - name: Run tests
        run: |
          python manage.py test
  
  deploy:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to server
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.SSH_KEY }}
          script: |
            cd /path/to/project
            git pull
            docker-compose -f docker-compose.prod.yml down
            docker-compose -f docker-compose.prod.yml up -d --build
```

> **Deployment Process and Environment Configuration**
>
> The system adopts a containerized deployment solution using Docker and Docker Compose to achieve environment consistency and rapid deployment. The deployment process includes the following steps:
>
> 1. **Environment Preparation**: Configure production servers, install Docker and Docker Compose, set up network and security rules.
>
> 2. **Containerize Applications**: Package Django applications, AI model services, and database services as separate Docker containers.
>
> 3. **Service Orchestration**: Use Docker Compose to define and manage multi-container applications.
>
> 4. **CI/CD Process**: Implement continuous integration and continuous deployment to automate testing and deployment processes.

### 5.5.2 ç³»çµ±ç›£æ§èˆ‡ç¶­è­·ç­–ç•¥

ç‚ºç¢ºä¿ç³»çµ±ç©©å®šé‹è¡Œï¼Œæˆ‘å€‘å¯¦æ–½äº†å…¨é¢çš„ç›£æ§å’Œç¶­è­·ç­–ç•¥ï¼š

1. **æ€§èƒ½ç›£æ§**ï¼šä½¿ç”¨Prometheuså’ŒGrafanaå»ºç«‹ç›£æ§å„€è¡¨æ¿ï¼Œå¯¦æ™‚ç›£æ§ç³»çµ±è³‡æºä½¿ç”¨æƒ…æ³ã€éŸ¿æ‡‰æ™‚é–“å’ŒéŒ¯èª¤ç‡ã€‚

```yaml
# prometheus.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'django'
    static_configs:
      - targets: ['web:8000']
  
  - job_name: 'nginx'
    static_configs:
      - targets: ['nginx-exporter:9113']
  
  - job_name: 'postgres'
    static_configs:
      - targets: ['postgres-exporter:9187']
  
  - job_name: 'redis'
    static_configs:
      - targets: ['redis-exporter:9121']
```

2. **æ—¥èªŒç®¡ç†**ï¼šé›†ä¸­æ”¶é›†å’Œåˆ†æç³»çµ±æ—¥èªŒï¼Œä½¿ç”¨ELK Stackï¼ˆElasticsearch, Logstash, Kibanaï¼‰å¯¦ç¾æ—¥èªŒå¯è¦–åŒ–å’Œç•°å¸¸æª¢æ¸¬ã€‚

```python
# settings.py æ—¥èªŒé…ç½®
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'file': {
            'level': 'INFO',
            'class': 'logging.FileHandler',
            'filename': '/var/log/django/mirror.log',
            'formatter': 'verbose',
        },
        'console': {
            'level': 'INFO',
            'class': 'logging.StreamHandler',
            'formatter': 'verbose',
        },
    },
    'loggers': {
        'django': {
            'handlers': ['file', 'console'],
            'level': 'INFO',
            'propagate': True,
        },
        'base': {
            'handlers': ['file', 'console'],
            'level': 'INFO',
            'propagate': True,
        },
    },
}
```

3. **è‡ªå‹•å‚™ä»½**ï¼šå¯¦æ–½å®šæœŸæ•¸æ“šåº«å‚™ä»½ç­–ç•¥ï¼Œç¢ºä¿æ•¸æ“šå®‰å…¨ã€‚

```bash
#!/bin/bash
# backup.sh - è‡ªå‹•å‚™ä»½è…³æœ¬

DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR=/var/backups/postgres

# å‰µå»ºå‚™ä»½ç›®éŒ„
mkdir -p $BACKUP_DIR

# åŸ·è¡Œæ•¸æ“šåº«å‚™ä»½
docker exec mirror_db_1 pg_dump -U postgres -d mirror_db > $BACKUP_DIR/mirror_db_$DATE.sql

# å£“ç¸®å‚™ä»½æ–‡ä»¶
gzip $BACKUP_DIR/mirror_db_$DATE.sql

# åˆªé™¤7å¤©å‰çš„å‚™ä»½
find $BACKUP_DIR -name "*.gz" -mtime +7 -delete

# ä¸Šå‚³åˆ°é ç¨‹å­˜å„²
aws s3 cp $BACKUP_DIR/mirror_db_$DATE.sql.gz s3://mirror-backups/
```

4. **æ›´æ–°èˆ‡è£œä¸ç®¡ç†**ï¼šå»ºç«‹ç³»çµ±æ›´æ–°æµç¨‹ï¼Œå®šæœŸæ‡‰ç”¨å®‰å…¨è£œä¸å’ŒåŠŸèƒ½æ›´æ–°ã€‚

5. **å®¹é‡è¦åŠƒ**ï¼šæ ¹æ“šä½¿ç”¨è¶¨å‹¢é€²è¡Œå®¹é‡è¦åŠƒï¼Œç¢ºä¿ç³»çµ±è³‡æºå……è¶³ã€‚

6. **ç½é›£æ¢å¾©è¨ˆåŠƒ**ï¼šåˆ¶å®šè©³ç´°çš„ç½é›£æ¢å¾©è¨ˆåŠƒï¼ŒåŒ…æ‹¬å‚™ä»½æ¢å¾©ã€æœå‹™é·ç§»å’Œæ•…éšœè½‰ç§»ç­–ç•¥ã€‚

> **System Monitoring and Maintenance Strategy**
>
> To ensure stable system operation, we have implemented comprehensive monitoring and maintenance strategies:
>
> 1. **Performance Monitoring**: Use Prometheus and Grafana to establish monitoring dashboards, real-time monitoring of system resource usage, response time, and error rates.
>
> 2. **Log Management**: Centrally collect and analyze system logs, using the ELK Stack (Elasticsearch, Logstash, Kibana) to achieve log visualization and anomaly detection.
>
> 3. **Automatic Backup**: Implement regular database backup strategies to ensure data security.
>
> 4. **Updates and Patch Management**: Establish system update processes, regularly apply security patches and feature updates.
>
> 5. **Capacity Planning**: Conduct capacity planning based on usage trends to ensure sufficient system resources.
>
> 6. **Disaster Recovery Plan**: Develop detailed disaster recovery plans, including backup recovery, service migration, and failover strategies.

---

## çµè«– (Conclusion)

Health Mirror ä»¥é¢éƒ¨å½±åƒ AI ç‚ºåˆ‡å…¥é»ï¼Œå°‡å³æ™‚æª¢æ¸¬ã€å€‹äººåŒ–è¿½è¹¤èˆ‡é†«ç™‚é ç´„æ•´åˆç‚ºé–‰ç’°æœå‹™ï¼Œå›æ‡‰äº†å¥åº·å¯åŠæ€§èˆ‡é é˜²é†«ç™‚çš„æ ¸å¿ƒè¨´æ±‚ã€‚é€éã€Œæ•æ· + é¢¨éšªé©…å‹• + DevOpsã€çš„å°ˆæ¡ˆæ–¹æ³•è«–ï¼Œæœ¬å°ˆæ¡ˆåœ¨ä¿éšœå‰µæ–°é€Ÿåº¦çš„åŒæ™‚ï¼Œå»ºç«‹äº†å¯é©—è­‰çš„å“è³ªé–€æª»èˆ‡å¯ç¶­é‹çš„å·¥ç¨‹åŸºç¤ã€‚æœªä¾†å·¥ä½œå°‡èšç„¦æ–¼æ¨¡å‹æ³›åŒ–èƒ½åŠ›æå‡ã€æ›´å¤šå¥åº·æŒ‡æ¨™æ‹“å±•ã€åˆè¦èˆ‡éš±ç§å¼·åŒ–ï¼Œä»¥åŠé†«ç™‚ç”Ÿæ…‹åˆä½œæ·±åŒ–ï¼ŒæŒçºŒå°‡æŠ€è¡“èƒ½åŠ›è½‰åŒ–ç‚ºå¯è¢«ä¸åŒäººç¾¤å…¬å¹³ä½¿ç”¨çš„å¥åº·æœå‹™åƒ¹å€¼ã€‚

By fusing real-time facial AI detection, personalization, and appointment integration, Health Mirror addresses accessibility and preventive healthcare needs. A hybrid of Agile, risk-driven governance, and DevOps balances innovation with quality and operability. Future work will strengthen model generalization, expand indicators, deepen compliance and privacy, and broaden healthcare partnershipsâ€”continually translating technical capability into equitable health value for diverse populations.